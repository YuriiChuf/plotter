
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Конвертер JPEG/PNG/SVG в G-code для Sovol SO-1</title>
<style>
    body {
        font-family: Arial, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background-color: #f5f5f5;
    }
    .main-container {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        align-items: start;
    }
    .left-panel {
        display: grid;
        grid-template-rows: auto auto;
        gap: 20px;
        height: fit-content;
    }
    .right-panel {
        display: grid;
        grid-template-rows: auto auto;
        gap: 20px;
        height: fit-content;
    }
    .panel {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        min-height: 0;
    }

    .image-upload-panel,
    .original-image-panel {
        grid-row: 1;
		height: 601px;
    }
    .tracing-settings-panel,
    .vector-preview-panel {
        grid-row: 2;
		height: 601px;
    }
    .canvas-container {
        position: relative;
        width: 100%;
        margin-bottom: 20px;
    }
    canvas {
        border: 1px solid #ddd;
        max-width: 100%;
        background: white;
        display: block;
    }
    .canvas-frame {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        box-sizing: border-box;
    }
    .controls {
        display: flex;
        flex-direction: column;
        gap: 8px;
    }
    input, select, button {
        padding: 6px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }
    button {
        background: #007cba;
        color: white;
        border: none;
        padding: 8px;
    }
    button:hover {
        background: #005a87;
    }
	button:disabled {
		background: #cccccc !important;
		color: #666666 !important;
		opacity: 0.6;
	}
	
    .gcode-output {
        width: 100%;
        height: 300px;
        font-family: monospace;
        font-size: 12px;
        resize: vertical;
    }
    .status {
        padding: 10px;
        margin: 10px 0;
        border-radius: 4px;
    }
    .success {
        background: #d4edda;
        color: #155724;
    }
    .error {
        background: #f8d7da;
        color: #721c24;
    }
    h1, h2, h3 {
        color: #333;
    }
	.butsett {
		background: #CDD0D3;
		color: black;
		border: none;
		border-radius: 2px;
		font-size: 12px;
		line-height: 1;
		width: 100%;
		margin-top: 0px;
	}
	.butsett:hover {
		background: #E2E4E7;
		color: black;
	}
    .setting-group {
		margin-top: 20px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        font-size: 15px;
    }
    .compact-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
        align-items: end;
	}

    .compact-group > div {
        display: flex;
        flex-direction: column;
        gap: 10px;
    }
	.path-info {
		font-size: 12px;
		color: #333;
		margin-top: 8px;
		line-height: 1.3;
		min-height: 20px;
		background: rgba(255, 255, 255, 0.8);
		padding: 4px 8px;
		border-radius: 4px;
		display: inline-block;
	}
	.info-text-1 {
        font-size: 11px;
        color: #666;
        margin-top: 0px;
        margin-bottom: -11px;
        line-height: 1.2;
    }
	 .info-text {
        font-size: 11px;
        color: #666;
        margin-top: -4px;
        margin-bottom: 8px;
        line-height: 1.2;
    }
	.button-group button.active {
		background: #005a87;
		border: 2px solid #003d5c;
	}

	.button-2-group {
		display: grid;
		grid-template-columns: 3fr 0.95fr 1.2fr 0.2fr 0.5fr;
		gap: 10px;
		align-items: center;
		margin-top: -30px;
	}

	.button-group {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr;
		gap: 10px;
	}

	.button-2-group button,
	.button-group button {
		height: 35px;
		min-height: 35px;
		padding: 8px 5px;
		font-size: 13px;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
	}

    .dimension-inputs span {
        text-align: center;
        font-weight: bold;
    }
    .legend {
        display: flex;
        gap: 12px;
        margin-top: 8px;
        font-size: 11px;
        flex-wrap: wrap;
    }
    .legend-item {
        display: flex;
        align-items: center;
        gap: 4px;
		margin-top: -10px;
    }
    .legend-color {
        width: 12px;
        height: 2px;
        display: inline-block;
    }
    .file-info {
        background: #f8f9fa;
        padding: 6px;
        border-radius: 4px;
        margin-top: 4px;
        font-size: 11px;
        line-height: 1.3;
		height: 50px;
    }
    
    .tracing-settings .controls {
        gap: 10px;
    }
    
    .tracing-settings label {
        font-size: 13px;
        margin-bottom: 2px;
    }
    
    .tracing-settings input,
    .tracing-settings select {
        padding: 5px;
        font-size: 13px;
    }
    
    .tracing-settings .setting-group {
        gap: 6px;
    }
    
    .position-controls {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 2px;
        margin-top: 0px;
    }
    
    .position-controls h4 {
        margin: 0 0 5px 0;
        font-size: 14px;
        color: #333;
    }
    
    .lock-proportions {
        display: flex;
        align-items: center;
        gap: 6px;
        margin-top: 4px;
    }
    
    .lock-proportions input {
        margin: 0;
    }
    
    .lock-proportions label {
        font-size: 12px;
        cursor: pointer;
    }

	.layout-toggle {
		position: fixed;
		top: 20px;
		right: 20px;
		background: rgba(255,255,255,0.95);
		padding: 8px 15px;
		border-radius: 20px;
		font-size: 12px;
		cursor: pointer;
		border: 1px solid #ddd;
		z-index: 1000;
		box-shadow: 0 2px 8px rgba(0,0,0,0.15);
	}

	.layout-toggle:hover {
		background: white;
		box-shadow: 0 2px 12px rgba(0,0,0,0.2);
	}

	.eraser-cursor {
		cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20"><circle cx="10" cy="10" r="8" fill="none" stroke="red" stroke-width="1"/><circle cx="10" cy="10" r="2" fill="red"/></svg>') 10 10, auto;
	}

	#eraserTool.active {
		background: #005a87;
		border: 2px solid #003d5c;
		font-weight: bold;
	}
	.position-group {
		display: grid;
		grid-template-columns: 1fr 1fr 1fr;
		gap: 15px;
		align-items: start;
	}

	.position-group > div {
		display: flex;
		flex-direction: column;
		gap: 8px;
	}

	.position-group label {
		font-weight: bold;
		margin: 0;
		font-size: small;
	}

	.input-row {
		display: flex;
		align-items: center;
		gap: 5px;
	}

	.position-group input[type="number"] {
		height: 32px;
		width: 80px;
		box-sizing: border-box;
		padding: 4px 8px;
	}

	.align-btn {
		width: 30px;
		height: 30px;
		padding: 0;
		background: #507657;
		color: white;
		border: none;
		border-radius: 4px;
		cursor: pointer;
		font-size: 25px;
		display: flex;
		align-items: center;
		justify-content: center;
		flex-shrink: 0;
		padding-bottom: 4px;
	}


	#imageInput {
		width: 80%;
		padding: 15px;
		border: 2px dashed #ccc;
		border-radius: 8px;
		background: #F1F1F1;
		cursor: pointer;
		transition: all 0.3s ease;
	}

	#imageInput:hover {
		border-color: #2CC00C;
		background: #D5FDCE;
	}

	#imageInput::file-selector-button {
	display: none;

	}


</style>
</head>
<body>
    <h1>Конвертер JPEG/PNG/SVG в G-code для Sovol SO-1</h1>
    
    <div class="layout-toggle" id="layoutToggle">☻☺☺</div>
    
    <div class="main-container" id="mainContainer">
        <!-- ЛЕВАЯ КОЛОНКА -->
        <div class="left-panel">
            <!-- ВЕРХНИЙ ЛЕВЫЙ БЛОК: Загрузка изображения -->
            <div class="panel image-upload-panel">
                <h3>Загрузка изображения</h3>
                <div>
                    <input type="file" id="imageInput" accept=".jpg,.jpeg,.png,.bmp,.gif,.svg" autocomplete="off" title="Кликни или брось в меня файл"/>
                    
                </div>
              
                <div class="controls">
                    <div class="setting-group">
						<div><label style="
						display: inline-block; 
						margin-right: 12px;
						font-size: 18px;
						font-weight: bold;
						">Настройки для плоттера:</label>
        <button id="resetPlotterSettings" title="Сбросить настройки плоттера" class="butsett">⟲ Сброс</button></div>
                        <div>
                        <label>Пауза G4 (мс):</label>
                        <input type="number" id="pauseTime" value="100" min="50" max="500">
						</div> 
				   </div> 
				   <div class="setting-group">
                        <div>
                            <label>Скорость перемещения (мм/мин):</label>
                            <input type="number" id="travelSpeed" value="3000" min="500" max="5000">
                        </div>
                        <div>
                            <label>Скорость рисования (мм/мин):</label>
                            <input type="number" id="drawSpeed" value="1500" min="500" max="3000">
                        </div>
                    
                        <div>
                            <label>Начало X (мм):</label>
                            <input type="number" id="startX" value="0" step="1">
							<label for="showCrosshair" style="font-size: 10px;">Прицел:</label><input type="checkbox" id="showCrosshair" checked>
                        </div>
                        <div>
                            <label>Начало Y (мм):</label>
                            <input type="number" id="startY" value="0" step="1">
                        </div>

                        <div>
                            <label>Ширина листа (мм):</label>
                            <input type="number" id="sheetWidth" value="210" min="10" max="500" step="1">
                        </div>
                        <div>
                            <label>Высота листа (мм):</label>
                            <input type="number" id="sheetHeight" value="297" min="10" max="500" step="1">     <input title='Новый рисунок &#10;вписываем в лист' type="radio" id="fitToSheet" name="fitOption" value="sheet" checked>
                        </div>

                        <div>
                            <label>Ширина области (мм):</label>
                            <input type="number" id="areaWidth" value="210" min="10" max="500" step="1">  
                            <label for="lockProportions" style="font-size: 10px;" >Пропорции:</label>
                            <input type="checkbox" id="lockProportions" checked >
                            
                        </div>
                        <div>
                            <label>Высота области (мм):</label>
                            <input type="number" id="areaHeight" value="297" min="10" max="500" step="1">     <input title='Новый рисунок &#10;вписываем в область' type="radio" id="fitToArea" name="fitOption" value="area">
                        </div>
                    </div>
                    
                    <div class="position-controls">
                    <h4>Позиционирование рисунка</h4>
						<div class="position-group">
							<div>
								<label>Смещение X</label>
								<div class="input-row">
									<input type="number" id="offsetX" value="0" step="1" placeholder="мм">
									<button type="button" id="centerX" class="align-btn">⬌</button>
								</div>
							</div>
							
							<div>
								<label>Смещение Y</label>
								<div class="input-row">
									<input type="number" id="offsetY" value="0" step="1" placeholder="мм">
									<button type="button" id="centerY" class="align-btn">⬍</button>
								</div>
							</div>
							
							<div>
								<label>Вращение</label>
								<div class="input-row">
									<input type="number" id="rotation" value="0" min="-180" max="180" step="1" placeholder="°">
								</div>
							</div>
						</div>
                        <div class="info-text-1">Смещение считается от нижнего левого угла листа</div>
                    </div>
                </div>
            </div>
            
            <!-- НИЖНИЙ ЛЕВЫЙ БЛОК: Настройки трассировки -->
            <div class="panel tracing-settings-panel">
                <h3>Настройки</h3>
                <div class="controls">
                    <div class="compact-group">
						<div>
                        <label>Метод конвертации:</label>
						<select id="conversionMethod">
                            <!-- Опции будут заполняться динамически -->
                        </select><div id="centerlineOptions" style="display: none;">
							<label for="removeSpursCheckbox" style="font-size: 9px;" >Отростки</label><input title="Удаление отростков" type="checkbox" id="removeSpursCheckbox" checked>
							<label for="removeParallelCheckbox" style="font-size: 9px;" >Паралельные</label><input text="про" title="Удаление параллельных" type="checkbox" id="removeParallelCheckbox" checked>
							<label for="connectCrossroadsCheckbox" style="font-size: 9px;" >Перекрестки</label><input title="Обработка перекрестков" type="checkbox" id="connectCrossroadsCheckbox" checked>
							<label for="continuePathsCheckbox" style="font-size: 9px;" >Путь</label><input title="Продолжение путей" type="checkbox" id="continuePathsCheckbox" checked>
						</div></div>

						<div><button id="resetBottomSettings" title="Сбросить настройки трассировки" class="butsett">⟲ Сброс</button>
                        </div>
						<div>
                            <label>Расширение области (мм):</label>
                            <input type="number" id="lineThickness" value="0.0" min="0.0" max="5" step="0.1">
                            <div class="info-text">Увеличивает черные области перед заливкой</div>
                        </div>
                        
                        <div>
							<label>Сужение области (мм):</label>
							<input type="number" id="borderOffset" value="0" min="0" max="1" step="0.1">
							<div class="info-text">Компенсация ширины пера</div>
                        </div>
                    </div>
                    
                    <div class="compact-group">


                        <div>
                            <label>Шаг штриховки (мм):</label>
                            <input type="number" id="hatchStep" value="0.5" min="0.1" max="10" step="0.1">
                            <div class="info-text">Расстояние между линиями штриховки</div>
                        </div>
                        <div>
                            <label>Угол штриховки (°):</label>
                            <input type="number" id="hatchAngle" value="0" min="0" max="180" step="1">
                            <div class="info-text">0° - горизонтально, 90° - вертикально</div>
                        </div>

                        <div>
                            <label>Соединение линий (мм):</label>
                            <input type="number" id="connectDistance" value="1" min="0.1" max="100" step="0.1">
                            <div class="info-text">Макс. расстояние для непрерывного рисования</div>
                        </div>
                        <div>
                            <label>Минимальная длина линии (мм):<input title='Показывать или нет&#10;Удаляются всегда' type="checkbox" id="showRemovedPaths" checked></label>
                            <input type="number" id="minLineLength" value="0.5" min="0.1" max="100" step="0.1">
                            <div class="info-text">Линии короче этой будут удалены</div>
                        </div>
						<div>
                            <label>Инвертировать изображение:</label>
                            <select id="invertImage">
                                <option value="false">Нет</option>
                                <option value="true">Да</option>
                            </select>
                            <div class="info-text">белое это черное</div>
                        </div>
                        <div>
                            <label>Порог яркости (0-255):</label>
                            <input type="number" id="threshold" value="128" min="0" max="255">
                            <div class="info-text">Интенсивность света</div>
                        </div>
                    </div>
                    <div style="margin-top: 5px;">
                        <input type="range" id="thresholdSlider" min="0" max="255" value="128" style="width: 100%; margin-top: 4px;">
                    </div>

                </div>
            </div>
        </div>
        
        <!-- ПРАВАЯ КОЛОНКА -->
        <div class="right-panel">
            <!-- ВЕРХНИЙ ПРАВЫЙ БЛОК: Исходное изображение -->
    <div class="panel original-image-panel">
        <h3>Исходное изображение</h3>
        <div class="canvas-container">
            <canvas id="imagePreview"></canvas>
            <div id="imageFrame" class="canvas-frame"></div>
            <div id="sheetFrame" class="canvas-frame"></div>
        </div>
        <div id="imageInfo" class="info-text"></div>
    </div>
            
            <!-- НИЖНИЙ ПРАВЫЙ БЛОК: Векторный предпросмотр -->
            <div class="panel vector-preview-panel">
                <h3>Векторный предпросмотр</h3>
                <div class="canvas-container">
                    <canvas id="vectorPreview"></canvas>
                    <div id="vectorFrame" class="canvas-frame"></div>
                    <div id="vectorSheetFrame" class="canvas-frame"></div>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ffebb8;"></span>
                        <span>Исходные пути</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: black;"></span>
                        <span>Оптимизированные пути</span>
                    </div>
                    <div class="legend-item">
                        <span class="legend-color" style="background: #ff4444;"></span>
                        <span>Удаленные линии</span>
					</div>
					<span id="pathInfo" class="info-text"></span>
                </div>
            </div>
        </div>
    </div>

    <div class="panel">
	<div class="button-2-group">
	<div id="status" class="status"></div>
        <button id="eraserTool" disabled>Ластик</button>
        <input type="range" id="eraserSize" min="1" max="50" value="10" style=" display: inline-block;">
        <span id="eraserSizeValue">10px</span>
		<button id="resetImageBtn" >Исходник</button>

	 </div>
	<div class="button-group">
                    <button id="convertBtn" disabled>Конвертировать в G-code</button>
                    <button id="downloadBtn" disabled>Скачать G-code</button>
                    <button id="downloadSvgBtn" disabled>Скачать SVG</button>
         </div>
		 
				
        <h3>G-code для Sovol SO-1</h3>
        <textarea id="gcodeOutput" class="gcode-output" placeholder="G-code появится здесь после конвертации..."></textarea>
    </div>

<div id="loadingIcon" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 50px; z-index: 10000; color: #007cba;">
    ⏳
</div>

   <script>
        // Элементы DOM
		const imageInput = document.getElementById('imageInput');
        const convertBtn = document.getElementById('convertBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const downloadSvgBtn = document.getElementById('downloadSvgBtn');
        const imagePreview = document.getElementById('imagePreview');
        const vectorPreview = document.getElementById('vectorPreview');
        const gcodeOutput = document.getElementById('gcodeOutput');
        const statusDiv = document.getElementById('status');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const thresholdInput = document.getElementById('threshold');
        const pathInfo = document.getElementById('pathInfo');
        const imageInfo = document.getElementById('imageInfo');
        const areaWidthInput = document.getElementById('areaWidth');
        const areaHeightInput = document.getElementById('areaHeight');
        const sheetWidthInput = document.getElementById('sheetWidth');
        const sheetHeightInput = document.getElementById('sheetHeight');
        const imageFrame = document.getElementById('imageFrame');
        const vectorFrame = document.getElementById('vectorFrame');
        const sheetFrame = document.getElementById('sheetFrame');
        const vectorSheetFrame = document.getElementById('vectorSheetFrame');
        const connectDistanceInput = document.getElementById('connectDistance');
        const minLineLengthInput = document.getElementById('minLineLength');
        const conversionMethod = document.getElementById('conversionMethod');
        const offsetXInput = document.getElementById('offsetX');
        const offsetYInput = document.getElementById('offsetY');
        const rotationInput = document.getElementById('rotation');
		const showCrosshair = document.getElementById('showCrosshair');
		const startXInput = document.getElementById('startX');
		const startYInput = document.getElementById('startY');
        const lockProportions = document.getElementById('lockProportions');
        const imageCtx = imagePreview.getContext('2d');
        const vectorCtx = vectorPreview.getContext('2d');
        // Переменные
		let eraserAnimationFrame = null;
        let originalImage = null;
        let imageData = null;
        let vectorPaths = [];
        let pixelToMM = 1;
        let optimizedPaths = [];
        let filteredPaths = [];
        let currentGcode = '';
        let canvasWidth = 500;
        let canvasHeight = 500;
        let currentFileName = '';
        let imageAspectRatio = 1; 
		let layoutState = 0;
		let isSvgFile = false;
		let svgPaths = [];
		let currentTool = 'none';
		let eraserSize = 10;
		let vectorUpdateTimeout = null;
		let lastVectorUpdateTime = 0;
		let vectorSnapshot = null;
		let eraserEnabled = false;
		let selectedPaths = new Set();
		let imageEditMode = false;
		let editedImageData = null;
		let originalImageData = null;
		let isMouseDown = false;
		let lastEraseTime = 0;
		let vectorUpdateTimer = null;
		let erasePoints = []; 
		let isErasing = false;
		let isEraserActive = false;
		let currentEraserCanvas = null;
		let showRemovedPaths = true;
		let transformedImageCache = null;
		let cacheKey = '';
		let currentTransformation = {
    offsetX: 0,
    offsetY: 0,
    rotation: 0,
    areaWidth: 210,
    areaHeight: 297
};
		const ERASE_THROTTLE = 16; 
		const VECTOR_UPDATE_DELAY = 1000; 
		const VECTOR_UPDATE_DELAY_AFTER_ERASE = 1000; 

		const PERFORMANCE_SETTINGS = {
			MAX_FLOODFILL_POINTS: 5000,  
			PIXEL_SKIP: 2,                 // Пропуск пикселей при отрисовке
			AREA_MIN_SIZE: 5,              // Минимальный размер области
			PROGRESS_UPDATE_INTERVAL: 5    // Частота обновления прогресса (строк)
		};
		const style = document.createElement('style');
		style.textContent = `
			.eraser-cursor {
				cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${Math.max(20, eraserSize * 2)}" height="${Math.max(20, eraserSize * 2)}" viewBox="0 0 ${Math.max(20, eraserSize * 2)} ${Math.max(20, eraserSize * 2)}"><circle cx="${Math.max(10, eraserSize)}" cy="${Math.max(10, eraserSize)}" r="${eraserSize}" fill="none" stroke="red" stroke-width="1"/><circle cx="${Math.max(10, eraserSize)}" cy="${Math.max(10, eraserSize)}" r="2" fill="red"/></svg>') ${Math.max(10, eraserSize)} ${Math.max(10, eraserSize)}, auto;
			}
			
			#eraserTool.active {
				background: #005a87;
				border: 2px solid #003d5c;
				font-weight: bold;
			}
			
			#eraserTool {
				transition: all 0.2s ease;
			}
		`;
		document.head.appendChild(style);

document.querySelectorAll('#removeSpursCheckbox, #removeParallelCheckbox, #connectCrossroadsCheckbox, #continuePathsCheckbox').forEach(checkbox => {
    checkbox.addEventListener('change', function() {
			if (originalImage || isSvgFile) {
				processAndDrawVectors();
			}
    });
});

function toggleCenterlineOptions() {
    const centerlineOptions = document.getElementById('centerlineOptions');
    const conversionMethod = document.getElementById('conversionMethod');
    
    if (conversionMethod.value === 'centerline') {
        centerlineOptions.style.display = 'block';
    } else {
        centerlineOptions.style.display = 'none';
    }
}
		function showLoading() {
			document.getElementById('loadingIcon').style.display = 'block';
		}
		function hideLoading() {
			document.getElementById('loadingIcon').style.display = 'none';
		}

		// Функция для применения ластика к исходному изображению
		function updateEditedImageDisplay() {
			if (!editedImageData) return;
			const tempCanvas = document.createElement('canvas');
			tempCanvas.width = editedImageData.width;
			tempCanvas.height = editedImageData.height;
			const tempCtx = tempCanvas.getContext('2d');
			tempCtx.putImageData(editedImageData, 0, 0);
			const editedImage = new Image();
			editedImage.onload = function() {
				displayImage(editedImage);
				originalImage = editedImage;
			};
			editedImage.src = tempCanvas.toDataURL();
		}

		// ПОЛНАЯ ОЧИСТКИ ПАМЯТИ
		function clearAllImageData() {
			originalImage = null;
			imageData = null;
			vectorPaths = [];
			optimizedPaths = [];
			filteredPaths = [];
			currentGcode = '';
			vectorSnapshot = null;
			svgPaths = [];
			editedImageData = null;
			originalImageData = null;
			currentTool = 'none';
			eraserEnabled = false;
			imageEditMode = false;
			isMouseDown = false;
			isErasing = false;
			erasePoints = [];
			eraseHistory = [];
			currentHistoryIndex = -1;
			imageCtx.fillStyle = 'white';
			imageCtx.fillRect(0, 0, imagePreview.width, imagePreview.height);
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
			pathInfo.textContent = '';
			imageInfo.textContent = '';
			gcodeOutput.value = '';
			downloadBtn.disabled = true;
			downloadSvgBtn.disabled = true;
			document.getElementById('eraserTool').classList.remove('active');
			vectorPreview.classList.remove('eraser-cursor');
			imagePreview.classList.remove('eraser-cursor');
			document.getElementById('eraserTool').classList.remove('active');
			vectorPreview.classList.remove('eraser-cursor');
			imagePreview.classList.remove('eraser-cursor');
			vectorPreview.style.cursor = 'default';
			imagePreview.style.cursor = 'default';

			updateUndoButton();
			updateStatus('Память очищена', 'success');
		}


		// Функция сброса редактирования
		function resetImageEdit(noHistory = false) {
			if (!originalImageData) return;
			
			if (!noHistory) {
				saveToHistory();
			}
			
			editedImageData = new ImageData(
				new Uint8ClampedArray(originalImageData.data),
				originalImageData.width,
				originalImageData.height
			);
			
			updateEditedImageDisplay();
			if (originalImage && !isSvgFile) {
				processAndDrawVectors(noHistory);
			}
			updateStatus('Изображение восстановлено' + (noHistory ? '' : ' (действие добавлено в историю)'), 'success');
		}

		// Функция для обновления курсора ластика
		function updateEraserCursor() {
			const cursorSize = Math.max(20, eraserSize * 2);
			const cursorSVG = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${cursorSize}" height="${cursorSize}" viewBox="0 0 ${cursorSize} ${cursorSize}"><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="${eraserSize}" fill="none" stroke="red" stroke-width="1"/><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="2" fill="red"/></svg>`;
			
			vectorPreview.style.cursor = `url('${cursorSVG}') ${cursorSize/2} ${cursorSize/2}, auto`;
			imagePreview.style.cursor = `url('${cursorSVG}') ${cursorSize/2} ${cursorSize/2}, auto`;
		}
		
        // Функция для обновления доступных методов в зависимости от типа файла
		function updateConversionMethods() {
			const currentValue = conversionMethod.value;
			
			conversionMethod.innerHTML = '';
			
			if (isSvgFile) {
				conversionMethod.appendChild(new Option('SVG пути (прямая конвертация)', 'svg'));
				conversionMethod.appendChild(new Option('Трассировка по центру линии', 'centerline'));
				conversionMethod.appendChild(new Option('Заливка', 'fill'));
				conversionMethod.appendChild(new Option('Штриховка', 'hatch'));
				conversionMethod.appendChild(new Option('Контуры', 'contour'));
			} else {
				conversionMethod.appendChild(new Option('Трассировка по центру линии', 'centerline'));
				conversionMethod.appendChild(new Option('Заливка', 'fill'));
				conversionMethod.appendChild(new Option('Штриховка', 'hatch'));
				conversionMethod.appendChild(new Option('Контуры', 'contour'));
			}

			if (conversionMethod.querySelector(`[value="${currentValue}"]`)) {
				conversionMethod.value = currentValue;
			}
		}

		thresholdSlider.addEventListener('input', function() {
			thresholdInput.value = this.value;
			showTemporaryImage();
			scheduleVectorUpdate();

		});

		thresholdInput.addEventListener('input', function() {
			thresholdSlider.value = this.value;
			showTemporaryImage();
			scheduleVectorUpdate();

		});

		// Настройки толщины линий
		function getLineSettings(type) {
			const settings = {
				original: { width: 1, color: '#ffebb8', dash: [] },
				optimized: { width: 1, color: 'black', dash: [] },
				filtered: { width: 1, color: '#ff4444', dash: [] },
				crosshair: { width: 0.5, color: '#ff0000', dash: [] }
			};
			return settings[type] || settings.optimized;
		}

		// Функция применения стилей к контексту
		function applyLineStyle(ctx, type) {
			const style = getLineSettings(type);
			ctx.lineWidth = style.width;
			ctx.strokeStyle = style.color;
			ctx.setLineDash(style.dash);
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
		}

		// Функция для сохранения векторов как изображения
		function saveVectorSnapshot() {
			if (!originalImage && !isSvgFile) return;
			
			const tempCanvas = document.createElement('canvas');
			tempCanvas.width = vectorPreview.width;
			tempCanvas.height = vectorPreview.height;
			const tempCtx = tempCanvas.getContext('2d');
			
			tempCtx.fillStyle = 'white';
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
			
			drawVectorPaths(tempCtx, tempCanvas);
			
			vectorSnapshot = new Image();
			vectorSnapshot.onload = function() {
				redrawVectorCanvas();
			};
			vectorSnapshot.src = tempCanvas.toDataURL();
		}

		// ТОЛЬКО прицел (быстро)
		function redrawCrosshairOnly() {
			if ((!originalImage && !isSvgFile) || !showCrosshair.checked) return;
			
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			
			const startX = parseInt(startXInput.value);
			const startY = parseInt(startYInput.value);
			const scaleX = vectorPreview.width / sheetWidth;
			const scaleY = vectorPreview.height / sheetHeight;
			const crossX = startX * scaleX;
			const crossY = vectorPreview.height - (startY * scaleY);
			
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(crossX - 20, crossY - 20, 40, 40);
			
			if (vectorSnapshot && vectorSnapshot.complete) {
				vectorCtx.drawImage(
					vectorSnapshot, 
					crossX - 20, crossY - 20, 40, 40,
					crossX - 20, crossY - 20, 40, 40
				);
			}
			
			drawCrosshair(vectorCtx, vectorPreview, sheetWidth, sheetHeight);
		}

		// Функция для показа временного изображения с текущим порогом
		function showTemporaryImage() {
			if (!originalImage || isSvgFile) return;
			
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
			
			drawImageWithThreshold();
			updateFrameSizes();
		}

		// Функция для отрисовки изображения с примененным порогом
		function drawImageWithThreshold() {
			if (!originalImage || isSvgFile) return;
			
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			const scaleX = vectorPreview.width / sheetWidth;
			const scaleY = vectorPreview.height / sheetHeight;
			
			const areaCanvasX = offsetX * scaleX;
			const areaCanvasY = vectorPreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
			const areaCanvasWidth = areaWidth * scaleX;
			const areaCanvasHeight = areaHeight * scaleY;
			
			vectorCtx.save();
			
			vectorCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
			
			vectorCtx.rotate(rotation * Math.PI / 180);
			
			const imageRatio = originalImage.width / originalImage.height;
			const areaRatio = areaWidth / areaHeight;
			
			let drawWidth, drawHeight;
			
			if (areaRatio > imageRatio) {
				drawHeight = areaCanvasHeight;
				drawWidth = drawHeight * imageRatio;
			} else {
				drawWidth = areaCanvasWidth;
				drawHeight = drawWidth / imageRatio;
			}
			
			const tempCanvas = document.createElement('canvas');
			const tempCtx = tempCanvas.getContext('2d');
			tempCanvas.width = originalImage.width;
			tempCanvas.height = originalImage.height;
			
			tempCtx.drawImage(originalImage, 0, 0);
			const tempImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
			
			const threshold = parseInt(thresholdInput.value);
			const invert = document.getElementById('invertImage').value === 'true';
			const data = tempImageData.data;
			
			for (let i = 0; i < data.length; i += 4) {
				const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
				const value = invert ? brightness > threshold : brightness < threshold;
				
				if (value) {
					data[i] = 0;
					data[i+1] = 0;
					data[i+2] = 0;
				} else {
					data[i] = 255;
					data[i+1] = 255;
					data[i+2] = 255;
				}
			}
			
			tempCtx.putImageData(tempImageData, 0, 0);
			
			vectorCtx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
			vectorCtx.globalAlpha = 1.0;
			
			vectorCtx.restore();
			
			updateStatus('Показано изображение с текущим порогом.', 'success');
		}

		// Функция для планирования обновления векторов
		function scheduleVectorUpdate() {
			if (vectorUpdateTimeout) {
				clearTimeout(vectorUpdateTimeout);
			}
			
			vectorUpdateTimeout = setTimeout(() => {
				if (originalImage && !isSvgFile) {
					processAndDrawVectors();
					displayImage(originalImage);
					updateStatus('Векторы обновлены с новым порогом', 'success');
				}
			}, VECTOR_UPDATE_DELAY);
			
			lastVectorUpdateTime = Date.now();
		}

		startXInput.addEventListener('input', function() {
			redrawCrosshairOnly();
			redrawImageCrosshairOnly(); 
		});

		startYInput.addEventListener('input', function() {
			redrawCrosshairOnly();
			redrawImageCrosshairOnly(); 
		});

		showCrosshair.addEventListener('change', function() {
			if (!originalImage && !isSvgFile) return;
			redrawVectorCanvas();
			redrawImageWithCrosshair();
		});
		
		// Остальные обработчики изменений
		const debouncedCanvasUpdate = debounce(updateCanvasSizes, 0);

		const debouncedImageRedraw = debounce(function() {
			if (originalImage || isSvgFile) {
				if (isSvgFile) {
					displaySvg();
				} else {
					displayImage(originalImage);
				}
				processAndDrawVectors();
			}
		}, 1500);

		// Обработчики размеров области
		areaWidthInput.addEventListener('input', function() {
			if ((originalImage || isSvgFile) && lockProportions.checked) {
				const newWidth = parseInt(this.value);
				const newHeight = Math.round(newWidth / imageAspectRatio);
				
				if (newHeight >= parseInt(areaHeightInput.min) && newHeight <= parseInt(areaHeightInput.max)) {
					areaHeightInput.value = newHeight;
				}
			}
			debouncedCanvasUpdate();
			debouncedImageRedraw();
		});

		areaHeightInput.addEventListener('input', function() {
			if ((originalImage || isSvgFile) && lockProportions.checked) {
				const newHeight = parseInt(this.value);
				const newWidth = Math.round(newHeight * imageAspectRatio);
				
				if (newWidth >= parseInt(areaWidthInput.min) && newWidth <= parseInt(areaWidthInput.max)) {
					areaWidthInput.value = newWidth;
				}
			}
			debouncedCanvasUpdate();
			debouncedImageRedraw();
		});

		// Обработчики размеров листа
		sheetWidthInput.addEventListener('input', function() {
			debouncedCanvasUpdate();
			debouncedImageRedraw();
		});

		sheetHeightInput.addEventListener('input', function() {
			debouncedCanvasUpdate();
			debouncedImageRedraw();
		});

		// Обработчики позиционирования
		const debouncedPositionUpdate = debounce(updatePositioningOnly, 50);

		const debouncedPositionRedraw = debounce(updatePositioningWithRecalculation, 2000);

		offsetXInput.addEventListener('input', function() {
			debouncedPositionUpdate();
			debouncedPositionRedraw();
		});

		offsetYInput.addEventListener('input', function() {
			debouncedPositionUpdate();
			debouncedPositionRedraw();
		});

		rotationInput.addEventListener('input', function() {
			debouncedPositionUpdate();
			debouncedPositionRedraw();
		});

		// Обработчики расширения области 
		const debouncedExpansionUpdate = debounce(function() {
			if (originalImage && !isSvgFile) {
				processAndDrawVectors();
				updateStatus('Расширение области обновлено', 'success');
			}
		}, 1000); 
		const debouncedImageUpdate = debounce(function() {
			if (originalImage && !isSvgFile) {
				displayImage(originalImage);
			}
		}, 50); 

		document.getElementById('resetPlotterSettings').addEventListener('click', function() {
			resetPlotterSettings();
		});
		
		document.getElementById('resetBottomSettings').addEventListener('click', function() {
			resetBottomSettings();
		});

		document.getElementById('lineThickness').addEventListener('input', function() {
			debouncedExpansionUpdate();
			debouncedImageUpdate();
		});

		document.getElementById('hatchStep').addEventListener('input', function() {
			debouncedExpansionUpdate();
		});
		document.getElementById('borderOffset').addEventListener('input', function() {
			debouncedExpansionUpdate();
			debouncedImageUpdate();
		});
		document.getElementById('hatchAngle').addEventListener('input', function() {
			debouncedExpansionUpdate();
		});

        // Обработчик блокировки пропорций
		lockProportions.addEventListener('change', function() {
			if ((originalImage || isSvgFile) && this.checked) {
				const currentWidth = parseInt(areaWidthInput.value);
				const currentHeight = parseInt(areaHeightInput.value);
				imageAspectRatio = currentWidth / currentHeight;
				
				updateCanvasSizes();
				if (originalImage || isSvgFile) {
					if (isSvgFile) {
						displaySvg();
					} else {
						displayImage(originalImage);
					}
					processAndDrawVectors();
				}
			}
		});

		// Обработчики изменения параметров оптимизации
		const debouncedOptimizationUpdate = debounce(function() {
			if (originalImage || isSvgFile) {
				updateStatus('Оптимизация путей...', 'success');
				optimizePaths(); // ТОЛЬКО оптимизация
				filterPathsByLength();
				saveVectorSnapshot();
				updatePathInfo();
				updateStatus('Параметры оптимизации обновлены', 'success');
			}
		}, 600);
		
		// Обработчики изменения параметров оптимизации
		connectDistanceInput.addEventListener('input', debouncedOptimizationUpdate);
		minLineLengthInput.addEventListener('input', debouncedOptimizationUpdate);
		// Создаем debounce-функцию для порога прозрачности
		const debouncedAlphaUpdate = debounce(function() {
			if (originalImage && !isSvgFile && alphaHandling.value === 'threshold') {
				processAndDrawVectors();
			}
		}, 500);
		
		// Сброс настроек трассировки к значениям по умолчанию
		function resetBottomSettings() {
			if (!confirm('Сбросить настройки трассировки к значениям по умолчанию?')) {
				return;
			}
				document.getElementById('lineThickness').value = 0.0;
				document.getElementById('borderOffset').value = 0;
				document.getElementById('hatchStep').value = 0.5;
				document.getElementById('hatchAngle').value = 0;
				document.getElementById('connectDistance').value = 1;
				document.getElementById('minLineLength').value = 0.5;
				document.getElementById('invertImage').value = 'false';
				document.getElementById('threshold').value = 128;
				document.getElementById('thresholdSlider').value = 128;
				
			if (originalImage || isSvgFile) {
				const img = originalImage;
				
				if (isSvgFile) {
					document.getElementById('conversionMethod').value = 'svg';
				} else {
					document.getElementById('conversionMethod').value = 'centerline';
				}

				updateCanvasSizes();
				updateStatus('Обработка рисунка', 'success');
				
				if (isSvgFile) {
					displaySvg();
				} else {
					displayImage(img);
				}
				
				processAndDrawVectors();
				updateStatus('Настройки сброшены', 'success');
			} else {

				updateStatus('Настройки сброшены', 'success');
			}	
		}

		function resetPlotterSettings() {
			if (!confirm('Сбросить настройки плоттера к значениям по умолчанию?')) {
				return;
			}
				document.getElementById('pauseTime').value = 100;
				document.getElementById('travelSpeed').value = 3000;
				document.getElementById('drawSpeed').value = 1500;
				document.getElementById('startX').value = 0;
				document.getElementById('startY').value = 0;
				document.getElementById('sheetWidth').value = 210;
				document.getElementById('sheetHeight').value = 297;
				document.getElementById('areaWidth').value = 210;
				document.getElementById('areaHeight').value = 297;
				document.getElementById('offsetX').value = 0;
				document.getElementById('offsetY').value = 0;
				document.getElementById('rotation').value = 0;
				document.getElementById('lockProportions').checked = true;

			if (originalImage || isSvgFile) {
				const img = originalImage;
				
				const currentAreaWidth = parseInt(areaWidthInput.value);
				const currentAreaHeight = parseInt(areaHeightInput.value);
				
				const scaleX = currentAreaWidth / img.width;
				const scaleY = currentAreaHeight / img.height;
				const scale = Math.min(scaleX, scaleY);
				
				const newAreaWidth = img.width * scale;
				const newAreaHeight = img.height * scale;
				
				areaWidthInput.value = Math.round(newAreaWidth);
				areaHeightInput.value = Math.round(newAreaHeight);
				imageAspectRatio = newAreaWidth / newAreaHeight;

				if (isSvgFile) {
					document.getElementById('conversionMethod').value = 'svg';
				} else {
					document.getElementById('conversionMethod').value = 'centerline';
				}

				updateCanvasSizes();
				updateStatus('Обработка рисунка', 'success');
				
				if (isSvgFile) {
					displaySvg();
				} else {
					displayImage(img);
				}
				
				processAndDrawVectors();
				updateStatus('Настройки сброшены как для нового изображения', 'success');
			} else {

				updateStatus('Настройки сброшены', 'success');
			}
		}

        // Обновление размеров canvas
 		function updateCanvasSizes() {
			if (!originalImage && !isSvgFile) return;
			
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);

			const sheetRatio = sheetWidth / sheetHeight;

			let displayWidth, displayHeight;
			if (sheetRatio > 1) {

				displayWidth = Math.min(canvasWidth, canvasHeight * sheetRatio);
				displayHeight = displayWidth / sheetRatio;
			} else {

				displayHeight = Math.min(canvasHeight, canvasWidth / sheetRatio);
				displayWidth = displayHeight * sheetRatio;
			}
			
			imagePreview.width = displayWidth;
			imagePreview.height = displayHeight;
			vectorPreview.width = displayWidth;
			vectorPreview.height = displayHeight;
			
			updateFrameSizes();
		}

        // Обновление размеров рамок
function updateFrameSizes() {
    if (!originalImage && !isSvgFile) return;
    
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    // Рамки листа (не вращаются)
    sheetFrame.style.width = imagePreview.width + 'px';
    sheetFrame.style.height = imagePreview.height + 'px';
    sheetFrame.style.left = '0px';
    sheetFrame.style.top = '0px';
    sheetFrame.style.border = '2px solid green';
    sheetFrame.style.transform = 'none';
    
    vectorSheetFrame.style.width = vectorPreview.width + 'px';
    vectorSheetFrame.style.height = vectorPreview.height + 'px';
    vectorSheetFrame.style.left = '0px';
    vectorSheetFrame.style.top = '0px';
    vectorSheetFrame.style.border = '2px solid green';
    vectorSheetFrame.style.transform = 'none';

    const scaleX = imagePreview.width / sheetWidth;
    const scaleY = imagePreview.height / sheetHeight;
    
    const areaFrameWidth = areaWidth * scaleX;
    const areaFrameHeight = areaHeight * scaleY;
    const areaFrameX = offsetX * scaleX;
    const areaFrameY = imagePreview.height - (offsetY * scaleY) - areaFrameHeight;
    
    // Рамки областей с вращением
    const applyRotation = (frame, centerX, centerY) => {
        frame.style.width = areaFrameWidth + 'px';
        frame.style.height = areaFrameHeight + 'px';
        frame.style.left = areaFrameX + 'px';
        frame.style.top = areaFrameY + 'px';
        
        // Применяем вращение относительно центра области
        frame.style.transformOrigin = `${centerX}px ${centerY}px`;
        frame.style.transform = `rotate(${rotation}deg)`;
    };
    
    // Центры вращения (относительно левого верхнего угла рамки)
    const centerX = areaFrameWidth / 2;
    const centerY = areaFrameHeight / 2;
    
    applyRotation(imageFrame, centerX, centerY);
    imageFrame.style.border = '2px dashed red';
    
    applyRotation(vectorFrame, centerX, centerY);
    vectorFrame.style.border = '2px dashed blue';
}

        // Инициализация canvas
        function initCanvases() {
            canvasWidth = 500;
            canvasHeight = 500;
            
            imagePreview.width = canvasWidth;
            imagePreview.height = canvasHeight;
            vectorPreview.width = canvasWidth;
            vectorPreview.height = canvasHeight;
            
            imageCtx.fillStyle = 'white';
            imageCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            vectorCtx.fillStyle = 'white';
            vectorCtx.fillRect(0, 0, canvasWidth, canvasHeight);
      
			currentTransformation = {
				offsetX: parseFloat(offsetXInput.value),
				offsetY: parseFloat(offsetYInput.value),
				rotation: parseFloat(rotationInput.value),
				areaWidth: parseInt(areaWidthInput.value),
				areaHeight: parseInt(areaHeightInput.value)
			};	  
            updateFrameSizes();
        }

        // ==================== ЗАГРУЗКА ФАЙЛОВ ====================

		// ОБРАБОТЧИК ЗАГРУЗКИ ФАЙЛОВ
imageInput.addEventListener('change', function(e) {
    const file = e.target.files[0];
    if (!file) return;

    clearAllImageData();
    
    currentFileName = file.name;
    const fileExtension = file.name.split('.').pop().toLowerCase();
    

    document.getElementById('imageInput').title = `Файл: ${file.name}&#10;Размер: ${(file.size / 1024).toFixed(1)} KB&#10;Тип: ${file.type}`;

    isSvgFile = fileExtension === 'svg';
    updateConversionMethods();
    
    if (isSvgFile) {
        conversionMethod.value = 'svg';
    } else {
        conversionMethod.value = 'centerline';
    }
    
    const reader = new FileReader();
    reader.onload = function(event) {
        if (isSvgFile) {
            originalImage = null;
            
            const originalFile = e.target.files[0];
            const textReader = new FileReader();
            textReader.onload = function(textEvent) {
                processSvgFileContent(textEvent.target.result);
            };
            textReader.onerror = function() {
                updateStatus('Ошибка чтения SVG файла', 'error');
            };
            textReader.readAsText(originalFile);
        } else {
            svgPaths = null;
            const img = new Image();
            img.onload = function() {
                const minRecommendedSize = 800; // минимальный рекомендуемый размер
                const scaleFactor = 2; // коэффициент увеличения
                
                if (img.width < minRecommendedSize || img.height < minRecommendedSize) {
                    updateStatus('Увеличиваю разрешение изображения для лучшего качества...', 'info');
                    
                    // Создаем canvas для увеличения
                    const upscaleCanvas = document.createElement('canvas');
                    const upscaleCtx = upscaleCanvas.getContext('2d');
                    
                    // Увеличиваем размер
                    upscaleCanvas.width = img.width * scaleFactor;
                    upscaleCanvas.height = img.height * scaleFactor;
                    
                    // Используем качественную интерполяцию
                    upscaleCtx.imageSmoothingEnabled = true;
                    upscaleCtx.imageSmoothingQuality = 'high';
                    upscaleCtx.drawImage(img, 0, 0, upscaleCanvas.width, upscaleCanvas.height);
                    
                    // Заменяем оригинальное изображение увеличенным
                    const upscaledImage = new Image();
                    upscaledImage.onload = function() {
                        originalImage = upscaledImage;
                        // ВАЖНО: вызываем продолжение обработки!
                        continueImageProcessing(upscaledImage);
                    };
                    upscaledImage.src = upscaleCanvas.toDataURL('image/png');
                    
                    return;
                }
                
                // Если размер достаточный - продолжаем как обычно
                originalImage = img;
                continueImageProcessing(img);
            };
            img.onerror = function() {
                updateStatus('Ошибка загрузки изображения', 'error');
            };
            img.src = event.target.result;
        }
    };
    reader.onerror = function() {
        updateStatus('Ошибка чтения файла', 'error');
    };
    reader.readAsDataURL(file);
});

// НОВАЯ ФУНКЦИЯ: продолжение обработки после загрузки/увеличения изображения
function continueImageProcessing(img) {
    updateConversionMethods();
    
    // ПРОВЕРКА ВЫБОРА РАДИО-КНОПКИ
    const fitToSheetRadio = document.getElementById('fitToSheet');
    const fitToAreaRadio = document.getElementById('fitToArea');
    
    let targetWidth, targetHeight;
    let fitOption = 'area'; // по умолчанию
    
    // Проверяем какая радио-кнопка выбрана
    if (fitToSheetRadio && fitToSheetRadio.checked) {
        // Вписать в лист
        targetWidth = parseInt(sheetWidthInput.value);
        targetHeight = parseInt(sheetHeightInput.value);
        fitOption = 'sheet';
    } else {
        // Вписать в область
        targetWidth = parseInt(areaWidthInput.value);
        targetHeight = parseInt(areaHeightInput.value);
        fitOption = 'area';
    }
    
    // ПРОВЕРКА ГАЛОЧКИ ПРОПОРЦИЙ
    const lockProportions = document.getElementById('lockProportions').checked;
    let newAreaWidth, newAreaHeight;
    
    if (lockProportions) {
        // СОХРАНЯЕМ ПРОПОРЦИИ - текущая логика
        const scaleX = targetWidth / img.width;
        const scaleY = targetHeight / img.height;
        const scale = Math.min(scaleX, scaleY);
        
        newAreaWidth = img.width * scale;
        newAreaHeight = img.height * scale;
        
        updateStatus('Изображение вписано с сохранением пропорций', 'success');
    } else {
        // РАСТЯГИВАЕМ БЕЗ СОХРАНИЯ ПРОПОРЦИЙ
        newAreaWidth = targetWidth;
        newAreaHeight = targetHeight;
        
        updateStatus('Изображение растянуто в выбранную область', 'success');
    }
    
    areaWidthInput.value = Math.round(newAreaWidth);
    areaHeightInput.value = Math.round(newAreaHeight);
    imageAspectRatio = newAreaWidth / newAreaHeight;

    updateCanvasSizes();
    displayImage(img);
    
    processAndDrawVectors();
    updateStatus('Изображение загружено' + (img.width > originalImage.width ? ' (увеличено для лучшего качества)' : ''), 'success');
}
        // Конвертация в G-code
convertBtn.addEventListener('click', function() {
    if (!originalImage && !isSvgFile) {
        updateStatus('Сначала загрузите изображение', 'error');
        return;
    }
    
    try {
        const pauseTime = parseInt(document.getElementById('pauseTime').value) || 100;
        const travelSpeed = parseInt(document.getElementById('travelSpeed').value) || 3000;
        const drawSpeed = parseInt(document.getElementById('drawSpeed').value) || 1500;
        const areaWidth = parseInt(areaWidthInput.value) || 210;
        const areaHeight = parseInt(areaHeightInput.value) || 297;
        const startX = parseInt(document.getElementById('startX').value) || 0;
        const startY = parseInt(document.getElementById('startY').value) || 0;
        const minLineLength = parseFloat(minLineLengthInput.value) || 0.5;
        const offsetX = parseFloat(offsetXInput.value) || 0;
        const offsetY = parseFloat(offsetYInput.value) || 0;
        const rotation = parseFloat(rotationInput.value) || 0;
        
        currentGcode = generateGCode(pauseTime, travelSpeed, drawSpeed, areaWidth, areaHeight, startX, startY, minLineLength, offsetX, offsetY, rotation);
        gcodeOutput.value = currentGcode;
        
        downloadBtn.disabled = false;
        updateStatus('G-code сгенерирован успешно', 'success');
    } catch (error) {
        console.error('Ошибка конвертации:', error);
        updateStatus('Ошибка при конвертации: ' + error.message, 'error');
    }
});

        // Скачивание G-code
        downloadBtn.addEventListener('click', function() {
            if (!currentGcode) {
                updateStatus('Сначала сгенерируйте G-code', 'error');
                return;
            }
            
            const fileName = currentFileName ? currentFileName.replace(/\.[^/.]+$/, "") + '.gcode' : 'drawing.gcode';
            const blob = new Blob([currentGcode], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            updateStatus('G-code сохранен', 'success');
        });

        // Скачивание SVG
        downloadSvgBtn.addEventListener('click', function() {
            if (!optimizedPaths.length) {
                updateStatus('Сначала сгенерируйте векторы', 'error');
                return;
            }
            
            const fileName = currentFileName ? currentFileName.replace(/\.[^/.]+$/, "") + '.svg' : 'drawing.svg';
            const svgContent = generateSVG();
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            updateStatus('SVG сохранен', 'success');
        });

        // Генерация SVG
		function generateSVG() {
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			
			const width = isSvgFile ? svgPaths.width : originalImage.width;
			const height = isSvgFile ? svgPaths.height : originalImage.height;
			
			const lockProportions = document.getElementById('lockProportions').checked;
			
			let scaleX, scaleY;
			
			if (lockProportions) {
				const imageRatio = width / height;
				const areaRatio = areaWidth / areaHeight;
				
				if (areaRatio > imageRatio) {
					scaleY = areaHeight / height;
					scaleX = scaleY;
				} else {
					scaleX = areaWidth / width;
					scaleY = scaleX;
				}
			} else {
				scaleX = areaWidth / width;
				scaleY = areaHeight / height;
			}
			
			let svgPathsContent = '';
			
			for (const path of filteredPaths) {
				if (path.length < 2) continue;
				
				let pathData = '';
				// Используем специальную функцию для SVG с инверсией точек изображения
				const transformedPoints = applyTransformationForSVG(path, offsetX, offsetY, rotation, scaleX, scaleY);
				
				if (transformedPoints.length > 0) {
					pathData = `M ${transformedPoints[0].x} ${sheetHeight - transformedPoints[0].y}`;
					
					for (let i = 1; i < transformedPoints.length; i++) {
						pathData += ` L ${transformedPoints[i].x} ${sheetHeight - transformedPoints[i].y}`;
					}
					
					svgPathsContent += `<path d="${pathData}" fill="none" stroke="black" stroke-width="0.5" />\n`;
				}
			}
			
			return `<?xml version="1.0" encoding="UTF-8"?>
		<svg width="${sheetWidth}mm" height="${sheetHeight}mm" viewBox="0 0 ${sheetWidth} ${sheetHeight}" xmlns="http://www.w3.org/2000/svg">
		${svgPathsContent}
		</svg>`;
		}

		function applyTransformationForSVG(path, offsetX, offsetY, rotation, scaleX, scaleY) {
			const width = isSvgFile ? svgPaths.width : originalImage.width;
			const height = isSvgFile ? svgPaths.height : originalImage.height;
			
			const centerX = width * scaleX / 2;
			const centerY = height * scaleY / 2;
			const rad = rotation * Math.PI / 180;
			const cos = Math.cos(rad);
			const sin = Math.sin(rad);
			
			return path.map(point => {
				// ИНВЕРТИРУЕМ Y точки изображения, но не позиционирование
				let x = point.x * scaleX;
				let y = (height - point.y) * scaleY; // ИНВЕРСИЯ точки изображения

				// Применяем вращение относительно центра
				const rotatedX = centerX + (x - centerX) * cos - (y - centerY) * sin;
				const rotatedY = centerY + (x - centerX) * sin + (y - centerY) * cos;

				// Применяем смещение (без инверсии - позиционирование остается как есть)
				x = offsetX + rotatedX;
				y = offsetY + rotatedY;
				
				return { x: x.toFixed(2), y: y.toFixed(2) };
			});
		}

		// Функция для частичной отрисовки векторов с прогрессом
		function drawPartialVectors(partialPaths, progress = 0, type = 'optimized') {
			if (!originalImage && !isSvgFile) return;
			
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
			
			if (partialPaths.length === 0) return;

			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			const scaleX = vectorPreview.width / sheetWidth;
			const scaleY = vectorPreview.height / sheetHeight;
			
			const areaCanvasX = offsetX * scaleX;
			const areaCanvasY = vectorPreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
			const areaCanvasWidth = areaWidth * scaleX;
			const areaCanvasHeight = areaHeight * scaleY;
			
			vectorCtx.save();
			vectorCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
			vectorCtx.rotate(rotation * Math.PI / 180);
			
			const width = isSvgFile ? svgPaths.width : originalImage.width;
			const height = isSvgFile ? svgPaths.height : originalImage.height;
			
			const imageRatio = width / height;
			const areaRatio = areaWidth / areaHeight;
			
			let drawScaleX, drawScaleY;
			
			if (areaRatio > imageRatio) {
				drawScaleY = areaCanvasHeight / height;
				drawScaleX = drawScaleY;
			} else {
				drawScaleX = areaCanvasWidth / width;
				drawScaleY = drawScaleX;
			}
			
			applyLineStyle(vectorCtx, type);
			
			// Рисуем пути
			for (const path of partialPaths) {
				if (path.length < 2) continue;
				
				vectorCtx.beginPath();
				vectorCtx.moveTo(
					(path[0].x - width / 2) * drawScaleX, 
					(path[0].y - height / 2) * drawScaleY
				);
				
				for (let j = 1; j < path.length; j++) {
					vectorCtx.lineTo(
						(path[j].x - width / 2) * drawScaleX, 
						(path[j].y - height / 2) * drawScaleY
					);
				}
				vectorCtx.stroke();
			}
			
			vectorCtx.restore();
			if (progress > 0) {
				const progressAreaHeight = 40;
				vectorCtx.fillStyle = 'white';
				vectorCtx.fillRect(0, 0, vectorPreview.width, progressAreaHeight);
				
				drawProgressIndicator(progress, '');
			}
		}

		// Функция для отображения прогресса
		function drawProgressIndicator(progress, text = '') {
			vectorCtx.save();
			
			const progressWidth = 120;
			const progressHeight = 10;
			const margin = 15;
			
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, progressWidth + margin * 2, 60);

			vectorCtx.fillStyle = 'rgba(255, 255, 255, 0.95)';
			vectorCtx.strokeStyle = '#333';
			vectorCtx.lineWidth = 1;
			
			vectorCtx.beginPath();
			vectorCtx.roundRect(margin, margin, progressWidth, progressHeight, 4);
			vectorCtx.fill();
			vectorCtx.stroke();
			
			vectorCtx.fillStyle = '#007cba';
			vectorCtx.beginPath();
			vectorCtx.roundRect(margin, margin, progressWidth * (progress / 100), progressHeight, 4);
			vectorCtx.fill();
			
			vectorCtx.fillStyle = '#333';
			vectorCtx.font = '12px Arial, sans-serif';
			vectorCtx.textAlign = 'center';
			vectorCtx.textBaseline = 'top';
			
			const percentText = `${Math.round(progress)}%`;
			vectorCtx.fillText(percentText, margin + progressWidth / 2, margin + progressHeight + 5);
			
			if (text && text.length <= 20) {
				vectorCtx.font = '12px Arial, sans-serif';
				vectorCtx.fillText(text, margin + progressWidth / 2, margin + progressHeight + 22);
			}
			
			vectorCtx.restore();
		}

        // Обработка и отрисовка векторов
		async function processAndDrawVectors() {
			showLoading();
			
			await new Promise(resolve => setTimeout(resolve, 100));
			
			try {
				vectorCtx.fillStyle = 'white';
				vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
				
				if (isSvgFile) {
					const method = document.getElementById('conversionMethod').value;
					
					if (method === 'svg') {

						vectorPaths = convertSvgPathsToVectorPaths();

						optimizePaths();
						filterPathsByLength();
						saveVectorSnapshot();
						updatePathInfo();
						
						drawVectorPreview();
						
					} else {
						// Для других методов используем BMP
						const bmpImage = createBitmapFromSheet();
						if (bmpImage) {
							await new Promise((resolve, reject) => {
								bmpImage.onload = resolve;
								bmpImage.onerror = reject;
							});
							
							originalImage = bmpImage;

							processImage();
							await generateVectorPathsWithProgress();
							optimizePaths();
							filterPathsByLength();
							saveVectorSnapshot();
							updatePathInfo();
							
						} else {
							vectorPaths = convertSvgPathsToVectorPaths();
							optimizePaths();
							filterPathsByLength();
							saveVectorSnapshot();
							updatePathInfo();
							drawVectorPreview();
						}
					}
				} else {
					if (!originalImage) {
						throw new Error('Изображение не загружено');
					}
					
					processImage();
					await generateVectorPathsWithProgress();
					optimizePaths();
					filterPathsByLength();
					saveVectorSnapshot();
					updatePathInfo();
				}
				
				updateStatus('Обработка завершена', 'success');
				downloadSvgBtn.disabled = false;
				convertBtn.disabled = false;
				eraserTool.disabled = false;
				resetImageBtn.disabled = false;
			} catch (error) {
				console.error('Ошибка:', error);
				updateStatus('Ошибка: ' + error.message, 'error');
			} finally {
				hideLoading();
			}
		}

		// Модифицированная функция генерации путей с прогрессом
		async function generateVectorPathsWithProgress() {
			const threshold = parseInt(thresholdInput.value);
			const invert = document.getElementById('invertImage').value === 'true';
			const method = document.getElementById('conversionMethod').value;
			
			vectorPaths = [];
			
			if (method === 'centerline') {
				await generateCenterlinePathsWithProgress(threshold, invert);
			} else if (method === 'fill') {
				await generateFillPathsWithProgress(threshold, invert);
			} else if (method === 'hatch') {
				await generateHatchPathsWithProgress(threshold, invert);
			} else if (method === 'contour') {
				await generateContourPathsWithProgress(threshold, invert);
			}
			
			updatePathInfo();
		}

		// Центральная линия с прогрессом
		async function generateCenterlinePathsWithProgress(threshold, invert) {
			const binary = createBinaryImage(threshold, invert);
			const width = originalImage.width;
			const height = originalImage.height;
			const lineThicknessMM = parseFloat(document.getElementById('lineThickness').value);
			
			drawProgressIndicator(40, 'Скелетизация...');
			
			let skeleton;
			if (lineThicknessMM > 0) {
				const thicknessPixels = Math.max(1, Math.round(lineThicknessMM / pixelToMM));
				const expanded = expandBinary(binary, thicknessPixels);
				skeleton = zhangSuenSkeletonization(expanded);
			} else {
				skeleton = zhangSuenSkeletonization(binary);
			}
			
			drawSkeletonPreview(skeleton, 50);
			await new Promise(resolve => setTimeout(resolve, 100));
			
			drawProgressIndicator(60, 'Трассировка...');
			
			let rawPaths = extractPathsFromSkeleton(skeleton);
			
			vectorPaths = optimizeStraightLines(rawPaths, 1.5);
			
			drawPartialVectors(vectorPaths, 70, 'temporary');
			await new Promise(resolve => setTimeout(resolve, 100));
			
			drawProgressIndicator(75, 'Оптимизация соединений...');
    
			unifiedPathConnection(); 
			
			drawProgressIndicator(85, 'Финальная оптимизация...');
			const improvements = await validateAndOptimizeConnections();
			
			drawPartialVectors(vectorPaths, 90, 'optimized');
			await new Promise(resolve => setTimeout(resolve, 100));
			
			const totalPaths = vectorPaths.length;
			const totalLength = vectorPaths.reduce((sum, path) => sum + calculatePathLength(path), 0);
			updateStatus(`Создано ${totalPaths} путей, улучшено ${improvements} соединений`, 'success');
		}

		// Заливка с прогрессом
		async function generateFillPathsWithProgress(threshold, invert) {
			const binary = createBinaryImage(threshold, invert);
			const width = originalImage.width;
			const height = originalImage.height;
			
			vectorPaths = [];
			
			drawProgressIndicator(45, 'Создание бинарного изображения...');

			
			const lineThicknessMM = parseFloat(document.getElementById('lineThickness').value);
			
			let processedBinary = binary;
			if (lineThicknessMM > 0) {
				drawProgressIndicator(47, 'Расширение областей...');
				const thicknessPixels = Math.max(1, Math.round(lineThicknessMM / pixelToMM));
				processedBinary = expandBinary(binary, thicknessPixels);

			}
			
			const borderOffsetMM = parseFloat(document.getElementById('borderOffset').value);
			const borderOffsetPixels = Math.max(0, Math.round(borderOffsetMM / pixelToMM));
			
			if (borderOffsetPixels > 0) {
				drawProgressIndicator(50, 'Применение отступа...');
				processedBinary = erodeBinary(processedBinary, borderOffsetPixels);
				

			}
			
			const hatchStepMM = parseFloat(document.getElementById('hatchStep').value);
			const areaWidth = parseInt(areaWidthInput.value);
			const hatchStepPixels = Math.max(1, Math.round((hatchStepMM / areaWidth) * width));

			drawProgressIndicator(52, 'Поиск черных областей...');
			const areas = await findAllBlackAreasWithProgress(processedBinary, width, height);
			
			drawProgressIndicator(60, `Найдено ${areas.length} областей`);
			await new Promise(resolve => setTimeout(resolve, 200));
			
			let totalPathsBefore = vectorPaths.length;
			
			for (let i = 0; i < areas.length; i++) {
				const area = areas[i];
				
				drawProgressIndicator(60 + Math.min(20, (i / areas.length) * 20), 
									`Область ${i+1}/${areas.length}`);
				
				const intersections = findGridIntersections(area, hatchStepPixels, width, height);
				
				if (intersections.length > 1) {
					const snakes = connectWithNearestNeighbor(intersections, hatchStepPixels);
					
					for (const snake of snakes) {
						if (snake.length > 1) {
							vectorPaths.push(snake);
						}
					}
					
					if (i % 2 === 0 || i === areas.length - 1) {
						const progress = 60 + Math.min(20, (i / areas.length) * 20);
						drawPartialVectors(vectorPaths, progress, 'temporary');
						await new Promise(resolve => setTimeout(resolve, 50));
					}
				}
				
				if (i % 5 === 0) {
					await new Promise(resolve => setTimeout(resolve, 10));
				}
			}
			
			const pathsAdded = vectorPaths.length - totalPathsBefore;
			
			drawPartialVectors(vectorPaths, 85, 'optimized');
			await new Promise(resolve => setTimeout(resolve, 100));
			
			updateStatus(`Создано ${pathsAdded} путей заливки в ${areas.length} областях`, 'success');
		}

		// Штриховка с прогрессом
		async function generateHatchPathsWithProgress(threshold, invert) {
			let binary = createBinaryImage(threshold, invert);
			const width = originalImage.width;
			const height = originalImage.height;
			
			vectorPaths = [];
			
			const borderOffsetMM = parseFloat(document.getElementById('borderOffset').value);
			const borderOffsetPixels = Math.max(0, Math.round(borderOffsetMM / pixelToMM));
			
			let processedBinary = binary;
			if (borderOffsetPixels > 0) {
				processedBinary = erodeBinary(binary, borderOffsetPixels);
			}
			
			const hatchStepMM = parseFloat(document.getElementById('hatchStep').value);
			const hatchAngle = parseFloat(document.getElementById('hatchAngle').value);
			const areaWidth = parseInt(areaWidthInput.value);
			const hatchStepPixels = Math.max(1, Math.round((hatchStepMM / areaWidth) * width));
			
			const angleRad = (hatchAngle - 90) * Math.PI / 180;
			const cosAngle = Math.cos(angleRad);
			const sinAngle = Math.sin(angleRad);
			
			const diagonalLength = Math.sqrt(width * width + height * height);
			const numLines = Math.ceil(diagonalLength / hatchStepPixels) * 2;
			
			drawProgressIndicator(40, 'Генерация штриховки...');
			
			for (let i = -numLines/2; i < numLines/2; i++) {
				let currentLine = [];
				const offset = i * hatchStepPixels;
				
				for (let t = -diagonalLength; t < diagonalLength; t++) {
					const x = Math.round(offset * cosAngle + t * sinAngle);
					const y = Math.round(offset * sinAngle - t * cosAngle);
					
					if (x >= 0 && x < width && y >= 0 && y < height) {
						if (processedBinary[y * width + x] === 1) {
							currentLine.push({x, y});
						} else if (currentLine.length > 0) {
							if (currentLine.length > 1) {
								vectorPaths.push([...currentLine]);
							}
							currentLine = [];
						}
					} else if (currentLine.length > 0) {
						if (currentLine.length > 1) {
							vectorPaths.push([...currentLine]);
						}
						currentLine = [];
					}
				}
				
				if (currentLine.length > 1) {
					vectorPaths.push([...currentLine]);
				}
				
				if (i % 10 === 0 || i === numLines/2 - 1) {
					const progress = 40 + Math.min(30, ((i + numLines/2) / numLines) * 30);
					drawPartialVectors(vectorPaths, progress, 'temporary');
					await new Promise(resolve => setTimeout(resolve, 0));
				}
			}
		}

		// Контуры с прогрессом
		async function generateContourPathsWithProgress(threshold, invert) {
			const binary = createBinaryImage(threshold, invert);
			const width = originalImage.width;
			const height = originalImage.height;
			
			vectorPaths = [];
			
			const lineThicknessMM = parseFloat(document.getElementById('lineThickness').value);
			
			let processedBinary = binary;
			if (lineThicknessMM > 0) {
				const thicknessPixels = Math.max(1, Math.round(lineThicknessMM / pixelToMM));
				processedBinary = expandBinary(binary, thicknessPixels);
			}
			
			const borderOffsetMM = parseFloat(document.getElementById('borderOffset').value);
			const borderOffsetPixels = Math.max(0, Math.round(borderOffsetMM / pixelToMM));
				
			if (borderOffsetPixels > 0) {
				processedBinary = erodeBinary(processedBinary, borderOffsetPixels);
			}
			
			drawProgressIndicator(40, 'Поиск контуров...');
			
			const edgeMap = new Array(width * height).fill(0);
			
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const index = y * width + x;
					
					if (processedBinary[index] === 1) {
						const neighbors = [
							{dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1}
						];
						
						for (const neighbor of neighbors) {
							const nx = x + neighbor.dx;
							const ny = y + neighbor.dy;
							
							if (nx < 0 || nx >= width || ny < 0 || ny >= height) {
								edgeMap[index] = 1;
								break;
							} else if (processedBinary[ny * width + nx] === 0) {
								edgeMap[index] = 1;
								break;
							}
						}
					}
				}
				
				if (y % 20 === 0) {
					const progress = 40 + Math.min(20, (y / height) * 20);
					drawProgressIndicator(progress, 'Поиск границ...');
					await new Promise(resolve => setTimeout(resolve, 0));
				}
			}
			
			drawProgressIndicator(60, 'Трассировка контуров...');
			
			const visited = new Array(width * height).fill(false);
			let contoursFound = 0;
			
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const index = y * width + x;
					
					if (edgeMap[index] === 1 && !visited[index]) {
						const contour = traceContinuousContour(edgeMap, visited, x, y, width, height);
						if (contour && contour.length > 5) {
							vectorPaths.push(contour);
							contoursFound++;
						}
					}
				}
				
				if (y % 20 === 0) {
					const progress = 60 + Math.min(20, (y / height) * 20);
					drawPartialVectors(vectorPaths, progress, 'temporary');
					await new Promise(resolve => setTimeout(resolve, 0));
				}
			}
			
			updateStatus(`Найдено контуров: ${contoursFound}`, 'success');
		}

		// Модифицируем функцию findAllBlackAreas для поддержки прогресса
		async function findAllBlackAreasWithProgress(binary, width, height) {
			const areas = [];
			const visited = new Array(width * height).fill(false);
			let totalPixels = width * height;
			let processedPixels = 0;
			
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const index = y * width + x;
					
					if (binary[index] === 1 && !visited[index]) {
						const area = floodFillArea(binary, visited, x, y, width, height);
						if (area.points.length > 10) {
							areas.push(area);
						}
					}
					
					processedPixels++;
				}
				
				if (y % 10 === 0) {
					const progress = 45 + Math.min(15, (processedPixels / totalPixels) * 15);
					drawProgressIndicator(progress, 'Поиск областей...');
					await new Promise(resolve => setTimeout(resolve, 10));
				}
			}
			
			return areas;
		}

		// Функция для предпросмотра скелета
		function drawSkeletonPreview(skeleton, progress = 0) {
			const width = originalImage.width;
			const height = originalImage.height;
			
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);

			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			const scaleX = vectorPreview.width / sheetWidth;
			const scaleY = vectorPreview.height / sheetHeight;
			
			const areaCanvasX = offsetX * scaleX;
			const areaCanvasY = vectorPreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
			const areaCanvasWidth = areaWidth * scaleX;
			const areaCanvasHeight = areaHeight * scaleY;
			
			vectorCtx.save();
			vectorCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
			vectorCtx.rotate(rotation * Math.PI / 180);
			
			const imageRatio = width / height;
			const areaRatio = areaWidth / areaHeight;
			
			let drawScaleX, drawScaleY;
			
			if (areaRatio > imageRatio) {
				drawScaleY = areaCanvasHeight / height;
				drawScaleX = drawScaleY;
			} else {
				drawScaleX = areaCanvasWidth / width;
				drawScaleY = drawScaleX;
			}
			
			vectorCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
			
			for (let y = 0; y < height; y += 2) {
				for (let x = 0; x < width; x += 2) {
					if (skeleton[y * width + x] === 1) {
						vectorCtx.fillRect(
							(x - width / 2) * drawScaleX, 
							(y - height / 2) * drawScaleY, 
							1, 1
						);
					}
				}
			}
			
			vectorCtx.restore();
			
			if (progress > 0) {
				drawProgressIndicator(progress, 'Скелетизация...');
			}
		}

		// Функция для быстрого обновления позиционирования без полного пересчета
		function updatePositioningOnly() {
			if (!originalImage && !isSvgFile) return;
			
			const newOffsetX = parseFloat(offsetXInput.value);
			const newOffsetY = parseFloat(offsetYInput.value);
			const newRotation = parseFloat(rotationInput.value);
			const newAreaWidth = parseInt(areaWidthInput.value);
			const newAreaHeight = parseInt(areaHeightInput.value);
			
			// Проверяем, действительно ли изменились параметры
			if (newOffsetX === currentTransformation.offsetX &&
				newOffsetY === currentTransformation.offsetY &&
				newRotation === currentTransformation.rotation &&
				newAreaWidth === currentTransformation.areaWidth &&
				newAreaHeight === currentTransformation.areaHeight) {
				return; // Ничего не изменилось
			}
			
			// Обновляем текущее состояние
			currentTransformation = {
				offsetX: newOffsetX,
				offsetY: newOffsetY,
				rotation: newRotation,
				areaWidth: newAreaWidth,
				areaHeight: newAreaHeight
			};
			
			// Быстрое обновление отображения
			updateCanvasSizes();
			
			if (isSvgFile) {
				displaySvg();
			} else {
				displayImage(originalImage);
			}
			
			// Для векторов - быстрая перерисовка без полной переобработки
			if (vectorSnapshot && vectorSnapshot.complete) {
				redrawVectorCanvas();
			} else {
				drawVectorPreview();
			}
			
			updateStatus('Позиционирование обновлено', 'success');
		}

		// Функция для полного пересчета при необходимости
		function updatePositioningWithRecalculation() {
			if (!originalImage && !isSvgFile) return;
			
			updateCanvasSizes();
			
			if (isSvgFile) {
				displaySvg();
			} else {
				displayImage(originalImage);
			}
			
			// Полная переобработка векторов
			processAndDrawVectors();
		}

        // Отображение изображения с учетом трансформаций
function displayImage(img) {
    if (!img) return;
    
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    imageCtx.fillStyle = 'white';
    imageCtx.fillRect(0, 0, imagePreview.width, imagePreview.height);
    
    const scaleX = imagePreview.width / sheetWidth;
    const scaleY = imagePreview.height / sheetHeight;
    
    const areaCanvasX = offsetX * scaleX;
    const areaCanvasY = imagePreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
    const areaCanvasWidth = areaWidth * scaleX;
    const areaCanvasHeight = areaHeight * scaleY;
    
    imageCtx.save();
    imageCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
    imageCtx.rotate(rotation * Math.PI / 180);
    
    const imageRatio = img.width / img.height;
    const areaRatio = areaWidth / areaHeight;
    const lockProportions = document.getElementById('lockProportions').checked;
    
    let drawWidth, drawHeight;
    
    if (lockProportions) {
        if (areaRatio > imageRatio) {
            drawHeight = areaCanvasHeight;
            drawWidth = drawHeight * imageRatio;
        } else {
            drawWidth = areaCanvasWidth;
            drawHeight = drawWidth / imageRatio;
        }
    } else {
        drawWidth = areaCanvasWidth;
        drawHeight = areaCanvasHeight;
    }
    
    // === ВСТАВЛЯЕМ ОБРАБОТКУ ИЗОБРАЖЕНИЯ ===
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = img.width;
    tempCanvas.height = img.height;
    
    // ЗАЛИВАЕМ БЕЛЫМ ФОНОМ для PNG
    tempCtx.fillStyle = 'white';
    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
    
    // Рисуем оригинал поверх белого фона
    tempCtx.drawImage(img, 0, 0);
    
    // Применяем порог и инвертирование
    const threshold = parseInt(thresholdInput.value);
    const invert = document.getElementById('invertImage').value === 'true';
    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const data = imageData.data;
    
    for (let i = 0; i < data.length; i += 4) {
        const brightness = (data[i] + data[i+1] + data[i+2]) / 3;
        const alpha = data[i+3]; // учитываем альфа-канал
        
        // Если пиксель прозрачный, делаем его белым
        if (alpha < 128) {
            data[i] = 255; data[i+1] = 255; data[i+2] = 255;
            continue;
        }
        
        const value = invert ? brightness > threshold : brightness < threshold;
        
        if (value) {
            data[i] = 0; data[i+1] = 0; data[i+2] = 0;
        } else {
            data[i] = 255; data[i+1] = 255; data[i+2] = 255;
        }
        data[i+3] = 255; // делаем непрозрачным
    }
    tempCtx.putImageData(imageData, 0, 0);
    
    // Применяем расширение и сужение области (в пикселях изображения)
    const lineThicknessMM = parseFloat(document.getElementById('lineThickness').value);
    const borderOffsetMM = parseFloat(document.getElementById('borderOffset').value);
    
    // ПРАВИЛЬНЫЙ РАСЧЕТ: мм → пиксели изображения
    const scaleToImage = Math.min(areaWidth / img.width, areaHeight / img.height);
    
    let processedBinary = null;
    
    // 1. Сначала получаем бинарное изображение
    const binaryData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
    const binary = new Array(tempCanvas.width * tempCanvas.height);
    
    for (let i = 0; i < binaryData.data.length; i += 4) {
        const idx = i / 4;
        binary[idx] = binaryData.data[i] === 0 ? 1 : 0; // черный = 1
    }
    
    processedBinary = binary;
    
    // 2. Применяем РАСШИРЕНИЕ если нужно
    if (lineThicknessMM > 0) {
        const expandPixels = Math.max(1, Math.round(lineThicknessMM / scaleToImage));
        processedBinary = expandBinary(processedBinary, expandPixels);
    }
    
    // 3. Применяем СУЖЕНИЕ если нужно (компенсация ширины пера)
    if (borderOffsetMM > 0) {
        const erodePixels = Math.max(1, Math.round(borderOffsetMM / scaleToImage));
        processedBinary = erodeBinary(processedBinary, erodePixels);
    }
    
    // 4. Преобразуем обратно в ImageData
    const finalData = new ImageData(tempCanvas.width, tempCanvas.height);
    for (let i = 0; i < processedBinary.length; i++) {
        const idx = i * 4;
        if (processedBinary[i] === 1) {
            finalData.data[idx] = 0;     // черный
            finalData.data[idx+1] = 0;
            finalData.data[idx+2] = 0;
        } else {
            finalData.data[idx] = 255;   // белый
            finalData.data[idx+1] = 255;
            finalData.data[idx+2] = 255;
        }
        finalData.data[idx+3] = 255; // непрозрачный
    }
    tempCtx.putImageData(finalData, 0, 0);
    // === КОНЕЦ ОБРАБОТКИ ===
    
    // Рисуем обработанное изображение
    imageCtx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
    imageCtx.restore();
    
    if (showCrosshair.checked) {
        drawCrosshair(imageCtx, imagePreview, sheetWidth, sheetHeight);
    }
    
    pixelToMM = Math.min(areaWidth / img.width, areaHeight / img.height);
    
    const fileType = isSvgFile ? 'SVG' : 'Изображение';
    const processingInfo = ` | Порог: ${threshold} | Инвертирование: ${invert ? 'Да' : 'Нет'} | Расширение: ${lineThicknessMM}мм | Сужение: ${borderOffsetMM}мм`;
    
    imageInfo.textContent = `${fileType}: ${img.width}×${img.height}px | Область: ${areaWidth}×${areaHeight}мм$ | Лист: ${sheetWidth}×${sheetHeight}мм | Смещение: X${offsetX}мм Y${offsetY}мм | Вращение: ${rotation}°${processingInfo}`;
}

        // Обработка изображения с поддержкой прозрачности PNG
		function processImage() {

			const imageToProcess = isSvgFile && originalImage ? originalImage : originalImage;
			
			if (!imageToProcess) {
				console.warn('Нет изображения для обработки');
				return;
			}
			
			const tempCanvas = document.createElement('canvas');
			const tempCtx = tempCanvas.getContext('2d');
			
			tempCanvas.width = imageToProcess.width;
			tempCanvas.height = imageToProcess.height;
			
			tempCtx.fillStyle = 'white';
			tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
			
			tempCtx.drawImage(imageToProcess, 0, 0);
			
			imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
		}



		function getSegmentDirection(path, fromEnd, lookback = 3) {
			if (path.length < lookback + 1) {

				if (path.length < 2) return { x: 0, y: 0 };
				lookback = Math.min(lookback, path.length - 1);
			}
			
			if (fromEnd) {
				const p1 = path[path.length - lookback - 1];
				const p2 = path[path.length - 1];
				return { x: p2.x - p1.x, y: p2.y - p1.y };
			} else {
				const p1 = path[0];
				const p2 = path[lookback];
				return { x: p2.x - p1.x, y: p2.y - p1.y };
			}
		}

function unifiedPathConnection() {
    if (vectorPaths.length < 2) return;

    let totalConnections = 0;
    const connectionStats = {
        conservative: 0, smart: 0, gapFilling: 0, 
        collinear: 0, rebuild: 0, segmentMerge: 0  
    };
    
    console.log("Начальное количество путей:", vectorPaths.length);
    
    // РАЗРЫВЫ ===
    const pathsBefore = vectorPaths.length;
    vectorPaths = breakVectorsAtSharpAngles(vectorPaths, 95);
    const breaksCreated = Math.max(0, vectorPaths.length - pathsBefore);
    console.log("Разрывы создано:", breaksCreated);
    
    // УДАЛЕНИЕ ОТРОСТКОВ - по галочке
    if (document.getElementById('removeSpursCheckbox').checked) {
        removeShortConnectedVectors();
        console.log("Удаление отростков выполнено");
    }
    
    // УДАЛЕНИЕ ПАРАЛЛЕЛЬНЫХ - по галочке
    let pathDel = 0;
    if (document.getElementById('removeParallelCheckbox').checked) {
        pathDel = mergeCloseParallelLines();
        console.log("Паралельные:", pathDel);
    }
    
    // ПЕРЕКРЕСТКИ - по галочке
    if (document.getElementById('connectCrossroadsCheckbox').checked) {
        connectCrossroadPointsSafe();
        console.log("Обработка перекрестков выполнена");
    }
    
    // ПРОДОЛЖЕНИЕ ПУТЕЙ - по галочке
    let collinearConnections = 0;
    if (document.getElementById('continuePathsCheckbox').checked) {
        const collinearBefore = vectorPaths.length;
        collinearConnections = collinearConnectionPhase(connectionStats);
        totalConnections += collinearConnections;
        console.log("Collinear connections:", connectionStats.collinear, "путей до:", collinearBefore, "после:", vectorPaths.length);
    }

    // Логирование результатов с учетом галочек
    const stats = {
        'Разрывы': breaksCreated,
        'Удаление отростков': document.getElementById('removeSpursCheckbox').checked ? 'выполнено' : 'пропущено',
        'Паралельных': document.getElementById('removeParallelCheckbox').checked ? pathDel : 'пропущено',
        'Перекрестки': document.getElementById('connectCrossroadsCheckbox').checked ? 'обработано' : 'пропущено',
        'Collinear': document.getElementById('continuePathsCheckbox').checked ? connectionStats.collinear : 'пропущено',
        'Всего соединений': totalConnections, 
        'Всего путей': vectorPaths.length
    };
    
    console.table(stats);
    
    updateStatus(`Разрывов: ${breaksCreated}, Соединений: ${totalConnections}`, 'success');
}


function breakVectorsAtSharpAngles(paths, maxAngle = 35) {
    // УБИРАЕМ конвертацию в радианы - работаем с градусами
    const newPaths = [];
    
    for (const path of paths) {
        if (path.length < 3) {
            newPaths.push(path);
            continue;
        }
        
        const segments = [];
        let currentSegment = [path[0]];
        
        for (let i = 1; i < path.length - 1; i++) {
            const prev = path[i-1];
            const curr = path[i];
            const next = path[i+1];
            
            const angle = calculateAngle(prev, curr, next);
            const absAngle = Math.abs(angle);
            
            //console.log(`Angle at point ${i}: ${angle}°`); // Отладка
            
            currentSegment.push(curr);
            
            // Сравниваем градусы с градусами!
            if (absAngle < maxAngle) {
                //console.log(`SHARP ANGLE DETECTED: ${absAngle}° < ${maxAngle}°`);
                segments.push([...currentSegment]);
                currentSegment = [curr];
            }
        }
        
        currentSegment.push(path[path.length - 1]);
        segments.push(currentSegment);
        
        newPaths.push(...segments);
    }
    
    return newPaths;
}

		//  Коллинеарные соединения (особенно важно для кривых)
function collinearConnectionPhase(stats) {
    let connectionsMade = 0; 
    const COLLINEAR_DISTANCE = 20; 
    
    let changed = true;
    let iterations = 0;
    
    while (changed && connectionsMade < 15 && iterations < 5) {
        changed = false;
        iterations++;
        
        for (let i = 0; i < vectorPaths.length && !changed; i++) {
            for (let j = i + 1; j < vectorPaths.length && !changed; j++) {
                const pathA = vectorPaths[i];
                const pathB = vectorPaths[j];
                
                if (pathA.length < 3 || pathB.length < 3) continue;
                
                const connectionTypes = [ 
                    { aEnd: true, bEnd: false, aPoint: pathA[pathA.length - 1], bPoint: pathB[0] },
                    { aEnd: true, bEnd: true, aPoint: pathA[pathA.length - 1], bPoint: pathB[pathB.length - 1] },
                    { aEnd: false, bEnd: false, aPoint: pathA[0], bPoint: pathB[0] },
                    { aEnd: false, bEnd: true, aPoint: pathA[0], bPoint: pathB[pathB.length - 1] }
                ];
                
                for (const conn of connectionTypes) {
                    const distance = distanceBetweenPoints(conn.aPoint, conn.bPoint);
                    
                    if (distance <= COLLINEAR_DISTANCE) {
                        const dirA = getSegmentDirection(pathA, conn.aEnd);
                        const dirB = getSegmentDirection(pathB, conn.bEnd);
                        
                        if (areSegmentsCollinearRelaxed(conn.aPoint, dirA, conn.bPoint, dirB)) {
                            // ФИКС: правильные параметры
                            if (performPathConnection(i, j, conn.aEnd, conn.bEnd, {
                                addIntermediatePoints: false
                            })) {
                                connectionsMade++;
                                stats.collinear++;
                                changed = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
    }
    
    return connectionsMade;
}


		// Упрощенная проверка коллинеарности для кривых
		function areSegmentsCollinearRelaxed(pointA, dirA, pointB, dirB, tolerance = 0.2) {
			const connectVector = { x: pointB.x - pointA.x, y: pointB.y - pointA.y };
			
			if (distanceBetweenPoints(pointA, pointB) < 3) return true;
			
			const normConnect = normalizeVector(connectVector);
			const normDirA = normalizeVector(dirA);
			const normDirB = normalizeVector(dirB);
			
			const dotA = Math.abs(normConnect.x * normDirA.x + normConnect.y * normDirA.y);
			const dotB = Math.abs(normConnect.x * normDirB.x + normConnect.y * normDirB.y);
			
			return dotA > (1 - tolerance) && dotB > (1 - tolerance);
		}

function performPathConnection(pathAIndex, pathBIndex, connectAEnd, connectBEnd, options = {}) {
    const {
        reverseA = false,
        reverseB = false,
        addIntermediatePoints = false,
        maxIntermediatePoints = 2
    } = options;

    try {
        const pathA = vectorPaths[pathAIndex];
        const pathB = vectorPaths[pathBIndex];
        
        if (!pathA || !pathB || pathA.length < 2 || pathB.length < 2) {
            return false;
        }

        // Подготовка путей - ФИКС: логика reverse была неправильной
        let finalPathA, finalPathB;
        
        if (connectAEnd && connectBEnd) {
            // A.end → B.end (оба конца) - разворачиваем B
            finalPathA = [...pathA];
            finalPathB = [...pathB].reverse();
        } else if (connectAEnd && !connectBEnd) {
            // A.end → B.start - обычное соединение
            finalPathA = [...pathA];
            finalPathB = [...pathB];
        } else if (!connectAEnd && connectBEnd) {
            // A.start → B.end - разворачиваем оба
            finalPathA = [...pathA].reverse();
            finalPathB = [...pathB];
        } else {
            // A.start → B.start - разворачиваем A
            finalPathA = [...pathA].reverse();
            finalPathB = [...pathB].reverse();
        }

        let connectedPath;

        if (addIntermediatePoints) {
            const pointA = connectAEnd ? finalPathA[finalPathA.length - 1] : finalPathA[0];
            const pointB = connectBEnd ? finalPathB[finalPathB.length - 1] : finalPathB[0];
            const intermediatePoints = createIntermediatePoints(pointA, pointB, maxIntermediatePoints);
            
            connectedPath = [...finalPathA, ...intermediatePoints, ...finalPathB];
        } else {
            connectedPath = [...finalPathA, ...finalPathB];
        }

        if (connectedPath.length >= 2) {
            vectorPaths[pathAIndex] = connectedPath;
            vectorPaths.splice(pathBIndex, 1);
            return true;
        }

        return false;
    } catch (error) {
        console.warn('Ошибка соединения путей:', error);
        return false;
    }
}

// паралельные
function mergeCloseParallelLines() {
    if (vectorPaths.length < 2) return 0;
    
    let mergedCount = 0;
    const mergedIndices = new Set();
    
    // Параметры для поиска близких линий
    const distanceThreshold = 4; // максимальное расстояние между линиями
    const angleThreshold = 3; // градусов
    const minOverlapRatio = 0.3; // минимальное перекрытие для объединения
    
    // Сначала находим все пары близких параллельных линий
    const candidates = [];
    
    for (let i = 0; i < vectorPaths.length; i++) {
        if (mergedIndices.has(i)) continue;
        
        const lineA = vectorPaths[i];
        if (!lineA || lineA.length < 2) continue;
        
        for (let j = i + 1; j < vectorPaths.length; j++) {
            if (mergedIndices.has(j)) continue;
            
            const lineB = vectorPaths[j];
            if (!lineB || lineB.length < 2) continue;
            
            // Проверяем параллельность и близость
            if (areLinesCloseAndParallel(lineA, lineB, distanceThreshold, angleThreshold, minOverlapRatio)) {
                candidates.push({i, j, distance: calculateLinesDistance(lineA, lineB)});
            }
        }
    }
    
    // Сортируем кандидатов по расстоянию (сначала самые близкие)
    candidates.sort((a, b) => a.distance - b.distance);
    
    // Объединяем линии
    for (const candidate of candidates) {
        if (mergedIndices.has(candidate.i) || mergedIndices.has(candidate.j)) continue;
        
        const mergedLine = mergeTwoLines(
            vectorPaths[candidate.i], 
            vectorPaths[candidate.j]
        );
        
        if (mergedLine) {
            // Заменяем первую линию объединенной
            vectorPaths[candidate.i] = mergedLine;
            // Помечаем вторую для удаления
            mergedIndices.add(candidate.j);
            mergedCount++;
            
            console.log(`Merged lines ${candidate.i} and ${candidate.j}`);
        }
    }
    
    // Удаляем объединенные линии
    const indicesToRemove = Array.from(mergedIndices).sort((a, b) => b - a);
    for (const index of indicesToRemove) {
        vectorPaths.splice(index, 1);
    }
    
    if (mergedCount > 0) {
        updateStatus(`Объединено близких параллельных линий: ${mergedCount}`, 'success');
    }
    
    return mergedCount;
}

// Проверяет, являются ли две линии близкими и параллельными
function areLinesCloseAndParallel(lineA, lineB, maxDistance, angleThreshold, minOverlapRatio) {
    const dirA = getLineDirection(lineA);
    const dirB = getLineDirection(lineB);
    
    // Проверяем параллельность
    if (!areVectorsParallel(dirA, dirB, angleThreshold)) {
        return false;
    }
    
    // Вычисляем расстояние между линиями
    const distance = calculateLinesDistance(lineA, lineB);
    if (distance > maxDistance) {
        return false;
    }
    
    // Проверяем перекрытие по проекции
    const overlap = calculateLinesOverlap(lineA, lineB);
    if (overlap < minOverlapRatio) {
        return false;
    }
    
    return true;
}

// Вычисляет направление линии (среднее направление всех сегментов)
function getLineDirection(line) {
    if (line.length < 2) return 0;
    
    let totalDX = 0;
    let totalDY = 0;
    
    for (let i = 1; i < line.length; i++) {
        totalDX += line[i].x - line[i-1].x;
        totalDY += line[i].y - line[i-1].y;
    }
    
    return Math.atan2(totalDY, totalDX);
}

// Вычисляет расстояние между двумя линиями
function calculateLinesDistance(lineA, lineB) {
    // Берем несколько точек на каждой линии и находим минимальное расстояние
    const samplePointsA = sampleLinePoints(lineA, 10);
    const samplePointsB = sampleLinePoints(lineB, 10);
    
    let minDistance = Infinity;
    
    for (const pointA of samplePointsA) {
        for (const pointB of samplePointsB) {
            const dist = distanceBetweenPoints(pointA, pointB);
            if (dist < minDistance) {
                minDistance = dist;
            }
        }
    }
    
    return minDistance;
}

// Берет равномерно распределенные точки на линии
function sampleLinePoints(line, numPoints) {
    const points = [];
    const totalLength = calculatePathLength(line);
    
    for (let i = 0; i <= numPoints; i++) {
        const targetLength = (totalLength * i) / numPoints;
        points.push(getPointAtLength(line, targetLength));
    }
    
    return points;
}

// Получает точку на линии на заданном расстоянии от начала
function getPointAtLength(line, targetLength) {
    if (targetLength <= 0) return {...line[0]};
    
    let accumulatedLength = 0;
    
    for (let i = 1; i < line.length; i++) {
        const segmentLength = distanceBetweenPoints(line[i-1], line[i]);
        
        if (accumulatedLength + segmentLength >= targetLength) {
            const ratio = (targetLength - accumulatedLength) / segmentLength;
            return {
                x: line[i-1].x + (line[i].x - line[i-1].x) * ratio,
                y: line[i-1].y + (line[i].y - line[i-1].y) * ratio
            };
        }
        
        accumulatedLength += segmentLength;
    }
    
    return {...line[line.length - 1]};
}

// Вычисляет перекрытие двух линий по проекции
function calculateLinesOverlap(lineA, lineB) {
    const direction = getLineDirection(lineA);
    
    // Проецируем точки на перпендикулярное направление
    const projA = projectLineToAxis(lineA, direction);
    const projB = projectLineToAxis(lineB, direction);
    
    // Вычисляем перекрытие проекций
    const overlapStart = Math.max(projA.min, projB.min);
    const overlapEnd = Math.min(projA.max, projB.max);
    
    if (overlapEnd <= overlapStart) return 0;
    
    const overlapLength = overlapEnd - overlapStart;
    const maxLength = Math.max(projA.max - projA.min, projB.max - projB.min);
    
    return overlapLength / maxLength;
}

// Проецирует линию на ось, заданную направлением
function projectLineToAxis(line, direction) {
    const perpendicular = direction + Math.PI / 2; // Перпендикулярное направление
    
    let min = Infinity;
    let max = -Infinity;
    
    for (const point of line) {
        const projection = point.x * Math.cos(perpendicular) + point.y * Math.sin(perpendicular);
        min = Math.min(min, projection);
        max = Math.max(max, projection);
    }
    
    return { min, max };
}

// Объединяет две близкие параллельные линии в одну
function mergeTwoLines(lineA, lineB) {
    // Собираем все точки из обеих линий
    const allPoints = [...lineA, ...lineB];
    
    // Находим основное направление
    const direction = getLineDirection(lineA);
    
    // Проецируем точки на направление линии
    const projectedPoints = allPoints.map(point => ({
        point,
        projection: point.x * Math.cos(direction) + point.y * Math.sin(direction)
    }));
    
    // Сортируем точки по проекции
    projectedPoints.sort((a, b) => a.projection - b.projection);
    
    // Берем упрощенную линию через крайние точки
    const simplifiedLine = [
        projectedPoints[0].point,
        projectedPoints[projectedPoints.length - 1].point
    ];
    
    // Можно добавить промежуточные точки для лучшего приближения
    if (projectedPoints.length > 4) {
        const midIndex = Math.floor(projectedPoints.length / 2);
        simplifiedLine.splice(1, 0, projectedPoints[midIndex].point);
    }
    
    return simplifiedLine;
}


// Проверка параллельности двух векторов
function areVectorsParallel(dirA, dirB, angleThreshold) {
    const angleDiff = Math.abs(dirA - dirB);
    const normalizedDiff = Math.min(angleDiff, Math.PI * 2 - angleDiff);
    const thresholdRad = angleThreshold * Math.PI / 180;
    return normalizedDiff <= thresholdRad || 
           Math.abs(normalizedDiff - Math.PI) <= thresholdRad; // Учитываем противоположное направление
}

//fin паралельные

function removeShortConnectedVectors() {
    if (vectorPaths.length < 2) return 0;
    
    const toRemove = new Set();
    const lengthRatioThreshold = 0.03; // 3% от длины большего вектора
    
    // Строим граф соединений
    const connections = buildVectorConnections();
    
    // Проходим по всем точкам соединения
    for (const [pointKey, vectorIndices] of connections) {
        // Нас интересуют точки, где соединены РОВНО 2 вектора
        if (vectorIndices.size !== 2) continue;
        
        const [indexA, indexB] = Array.from(vectorIndices);
        
        // Проверяем, что векторы еще не помечены для удаления
        if (toRemove.has(indexA) || toRemove.has(indexB)) continue;
        
        const vectorA = vectorPaths[indexA];
        const vectorB = vectorPaths[indexB];
        
        if (!vectorA || !vectorB || vectorA.length < 2 || vectorB.length < 2) continue;
        
        // Проверяем, что векторы соединены именно КРАЙНИМИ точками
        if (areVectorsConnectedAtEnds(indexA, indexB, connections)) {
            const lengthA = calculatePathLength(vectorA);
            const lengthB = calculatePathLength(vectorB);
            
            // Находим соотношение длин
            const ratio = Math.min(lengthA, lengthB) / Math.max(lengthA, lengthB);
            
            // Если один вектор значительно короче другого
            if (ratio < lengthRatioThreshold) {
                const shortIndex = lengthA < lengthB ? indexA : indexB;
                toRemove.add(shortIndex);
                
                console.log(`Removing short connected vector: ${shortIndex} (ratio: ${ratio.toFixed(3)})`);
                console.log(`  Vector ${indexA} length: ${lengthA.toFixed(2)}`);
                console.log(`  Vector ${indexB} length: ${lengthB.toFixed(2)}`);
            }
        }
    }
    
    // Применяем удаление
    const indicesToRemove = Array.from(toRemove).sort((a, b) => b - a);
    for (const index of indicesToRemove) {
        vectorPaths.splice(index, 1);
    }
    
    if (toRemove.size > 0) {
        updateStatus(`Удалено коротких соединенных векторов: ${toRemove.size}`, 'success');
    }
    
    return toRemove.size;
}

// Проверяет, соединены ли два вектора именно крайними точками
function areVectorsConnectedAtEnds(indexA, indexB, connections) {
    const vectorA = vectorPaths[indexA];
    const vectorB = vectorPaths[indexB];
    
    const aStart = vectorA[0];
    const aEnd = vectorA[vectorA.length - 1];
    const bStart = vectorB[0];
    const bEnd = vectorB[vectorB.length - 1];
    
    // Проверяем все возможные комбинации соединения крайних точек
    const connectionPoints = [];
    
    if (pointsAreEqual(aStart, bStart) || pointsAreEqual(aStart, bEnd)) {
        connectionPoints.push(aStart);
    }
    if (pointsAreEqual(aEnd, bStart) || pointsAreEqual(aEnd, bEnd)) {
        connectionPoints.push(aEnd);
    }
    
    // Должна быть ровно одна точка соединения (исключаем случай когда векторы полностью совпадают)
    if (connectionPoints.length !== 1) return false;
    
    const connectionPoint = connectionPoints[0];
    
    // Проверяем, что в точке соединения нет других векторов
    const pointKey = `${Math.round(connectionPoint.x)},${Math.round(connectionPoint.y)}`;
    const pointConnections = connections.get(pointKey);
    
    return pointConnections && pointConnections.size === 2;
}

// Проверяет, совпадают ли две точки (с учетом погрешности)
function pointsAreEqual(pointA, pointB, tolerance = 1) {
    return Math.abs(pointA.x - pointB.x) <= tolerance && 
           Math.abs(pointA.y - pointB.y) <= tolerance;
}

// Строит граф соединений между существующими векторами
function buildVectorConnections() {
    const connections = new Map();
    
    for (let i = 0; i < vectorPaths.length; i++) {
        const vector = vectorPaths[i];
        if (!vector || vector.length < 2) continue;
        
        const start = vector[0];
        const end = vector[vector.length - 1];
        
        // Добавляем соединения по начальным и конечным точкам
        addConnection(connections, start, i);
        addConnection(connections, end, i);
    }
    
    return connections;
}

function addConnection(connections, point, vectorIndex) {
    const key = `${Math.round(point.x)},${Math.round(point.y)}`;
    if (!connections.has(key)) {
        connections.set(key, new Set());
    }
    connections.get(key).add(vectorIndex);
}

// --

function connectCrossroadPointsSafe() {
    console.log("Start connectCrossroadPointsSafe, initial count:", vectorPaths.length);
    
    const distanceThreshold = 10;
    let totalConnectionsMade = 0;
    const maxIterations = 3;
    
    // Многократный перезапуск для обработки всех перекрестков
    for (let iteration = 1; iteration <= maxIterations; iteration++) {
        console.log(`=== Iteration ${iteration} ===`);
        
        const connectionsInIteration = processAllCrossroads(distanceThreshold);
        totalConnectionsMade += connectionsInIteration;
        
        console.log(`Iteration ${iteration}: made ${connectionsInIteration} connections`);
        
        if (connectionsInIteration === 0) {
            break; // Больше нет перекрестков для обработки
        }
    }
    
    console.log("Final vectorPaths count:", vectorPaths.length);
    
    if (totalConnectionsMade > 0) {
        updateStatus(`Объединено ${totalConnectionsMade} пар векторов в перекрестках`, 'success');
    }
    
    return totalConnectionsMade;
}

function processAllCrossroads(distanceThreshold) {
    // 1. Собираем ВСЕ конечные точки и создаем карту перекрестков
    const endpoints = [];
    
    // Создаем стабильные идентификаторы для путей
    for (let i = 0; i < vectorPaths.length; i++) {
        const path = vectorPaths[i];
        if (!path || path.length < 2) continue;
        
        // Создаем уникальный ID для пути
        const pathId = generatePathId(path);
        
        endpoints.push({ 
            point: path[0], 
            path: path,
            pathId: pathId,
            isStart: true,
            endpointId: `${pathId}_start`
        });
        
        endpoints.push({ 
            point: path[path.length - 1], 
            path: path,
            pathId: pathId,
            isStart: false,
            endpointId: `${pathId}_end`
        });
    }
    
    // 2. Находим ВСЕ перекрестки (и с 3, и с 4 векторами)
    const allCrossroads = findAllCrossroads(endpoints, distanceThreshold);
    console.log(`Found ${allCrossroads.length} crossroads total`);
    
    if (allCrossroads.length === 0) return 0;
    
    // 3. Собираем ВСЕ возможные пары из ВСЕХ перекрестков
    const allPairs = [];
    const usedPaths = new Set(); // Отслеживаем пути, которые уже участвуют в парах
    
    for (const crossroad of allCrossroads) {
        const crossroadPairs = findPairsInCrossroad(crossroad, usedPaths);
        allPairs.push(...crossroadPairs);
    }
    
    console.log(`Total pairs found: ${allPairs.length}`);
    
    // 4. Группируем пары по перекресткам и обрабатываем их оптимально
    const connectionsMade = processPairsByCrossroad(allPairs);
    
    return connectionsMade;
}

function findAllCrossroads(endpoints, distanceThreshold) {
    const crossroads = [];
    const usedEndpointIds = new Set();
    
    for (let i = 0; i < endpoints.length; i++) {
        if (usedEndpointIds.has(endpoints[i].endpointId)) continue;
        
        const cluster = [endpoints[i]];
        usedEndpointIds.add(endpoints[i].endpointId);
        
        // Находим все близкие точки
        for (let j = 0; j < endpoints.length; j++) {
            if (usedEndpointIds.has(endpoints[j].endpointId)) continue;
            
            const dist = distanceBetweenPoints(endpoints[i].point, endpoints[j].point);
            if (dist <= distanceThreshold) {
                cluster.push(endpoints[j]);
                usedEndpointIds.add(endpoints[j].endpointId);
            }
        }
        
        // Находим уникальные пути в кластере
        const uniquePathIds = [...new Set(cluster.map(ep => ep.pathId))];
        
        // Нас интересуют перекрестки с 3 ИЛИ 4 путями
        if (uniquePathIds.length === 3 || uniquePathIds.length === 4) {
            const center = {
                x: cluster.reduce((sum, ep) => sum + ep.point.x, 0) / cluster.length,
                y: cluster.reduce((sum, ep) => sum + ep.point.y, 0) / cluster.length
            };
            
            crossroads.push({
                endpoints: cluster,
                pathIds: uniquePathIds,
                center: center,
                crossroadId: `crossroad_${uniquePathIds.length}_${crossroads.length}`,
                type: uniquePathIds.length === 3 ? 'triple' : 'quadruple'
            });
            
            console.log(`Found ${uniquePathIds.length}-way crossroad with paths:`, uniquePathIds);
        }
    }
    
    console.log(`Found crossroads: ${crossroads.filter(c => c.type === 'triple').length} triple, ${crossroads.filter(c => c.type === 'quadruple').length} quadruple`);
    
    return crossroads;
}

function findPairsInCrossroad(crossroad, usedPaths) {
    const pairs = [];
    const usedEndpointIds = new Set();
    const endpoints = crossroad.endpoints;
    
    // Для тройных перекрестков - особый алгоритм
    if (crossroad.type === 'triple') {
        return findPairsInTripleCrossroad(crossroad, usedPaths);
    }
    
    // Для четверных перекрестков - стандартный алгоритм
    const sortedEndpoints = [...endpoints].sort((a, b) => {
        const distA = distanceBetweenPoints(a.point, crossroad.center);
        const distB = distanceBetweenPoints(b.point, crossroad.center);
        return distA - distB;
    });
    
    for (let i = 0; i < sortedEndpoints.length; i++) {
        if (usedEndpointIds.has(sortedEndpoints[i].endpointId)) continue;
        
        let bestMatch = null;
        let bestScore = -Infinity;
        
        for (let j = 0; j < sortedEndpoints.length; j++) {
            if (i === j) continue;
            if (usedEndpointIds.has(sortedEndpoints[j].endpointId)) continue;
            
            // Проверяем, что это разные пути и они еще не используются
            if (sortedEndpoints[i].pathId !== sortedEndpoints[j].pathId &&
                !usedPaths.has(sortedEndpoints[i].pathId) &&
                !usedPaths.has(sortedEndpoints[j].pathId)) {
                
                const score = calculateOppositeScore(sortedEndpoints[i], sortedEndpoints[j], crossroad.center);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = sortedEndpoints[j];
                }
            }
        }
        
        if (bestMatch && bestScore > 0.3) {
            pairs.push({
                ep1: sortedEndpoints[i],
                ep2: bestMatch,
                crossroadId: crossroad.crossroadId,
                score: bestScore,
                type: crossroad.type
            });
            
            usedEndpointIds.add(sortedEndpoints[i].endpointId);
            usedEndpointIds.add(bestMatch.endpointId);
            usedPaths.add(sortedEndpoints[i].pathId);
            usedPaths.add(bestMatch.pathId);
        }
    }
    
    return pairs;
}

// Новая функция для обработки тройных перекрестков
function findPairsInTripleCrossroad(crossroad, usedPaths) {
    const pairs = [];
    const endpoints = crossroad.endpoints;
    
    // В тройном перекрестке у нас 3 пути = 6 конечных точек
    // Нужно найти 1-2 лучшие пары
    
    // Группируем endpoints по путям
    const endpointsByPath = new Map();
    for (const ep of endpoints) {
        if (!endpointsByPath.has(ep.pathId)) {
            endpointsByPath.set(ep.pathId, []);
        }
        endpointsByPath.get(ep.pathId).push(ep);
    }
    
    // Для тройного перекрестка пробуем все возможные комбинации пар
    const pathIds = Array.from(endpointsByPath.keys());
    
    for (let i = 0; i < pathIds.length; i++) {
        for (let j = i + 1; j < pathIds.length; j++) {
            const path1Id = pathIds[i];
            const path2Id = pathIds[j];
            
            // Пропускаем если пути уже используются
            if (usedPaths.has(path1Id) || usedPaths.has(path2Id)) continue;
            
            // Находим лучшую пару между этими двумя путями
            const path1Endpoints = endpointsByPath.get(path1Id);
            const path2Endpoints = endpointsByPath.get(path2Id);
            
            let bestPair = null;
            let bestScore = -Infinity;
            
            for (const ep1 of path1Endpoints) {
                for (const ep2 of path2Endpoints) {
                    const score = calculateOppositeScore(ep1, ep2, crossroad.center);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestPair = { ep1, ep2 };
                    }
                }
            }
            
            if (bestPair && bestScore > 0.2) { // Более низкий порог для тройных
                pairs.push({
                    ep1: bestPair.ep1,
                    ep2: bestPair.ep2,
                    crossroadId: crossroad.crossroadId,
                    score: bestScore,
                    type: crossroad.type
                });
                
                usedPaths.add(path1Id);
                usedPaths.add(path2Id);
                
                // В тройном перекрестке обычно можно создать только 1-2 пары
                break;
            }
        }
    }
    
    return pairs;
}

function processPairsByCrossroad(allPairs) {
    // Группируем пары по перекресткам
    const pairsByCrossroad = new Map();
    
    for (const pair of allPairs) {
        if (!pairsByCrossroad.has(pair.crossroadId)) {
            pairsByCrossroad.set(pair.crossroadId, []);
        }
        pairsByCrossroad.get(pair.crossroadId).push(pair);
    }
    
    let totalConnections = 0;
    
    // Обрабатываем каждый перекресток
    for (const [crossroadId, pairs] of pairsByCrossroad) {
        console.log(`Processing crossroad ${crossroadId} with ${pairs.length} pairs`);
        
        // Сортируем пары по качеству (score)
        pairs.sort((a, b) => b.score - a.score);
        
        const connectionsInCrossroad = processPairsInCrossroad(pairs); // ПРАВИЛЬНОЕ название переменной
        totalConnections += connectionsInCrossroad; // ПРАВИЛЬНОЕ название переменной
        
        console.log(`Crossroad ${crossroadId}: made ${connectionsInCrossroad} connections`); // ПРАВИЛЬНОЕ название
    }
    
    return totalConnections;
}

function processPairsInCrossroad(pairs) {
    let connectionsMade = 0;
    
    for (const pair of pairs) {
        // Находим текущие индексы путей (они могли измениться!)
        const path1Info = findPathInfoById(pair.ep1.pathId);
        const path2Info = findPathInfoById(pair.ep2.pathId);
        
        if (!path1Info || !path2Info) {
            console.log("Paths not found, skipping pair");
            continue;
        }
        
        // Проверяем, что пути еще существуют и не были изменены
        if (path1Info.index === -1 || path2Info.index === -1) {
            continue;
        }
        
        if (vectorPaths[path1Info.index] !== path1Info.path || 
            vectorPaths[path2Info.index] !== path2Info.path) {
            continue;
        }
        
        // Создаем объединенный путь
        const middlePoint = {
            x: (pair.ep1.point.x + pair.ep2.point.x) / 2,
            y: (pair.ep1.point.y + pair.ep2.point.y) / 2
        };
        
        const continuousPath = createContinuousPathFromEndpoints(pair.ep1, pair.ep2, middlePoint);
        
        if (continuousPath.length > 1) {
            // Заменяем первый путь объединенным
            vectorPaths[path1Info.index] = continuousPath;
            // Удаляем второй путь
            vectorPaths.splice(path2Info.index, 1);
            
            connectionsMade++;
            console.log(`Connected paths ${path1Info.index} and ${path2Info.index} in ${pair.type} crossroad`);
        }
    }
    
    return connectionsMade;
}

// Остальные вспомогательные функции остаются без изменений
function generatePathId(path) {
    const str = `${path[0].x},${path[0].y}-${path[path.length-1].x},${path[path.length-1].y}`;
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return 'path_' + Math.abs(hash);
}

function findPathInfoById(pathId) {
    for (let i = 0; i < vectorPaths.length; i++) {
        const path = vectorPaths[i];
        if (!path) continue;
        
        const currentPathId = generatePathId(path);
        if (currentPathId === pathId) {
            return { path: path, index: i, id: pathId };
        }
    }
    return null;
}

function createContinuousPathFromEndpoints(ep1, ep2, mergedPoint) {
    const continuousPath = [];
    
    // Добавляем первый вектор до объединенной точки
    if (ep1.isStart) {
        continuousPath.push(...ep1.path.slice().reverse().slice(0, -1));
    } else {
        continuousPath.push(...ep1.path.slice(0, -1));
    }
    
    // Добавляем объединенную точку
    continuousPath.push(mergedPoint);
    
    // Добавляем второй вектор от объединенной точки
    if (ep2.isStart) {
        continuousPath.push(...ep2.path.slice(1));
    } else {
        continuousPath.push(...ep2.path.slice(0, -1).reverse());
    }
    
    return continuousPath;
}

function calculateOppositeScore(ep1, ep2, center) {
    const vec1 = { x: ep1.point.x - center.x, y: ep1.point.y - center.y };
    const vec2 = { x: ep2.point.x - center.x, y: ep2.point.y - center.y };
    
    const len1 = Math.sqrt(vec1.x * vec1.x + vec1.y * vec1.y);
    const len2 = Math.sqrt(vec2.x * vec2.x + vec2.y * vec2.y);
    
    if (len1 === 0 || len2 === 0) return 0;
    
    const norm1 = { x: vec1.x / len1, y: vec1.y / len1 };
    const norm2 = { x: vec2.x / len2, y: vec2.y / len2 };
    
    const dot = norm1.x * norm2.x + norm1.y * norm2.y;
    return -dot;
}

// --

		// Функция для расчета длины пути
		function calculatePathLength(path) {
			if (path.length < 2) return 0;
			
			let length = 0;
			for (let i = 1; i < path.length; i++) {
				const dx = path[i].x - path[i-1].x;
				const dy = path[i].y - path[i-1].y;
				length += Math.sqrt(dx * dx + dy * dy);
			}
			return length;
		}


		async function validateAndOptimizeConnections() {
			drawProgressIndicator(88, 'Валидация соединений...');
			
			let improvements = 0;
			const maxIterations = 5;
			
			for (let iteration = 0; iteration < maxIterations; iteration++) {
				const improvementsInIteration = await performConnectionValidation();
				improvements += improvementsInIteration;
				
				if (improvementsInIteration === 0) break;
				
				drawProgressIndicator(88 + iteration * 2, `Оптимизация ${iteration + 1}/${maxIterations}`);
				await new Promise(resolve => setTimeout(resolve, 50));
			}
			
			return improvements;
		}

		async function performConnectionValidation() {
			let improvements = 0;
			let changed = true;
			
			while (changed && improvements < 20) {
				changed = false;
				
				const pathsCopy = [...vectorPaths];
				
				for (let i = 0; i < pathsCopy.length && !changed; i++) {
					const path = pathsCopy[i];
					if (path.length < 6) continue;
					
					const problematicJoints = findProblematicJoints(path);
					
					for (const joint of problematicJoints) {

						const betterConnection = await findBetterConnection(path, joint, i);
						if (betterConnection) {
							improvements++;
							changed = true;
							break;
						}
					}
				}
			}
			
			return improvements;
		}

		function findProblematicJoints(path) {
			const problematic = [];
			const ANGLE_THRESHOLD = 45; // градусов
			
			for (let i = 1; i < path.length - 2; i++) {
				const prevPoint = path[i - 1];
				const currentPoint = path[i];
				const nextPoint = path[i + 1];
				const nextNextPoint = path[i + 2];

				const angle1 = calculateAngle(prevPoint, currentPoint, nextPoint);
				const angle2 = calculateAngle(currentPoint, nextPoint, nextNextPoint);

				if (Math.abs(angle1) > ANGLE_THRESHOLD || Math.abs(angle2) > ANGLE_THRESHOLD) {
					problematic.push({
						index: i,
						point: currentPoint,
						angle: Math.max(Math.abs(angle1), Math.abs(angle2)),
						type: 'sharp_angle'
					});
				}
				
				// Проверяем на встречные углы (>< паттерн)
				if (isOppositeAnglePattern(path, i)) {
					problematic.push({
						index: i,
						point: currentPoint,
						angle: 180, // максимальный угол
						type: 'opposite_angle'
					});
				}
			}
			
			return problematic.sort((a, b) => b.angle - a.angle); 
		}

		function calculateCurrentScore(path, problematicJoint) {
			if (!path || path.length < 3) return 0;
			
			let totalScore = 0;
			const breakPoint = problematicJoint.index;

			const anglePenalty = calculateAnglePenalty(path, breakPoint);

			const distancePenalty = calculateDistancePenalty(path, breakPoint);

			const patternPenalty = calculatePatternPenalty(path, breakPoint);

			const smoothnessBonus = calculateSmoothnessBonus(path, breakPoint);

			totalScore = 100 - anglePenalty - distancePenalty - patternPenalty + smoothnessBonus;
			
			return Math.max(0, totalScore);
		}

		function calculateAnglePenalty(path, breakPoint) {
			let penalty = 0;

			const analysisRange = 3;
			const start = Math.max(1, breakPoint - analysisRange);
			const end = Math.min(path.length - 2, breakPoint + analysisRange);
			
			for (let i = start; i <= end; i++) {
				const angle = Math.abs(calculateAngle(path[i-1], path[i], path[i+1]));
				
				if (angle > 45) {
					penalty += Math.pow((angle - 45) / 10, 2);
				}
				
				if (angle > 120) {
					penalty += 20;
				}
			}
			
			return penalty;
		}

		function calculateDistancePenalty(path, breakPoint) {
			if (breakPoint < 0 || breakPoint >= path.length - 1) return 0;
			
			const pointBefore = path[breakPoint];
			const pointAfter = path[breakPoint + 1];
			const distance = distanceBetweenPoints(pointBefore, pointAfter);

			if (distance > 5) {
				return (distance - 5) * 2; 
			}
			
			return 0;
		}

		function calculatePatternPenalty(path, breakPoint) {
			let penalty = 0;

			if (isOppositeAnglePattern(path, breakPoint)) {
				penalty += 30; 
			}

			if (isZigzagPattern(path, breakPoint)) {
				penalty += 15;
			}
			
			if (breakPoint > 0 && breakPoint < path.length - 1) {
				const acuteAngle = Math.abs(calculateAngle(path[breakPoint-1], path[breakPoint], path[breakPoint+1]));
				if (acuteAngle < 30) {
					penalty += 10; 
				}
			}
			
			return penalty;
		}

		function calculateSmoothnessBonus(path, breakPoint) {
			let bonus = 0;
			
			const smoothnessRange = 2;
			let smoothSegments = 0;
			let totalSegments = 0;
			
			for (let i = Math.max(1, breakPoint - smoothnessRange); i <= Math.min(path.length - 2, breakPoint + smoothnessRange); i++) {
				const angle = Math.abs(calculateAngle(path[i-1], path[i], path[i+1]));
				totalSegments++;
				
				if (angle < 15) { 
					smoothSegments++;
				}
			}

			if (totalSegments > 0) {
				const smoothnessRatio = smoothSegments / totalSegments;
				if (smoothnessRatio > 0.7) {
					bonus = smoothnessRatio * 20; 
				}
			}
			
			return bonus;
		}

		// Вспомогательные функции для паттернов
		function isZigzagPattern(path, centerIndex) {
			if (centerIndex < 2 || centerIndex > path.length - 3) return false;
			
			const angles = [];
			for (let i = centerIndex - 2; i <= centerIndex + 2; i++) {
				if (i > 0 && i < path.length - 1) {
					const angle = calculateAngle(path[i-1], path[i], path[i+1]);
					angles.push(angle);
				}
			}
			
			let signChanges = 0;
			for (let i = 1; i < angles.length; i++) {
				if (angles[i] * angles[i-1] < 0 && Math.abs(angles[i]) > 20 && Math.abs(angles[i-1]) > 20) {
					signChanges++;
				}
			}
			
			return signChanges >= 2; 
		}

		// Функция расчета угла между тремя точками (возвращает градусы)
		function calculateAngle(p1, p2, p3) {
			const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
			const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
			
			const dot = v1.x * v2.x + v1.y * v2.y;
			const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
			const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);

			if (mag1 === 0 || mag2 === 0) return 0;
			
			const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
			const angleRad = Math.acos(cosAngle);
			const angleDeg = angleRad * 180 / Math.PI;
			
			const cross = v1.x * v2.y - v1.y * v2.x;
			
			return cross < 0 ? -angleDeg : angleDeg;
		}

		function isOppositeAnglePattern(path, index) {
			if (index < 2 || index > path.length - 3) return false;
			
			const p1 = path[index - 2];
			const p2 = path[index - 1];
			const p3 = path[index];
			const p4 = path[index + 1];
			const p5 = path[index + 2];
			
			const angle1 = calculateAngle(p1, p2, p3);
			const angle2 = calculateAngle(p3, p4, p5);
			
			return Math.abs(angle1) > 60 && Math.abs(angle2) > 60 && angle1 * angle2 < 0;
		}

		async function findBetterConnection(originalPath, problematicJoint, pathIndex) {
			const breakPoint = problematicJoint.index;
			
			const partA = originalPath.slice(0, breakPoint + 1);
			const partB = originalPath.slice(breakPoint + 1);
			
			if (partA.length < 2 || partB.length < 2) return false;
			
			let bestAlternative = null;
			let bestScore = -Infinity;
			
			for (let i = 0; i < vectorPaths.length; i++) {
				if (i === pathIndex) continue;
				
				const candidatePath = vectorPaths[i];
				const alternatives = findAlternativeConnections(partA, partB, candidatePath);
				
				for (const alt of alternatives) {
					if (alt.score > bestScore) {
						bestScore = alt.score;
						bestAlternative = { ...alt, targetPathIndex: i };
					}
				}
			}
			
			if (bestAlternative && bestScore > calculateCurrentScore(originalPath, problematicJoint)) {
				return applyBetterConnection(pathIndex, bestAlternative);
			}
			
			return false;
		}

		function findAlternativeConnections(partA, partB, candidatePath) {
			const alternatives = [];
			const MAX_DISTANCE = 20;
			
			const connections = [

				{ type: 'A_C_B', aEnd: partA[partA.length - 1], cStart: candidatePath[0], bStart: partB[0] },

				{ type: 'A_Cend_B', aEnd: partA[partA.length - 1], cEnd: candidatePath[candidatePath.length - 1], bStart: partB[0] },

				{ type: 'A_Cmerged_B', aEnd: partA[partA.length - 1], cPath: candidatePath, bStart: partB[0] }
			];
			
			for (const conn of connections) {
				const score = calculateConnectionScore(partA, partB, candidatePath, conn);
				if (score > 0) {
					alternatives.push({
						type: conn.type,
						candidatePath: candidatePath,
						score: score,
						connection: conn
					});
				}
			}
			
			return alternatives;
		}

		function calculateConnectionScore(partA, partB, candidatePath, connection) {
			let totalDistance = 0;
			let totalAngle = 0;
			
			switch (connection.type) {
				case 'A_C_B':
					totalDistance = distanceBetweenPoints(connection.aEnd, connection.cStart) +
								  distanceBetweenPoints(connection.cStart, connection.bStart);

					const dirA = getSegmentDirection([partA[partA.length - 2], connection.aEnd], true);
					const dirC1 = getSegmentDirection([connection.cStart, candidatePath[1]], false);
					const dirC2 = getSegmentDirection([candidatePath[candidatePath.length - 2], connection.cStart], true);
					const dirB = getSegmentDirection([connection.bStart, partB[1]], false);
					
					totalAngle = Math.abs(calculateAngleBetweenVectors(dirA, dirC1)) +
								Math.abs(calculateAngleBetweenVectors(dirC2, dirB));
					break;
					
				case 'A_Cend_B':
					totalDistance = distanceBetweenPoints(connection.aEnd, connection.cEnd) +
								  distanceBetweenPoints(connection.cEnd, connection.bStart);

					break;
			}
			
			return 1000 / (totalDistance + totalAngle * 10);
		}

		function calculateAngleBetweenVectors(v1, v2) {
			const dot = v1.x * v2.x + v1.y * v2.y;
			const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
			const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
			return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
		}

		function applyBetterConnection(originalPathIndex, betterAlternative) {
			try {
				const originalPath = vectorPaths[originalPathIndex];
				const { candidatePath, type, connection } = betterAlternative;
				
				let newPath;
				
				switch (type) {
					case 'A_C_B':

						const partA = originalPath.slice(0, connection.breakPoint + 1);
						const partB = originalPath.slice(connection.breakPoint + 1);
						newPath = [...partA, ...candidatePath, ...partB];
						break;
						
					case 'A_Cend_B':

						const partA2 = originalPath.slice(0, connection.breakPoint + 1);
						const partB2 = originalPath.slice(connection.breakPoint + 1);
						newPath = [...partA2, ...candidatePath.reverse(), ...partB2];
						break;
				}
				
				if (newPath && newPath.length > 2) {

					vectorPaths[originalPathIndex] = newPath;

					const candidateIndex = vectorPaths.indexOf(betterAlternative.candidatePath);
					if (candidateIndex !== -1 && candidateIndex !== originalPathIndex) {
						vectorPaths.splice(candidateIndex, 1);
					}
					
					return true;
				}
				
			} catch (error) {
				console.error('Ошибка при применении улучшения:', error);
			}
			
			return false;
		}
			
		function createBinaryImage(threshold, invert) {

			const imageToProcess = isSvgFile && originalImage ? originalImage : originalImage;
			
			if (!imageToProcess) {
				console.error('Нет изображения для создания бинарного');
				return [];
			}
			
			const width = imageToProcess.width;
			const height = imageToProcess.height;
			const binary = new Array(width * height);
			
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					const pixel = getPixel(imageData, x, y);
					const brightness = (pixel[0] + pixel[1] + pixel[2]) / 3;
					const alpha = pixel[3];
					
					if (alpha === 0) {
						binary[y * width + x] = 0;
					} else {
						const value = invert ? brightness > threshold : brightness < threshold;
						binary[y * width + x] = value ? 1 : 0;
					}
				}
			}
			return binary;
		}
		
		// Алгоритм Чжана-Суэна для скелетизации
		function zhangSuenSkeletonization(binary) {
			const width = originalImage.width;
			const height = originalImage.height;
			let changed = true;
			const skeleton = [...binary];
			
			let iteration = 0;
			const maxIterations = 100;
			
			while (changed && iteration < maxIterations) {
				changed = false;
				iteration++;
				
				// Шаг 1
				const toRemove = [];
				for (let y = 1; y < height - 1; y++) {
					for (let x = 1; x < width - 1; x++) {
						if (skeleton[y * width + x] === 1) {
							const neighbors = getNeighbors(skeleton, x, y, width);
							if (shouldRemoveStep1(neighbors)) {
								toRemove.push({x, y});
							}
						}
					}
				}
				
				toRemove.forEach(p => {
					skeleton[p.y * width + p.x] = 0;
					changed = true;
				});
				
				// Шаг 2
				const toRemove2 = [];
				for (let y = 1; y < height - 1; y++) {
					for (let x = 1; x < width - 1; x++) {
						if (skeleton[y * width + x] === 1) {
							const neighbors = getNeighbors(skeleton, x, y, width);
							if (shouldRemoveStep2(neighbors)) {
								toRemove2.push({x, y});
							}
						}
					}
				}
				
				toRemove2.forEach(p => {
					skeleton[p.y * width + p.x] = 0;
					changed = true;
				});
			}
			
			return skeleton;
		}

        // Получение соседей по 8-связности
        function getNeighbors(data, x, y, width) {
            return [
                data[(y-1)*width + x],     // P2
                data[(y-1)*width + (x+1)], // P3
                data[y*width + (x+1)],     // P4
                data[(y+1)*width + (x+1)], // P5
                data[(y+1)*width + x],     // P6
                data[(y+1)*width + (x-1)], // P7
                data[y*width + (x-1)],     // P8
                data[(y-1)*width + (x-1)]  // P9
            ];
        }

        // Условия для удаления (шаг 1)
        function shouldRemoveStep1(neighbors) {
            const [p2, p3, p4, p5, p6, p7, p8, p9] = neighbors;
            
            const blackNeighbors = neighbors.filter(p => p === 1).length;
            
            let transitions = 0;
            for (let i = 0; i < 8; i++) {
                if (neighbors[i] === 0 && neighbors[(i+1)%8] === 1) {
                    transitions++;
                }
            }
            
            return (blackNeighbors >= 2 && blackNeighbors <= 6) &&
                   (transitions === 1) &&
                   (p2 * p4 * p6 === 0) &&
                   (p4 * p6 * p8 === 0);
        }

        // Условия для удаление (шаг 2)
        function shouldRemoveStep2(neighbors) {
            const [p2, p3, p4, p5, p6, p7, p8, p9] = neighbors;
            
            const blackNeighbors = neighbors.filter(p => p === 1).length;

            let transitions = 0;
            for (let i = 0; i < 8; i++) {
                if (neighbors[i] === 0 && neighbors[(i+1)%8] === 1) {
                    transitions++;
                }
            }
            
            return (blackNeighbors >= 2 && blackNeighbors <= 6) &&
                   (transitions === 1) &&
                   (p2 * p4 * p8 === 0) &&
                   (p2 * p6 * p8 === 0);
        }
	
		//трассировка
function extractPathsFromSkeleton(skeleton) {
    const width = originalImage.width;
    const height = originalImage.height;
    const visited = new Array(width * height).fill(false);
    const allPaths = [];

    // МЕНЕЕ агрессивное прореживание - сохраняем ВСЕ точки скелетона
    const thinSkeleton = [...skeleton];

    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            if (thinSkeleton[y * width + x] && !visited[y * width + x]) {
                const line = traceContinuousLine(thinSkeleton, visited, x, y, width, height);
                if (line && line.length > 3) {
                    allPaths.push(line);
                    // ПОМЕЧАЕМ ОБЛАСТЬ ВОКРУГ ЛИНИИ
                    markAreaAroundLine(line, visited, thinSkeleton, width, height);
                }
            }
        }
    }

    return allPaths;
}

// НОВАЯ ФУНКЦИЯ - пометка области вокруг линии
function markAreaAroundLine(line, visited, skeleton, width, height) {
    for (const point of line) {
        markPerpendicularArea(point, visited, skeleton, width, height);
    }
}

// НОВАЯ ФУНКЦИЯ - пометка перпендикулярной области
function markPerpendicularArea(center, visited, skeleton, width, height) {
    const directions = [
        {dx: -1, dy: 0}, {dx: 1, dy: 0}, {dx: 0, dy: -1}, {dx: 0, dy: 1},
        {dx: -1, dy: -1}, {dx: 1, dy: -1}, {dx: -1, dy: 1}, {dx: 1, dy: 1}
    ];
    
    visited[center.y * width + center.x] = true;
    
    for (const dir of directions) {
        let current = {x: center.x, y: center.y};
        let steps = 0;
        const maxSteps = 3; // уменьшил радиус
        
        while (steps < maxSteps) {
            current = {x: current.x + dir.dx, y: current.y + dir.dy};
            
            if (current.x < 0 || current.x >= width || current.y < 0 || current.y >= height) {
                break;
            }
            
            if (!skeleton[current.y * width + current.x]) {
                break;
            }
            
            visited[current.y * width + current.x] = true;
            steps++;
        }
    }
}

// ОСТАВЛЯЕМ ВСЕ ОСТАЛЬНЫЕ ФУНКЦИИ БЕЗ ИЗМЕНЕНИЙ
function traceContinuousLine(skeleton, visited, startX, startY, width, height) {
    const line = [];
    
    // Находим начальную точку (конец линии)
    const startPoint = findBestStartPoint(skeleton, visited, startX, startY, width, height);
    if (!startPoint) return null;
    
    let current = startPoint;
    line.push(current);
    visited[current.y * width + current.x] = true;
    
    let previousPoints = [current];
    
    while (true) {
        const next = findBestNextPoint(skeleton, visited, current, previousPoints, width, height);
        if (!next) break;
        
        line.push(next);
        visited[next.y * width + next.x] = true;
        
        // Сохраняем историю для определения направления
        previousPoints.push(next);
        if (previousPoints.length > 3) {
            previousPoints.shift();
        }
        
        current = next;
        
        // Более либеральное ограничение длины
        if (line.length > width * height / 5) break;
    }
    
    return line.length > 3 ? line : null;
}

function findBestStartPoint(skeleton, visited, x, y, width, height) {
    // Проверяем стартовую точку
    if (skeleton[y * width + x] && !visited[y * width + x]) {
        return {x, y};
    }
    
    // Если стартовая уже посещена, ищем ближайшую непосещенную
    for (let radius = 1; radius < 5; radius++) {
        for (let dy = -radius; dy <= radius; dy++) {
            for (let dx = -radius; dx <= radius; dx++) {
                const nx = x + dx, ny = y + dy;
                if (nx >= 0 && nx < width && ny >= 0 && ny < height &&
                    skeleton[ny * width + nx] && !visited[ny * width + nx]) {
                    return {x: nx, y: ny};
                }
            }
        }
    }
    
    return null;
}

function findBestNextPoint(skeleton, visited, current, previousPoints, width, height) {
    const candidates = [];
    
    // Определяем текущее направление движения
    let currentDirection = {dx: 0, dy: 0};
    if (previousPoints.length >= 2) {
        const lastPoint = previousPoints[previousPoints.length - 2];
        currentDirection = {
            dx: current.x - lastPoint.x,
            dy: current.y - lastPoint.y
        };
        
        // Нормализуем направление
        const length = Math.sqrt(currentDirection.dx * currentDirection.dx + currentDirection.dy * currentDirection.dy);
        if (length > 0) {
            currentDirection.dx /= length;
            currentDirection.dy /= length;
        }
    }
    
    // Проверяем соседей в радиусе 2
    for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
            if (dx === 0 && dy === 0) continue;
            
            const nx = current.x + dx, ny = current.y + dy;
            if (nx >= 0 && nx < width && ny >= 0 && ny < height &&
                skeleton[ny * width + nx] && !visited[ny * width + nx]) {
                
                const distance = Math.sqrt(dx * dx + dy * dy);
                let score = 12 - distance; // Ближе = лучше
                
                // ОЦЕНКА НАПРАВЛЕНИЯ - КЛЮЧЕВОЕ ИЗМЕНЕНИЕ
                if (previousPoints.length >= 2) {
                    const newDirection = {dx: dx, dy: dy};
                    const newLength = Math.sqrt(newDirection.dx * newDirection.dx + newDirection.dy * newDirection.dy);
                    if (newLength > 0) {
                        newDirection.dx /= newLength;
                        newDirection.dy /= newLength;
                    }
                    
                    // Скалярное произведение для определения схожести направлений
                    const dotProduct = currentDirection.dx * newDirection.dx + currentDirection.dy * newDirection.dy;
                    
                    if (dotProduct > 0.8) {
                        // Отличное продолжение направления - большой бонус
                        score += 10;
                    } else if (dotProduct > 0.3) {
                        // Хорошее продолжение
                        score += 5;
                    } else if (dotProduct > -0.3) {
                        // Нейтральное направление
                        score += 1;
                    } else {
                        // Разворот или резкий поворот - ШТРАФ
                        score -= 8;
                    }
                }
                
                // Бонус за прямых соседей (4-связность)
                if ((dx === 0 && Math.abs(dy) === 1) || (dy === 0 && Math.abs(dx) === 1)) {
                    score += 2;
                }
                
                candidates.push({
                    point: {x: nx, y: ny},
                    score: score,
                    distance: distance
                });
            }
        }
    }
    
    if (candidates.length === 0) return null;
    
    // Сортируем по score и выбираем лучшего
    candidates.sort((a, b) => b.score - a.score);
    
    // ДОПОЛНИТЕЛЬНАЯ ПРОВЕРКА: не выбираем точки, которые ведут назад
    const bestCandidate = candidates[0];
    if (previousPoints.length >= 3) {
        const isBackward = isMovingBackward(bestCandidate.point, current, previousPoints);
        if (isBackward && candidates.length > 1) {
            // Если лучший кандидат ведет назад, берем следующего
            return candidates[1].point;
        }
    }
    
    return bestCandidate.point;
}

function isMovingBackward(newPoint, current, previousPoints) {
    if (previousPoints.length < 3) return false;
    
    // Берем 3 предыдущие точки для определения траектории
    const p1 = previousPoints[previousPoints.length - 3];
    const p2 = previousPoints[previousPoints.length - 2];
    const p3 = current;
    
    // Вычисляем вектор направления
    const trajectoryDir = {
        dx: p3.x - p1.x,
        dy: p3.y - p1.y
    };
    
    // Вычисляем вектор к новой точке
    const newDir = {
        dx: newPoint.x - p3.x,
        dy: newPoint.y - p3.y
    };
    
    // Скалярное произведение
    const dot = trajectoryDir.dx * newDir.dx + trajectoryDir.dy * newDir.dy;
    
    // Если скалярное произведение отрицательное - движемся назад
    return dot < 0;
}

function distance(p1, p2) {
    return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}


//fin трассировка

		// Вычисление кривизны в точке
		function calculateCurvature(prev, current, next) {
			const dx1 = current.x - prev.x;
			const dy1 = current.y - prev.y;
			const dx2 = next.x - current.x;
			const dy2 = next.y - current.y;
			
			const crossProduct = dx1 * dy2 - dy1 * dx2;
			const dotProduct = dx1 * dx2 + dy1 * dy2;
	
			if (dotProduct === 0) return Math.PI / 2;
			
			return Math.atan2(Math.abs(crossProduct), dotProduct);
		}

		// Расстояние от точки до линии
		function distanceToLine(point, lineStart, lineEnd) {
			const numerator = Math.abs(
				(lineEnd.y - lineStart.y) * point.x -
				(lineEnd.x - lineStart.x) * point.y +
				lineEnd.x * lineStart.y -
				lineEnd.y * lineStart.x
			);
			const denominator = Math.sqrt(
				Math.pow(lineEnd.y - lineStart.y, 2) + 
				Math.pow(lineEnd.x - lineStart.x, 2)
			);
			
			return numerator / denominator;
		}

		// Упрощение ломаной линии (алгоритм Дугласа-Пекера)
		function simplifyPolyline(points, epsilon = 1.0) {
			if (points.length <= 2) return points;
			
			let maxDistance = 0;
			let maxIndex = 0;
			const first = points[0];
			const last = points[points.length - 1];
			
			for (let i = 1; i < points.length - 1; i++) {
				const distance = distanceToLine(points[i], first, last);
				if (distance > maxDistance) {
					maxDistance = distance;
					maxIndex = i;
				}
			}

			if (maxDistance > epsilon) {
				const left = simplifyPolyline(points.slice(0, maxIndex + 1), epsilon);
				const right = simplifyPolyline(points.slice(maxIndex), epsilon);
				return left.slice(0, -1).concat(right);
			} else {
				return [first, last];
			}
		}


		// Алгоритм Рамера-Дугласа-Пекера для упрощения путей
		function douglasPeucker(points, epsilon) {
			if (points.length <= 2) return points;

			let maxDistance = 0;
			let maxIndex = 0;
			const first = points[0];
			const last = points[points.length - 1];
			
			for (let i = 1; i < points.length - 1; i++) {
				const distance = perpendicularDistance(points[i], first, last);
				if (distance > maxDistance) {
					maxDistance = distance;
					maxIndex = i;
				}
			}
			
			if (maxDistance > epsilon) {
				const left = douglasPeucker(points.slice(0, maxIndex + 1), epsilon);
				const right = douglasPeucker(points.slice(maxIndex), epsilon);
				return left.slice(0, -1).concat(right);
			} else {
				return [first, last];
			}
		}

		// Расстояние от точки до линии
		function perpendicularDistance(point, lineStart, lineEnd) {
			const numerator = Math.abs(
				(lineEnd.y - lineStart.y) * point.x -
				(lineEnd.x - lineStart.x) * point.y +
				lineEnd.x * lineStart.y -
				lineEnd.y * lineStart.x
			);
			const denominator = Math.sqrt(
				Math.pow(lineEnd.y - lineStart.y, 2) + 
				Math.pow(lineEnd.x - lineStart.x, 2)
			);
			return numerator / denominator;
		}

		function optimizeStraightLines(paths, collinearityTolerance = 2) {
			return paths.map(path => {
				if (path.length <= 2) return path;
				
				const optimized = [path[0]];
				let i = 1;
				
				while (i < path.length - 1) {
					const prev = optimized[optimized.length - 1];
					const current = path[i];
					const next = path[i + 1];
					
					if (arePointsCollinear(prev, current, next, collinearityTolerance)) {

						i++;
					} else {
						optimized.push(current);
						i++;
					}
				}
				
				optimized.push(path[path.length - 1]);
				
				return optimized;
			});
		}

		// Проверка коллинеарности трех точек
		function arePointsCollinear(p1, p2, p3, tolerance) {

			const area = Math.abs(
				(p2.x - p1.x) * (p3.y - p1.y) - (p3.x - p1.x) * (p2.y - p1.y)
			) / 2;
			
			return area <= tolerance;
		}

		// Заливка - второй метод 
		// Находит пересечения сетки внутри области
		function findGridIntersections(area, stepPixels, width, height) {
			const { bbox, points } = area;
			const { minX, minY, maxX, maxY } = bbox;
			const intersections = [];
			const areaSet = new Set(points.map(p => `${p.x},${p.y}`));

			for (let x = minX; x <= maxX; x += stepPixels) {
				for (let y = minY; y <= maxY; y += stepPixels) {
					if (areaSet.has(`${x},${y}`)) {
						intersections.push({x, y});
					}
				}
			}
			
			return intersections;
		}

		// Нормализация вектора
		function normalizeVector(v) {
			const length = Math.sqrt(v.x * v.x + v.y * v.y);
			if (length === 0) return { x: 0, y: 0 };
			return { x: v.x / length, y: v.y / length };
		}

		// Создание промежуточных точек для заполнения разрыва
		function createIntermediatePoints(from, to, numPoints) {
			const points = [];
			
			for (let i = 1; i <= numPoints; i++) {
				const t = i / (numPoints + 1);
				points.push({
					x: Math.round(from.x + (to.x - from.x) * t),
					y: Math.round(from.y + (to.y - from.y) * t)
				});
			}
			
			return points;
		}

		// соединяем точки
		function connectWithNearestNeighbor(points, hatchStepPixels) {
			if (points.length === 0) return [];
			
			const MAX_STEP_PX = Math.round(hatchStepPixels * 1.5);
			const MAX_JUMP_PX = Math.round(hatchStepPixels * 2.5);
			
			const allSnakes = [];
			const used = new Set();
			
			
			while (used.size < points.length) {
				let snake = [];
				
				let current = findStartCorner(points, used);
				if (!current) {

					for (const point of points) {
						const key = `${point.x},${point.y}`;
						if (!used.has(key)) {
							current = point;
							break;
						}
					}
				}
				
				if (!current) break;
				
				snake.push(current);
				used.add(`${current.x},${current.y}`);

				
				let canContinue = true;
				
				while (canContinue && used.size < points.length) {
					let nearest = null;
					let minDist = Infinity;

					for (const point of points) {
						const key = `${point.x},${point.y}`;
						if (used.has(key)) continue;
						
						const dist = distanceBetweenPoints(current, point);
						if (dist <= MAX_STEP_PX && dist < minDist) {
							minDist = dist;
							nearest = point;
						}
					}
					
					if (nearest) {
						snake.push(nearest);
						used.add(`${nearest.x},${nearest.y}`);
						current = nearest;
					} else {

						let jumpPoint = null;
						let jumpDist = Infinity;
						
						for (const point of points) {
							const key = `${point.x},${point.y}`;
							if (used.has(key)) continue;
							
							const dist = distanceBetweenPoints(current, point);
							if (dist <= MAX_JUMP_PX && dist < jumpDist) {
								jumpDist = dist;
								jumpPoint = point;
							}
						}
						
						if (jumpPoint) {
							snake.push(jumpPoint);
							used.add(`${jumpPoint.x},${jumpPoint.y}`);
							current = jumpPoint;
						} else {
							canContinue = false;

						}
					}
				}
				
				if (snake.length > 1) {
					allSnakes.push(snake);

				}
			}
			
			return allSnakes;
		}

		// Находит стартовую точку в углу области
		function findStartCorner(points, used) {
			let cornerPoint = null;
			let minSum = Infinity;
			
			for (const point of points) {
				const key = `${point.x},${point.y}`;
				if (used.has(key)) continue;

				const sum = point.x + point.y;
				if (sum < minSum) {
					minSum = sum;
					cornerPoint = point;
				}
			}
			
			return cornerPoint;
		}

		// Заливает область и возвращает её bounding box и точки
		function floodFillArea(binary, visited, startX, startY, width, height) {
			const points = [];
			const stack = [{x: startX, y: startY}];
			let minX = startX, minY = startY, maxX = startX, maxY = startY;
			
			while (stack.length > 0) {
				const {x, y} = stack.pop();
				const index = y * width + x;
				
				if (x < 0 || x >= width || y < 0 || y >= height || visited[index] || binary[index] === 0) {
					continue;
				}
				
				visited[index] = true;
				points.push({x, y});
				
				minX = Math.min(minX, x);
				minY = Math.min(minY, y);
				maxX = Math.max(maxX, x);
				maxY = Math.max(maxY, y);
				
				stack.push({x: x+1, y});
				stack.push({x: x-1, y});
				stack.push({x, y: y+1});
				stack.push({x, y: y-1});
			}
			
			return {
				points,
				bbox: {minX, minY, maxX, maxY},
				width: maxX - minX + 1,
				height: maxY - minY + 1
			};
		}

//---

		// Морфологическое расширение бинарного изображения
		function expandBinary(binary, radius) {
			const width = originalImage.width;
			const height = originalImage.height;
			const expanded = new Array(width * height).fill(0);
			
			for (let y = 0; y < height; y++) {
				for (let x = 0; x < width; x++) {
					if (binary[y * width + x] === 1) {
						for (let dy = -radius; dy <= radius; dy++) {
							for (let dx = -radius; dx <= radius; dx++) {
								const nx = x + dx;
								const ny = y + dy;
								if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
									expanded[ny * width + nx] = 1;
								}
							}
						}
					}
				}
			}
			
			return expanded;
		}
	
		// Оптимизация путей для непрерывного рисования следующая ШТРИШОВКА
		class ContextAwareConnector {
			connectPathsWithContext(paths, maxDistancePixels = 20) {
				this.maxDistancePixels = maxDistancePixels;
				const connectionScores = this.calculateConnectionScores(paths);
				return connectionScores.sort((a, b) => b.total - a.total);
			}
			
			calculateConnectionScores(paths) {
				const scores = [];
				for (let i = 0; i < paths.length; i++) {
					for (let j = i + 1; j < paths.length; j++) {
						const score = this.calculateSingleConnectionScore(paths[i], paths[j], i, j);
						if (score.total > 0.1) { 
							scores.push({ pathA: i, pathB: j, ...score });
						}
					}
				}
				return scores;
			}
			
			calculateSingleConnectionScore(pathA, pathB, indexA, indexB) {
				const endpointsA = [pathA[0], pathA[pathA.length - 1]];
				const endpointsB = [pathB[0], pathB[pathB.length - 1]];
				
				let bestScore = { total: 0 };
				
				for (let aIdx = 0; aIdx < 2; aIdx++) {
					for (let bIdx = 0; bIdx < 2; bIdx++) {
						const pointA = endpointsA[aIdx];
						const pointB = endpointsB[bIdx];
						
						const distance = Math.sqrt(
							Math.pow(pointB.x - pointA.x, 2) + 
							Math.pow(pointB.y - pointA.y, 2)
						);
						
						if (distance > this.maxDistancePixels) continue;
						
						const distanceScore = Math.max(0, 1 - distance / this.maxDistancePixels);
						const directionScore = this.calculateDirectionScore(pathA, pathB, aIdx === 1, bIdx === 0);
						
						const total = distanceScore * 0.7 + directionScore * 0.3;
						
						if (total > bestScore.total) {
							bestScore = {
								total,
								distance: distanceScore,
								direction: directionScore,
								actualDistance: distance,
								connectionType: {
									endA: aIdx === 1,
									endB: bIdx === 0,
									reverseB: bIdx === 1
								}
							};
						}
					}
				}
				return bestScore;
			}
			
			calculateDirectionScore(pathA, pathB, connectAEnd, connectBStart) {
				const dirA = this.getPathDirection(pathA, connectAEnd);
				const dirB = this.getPathDirection(pathB, !connectBStart);
				
				const dotProduct = dirA.x * dirB.x + dirA.y * dirB.y;
				if (dotProduct < -0.5) return 0;
				return (dotProduct + 1) / 2;
			}
			
			getPathDirection(path, fromEnd) {
				if (path.length < 2) return { x: 0, y: 0 };
				
				if (fromEnd) {
					const p1 = path[path.length - 2];
					const p2 = path[path.length - 1];
					return { x: p2.x - p1.x, y: p2.y - p1.y };
				} else {
					const p1 = path[0];
					const p2 = path[1];
					return { x: p2.x - p1.x, y: p2.y - p1.y };
				}
			}
			
			executeContextualConnection(paths, connectionScores) {
				const connectedPaths = [...paths];
				const usedIndices = new Set();
				
				connectionScores.forEach(score => {
					if (usedIndices.has(score.pathA) || usedIndices.has(score.pathB)) return;
					
					// Используем адаптивный порог на основе maxDistancePixels
					const adaptiveThreshold = 0.6 - (this.maxDistancePixels / 100);
					
					if (score.total > Math.max(0.3, adaptiveThreshold)) {
						this.performConnection(connectedPaths, score, usedIndices);
					}
				});
				
				return connectedPaths.filter((path, index) => !usedIndices.has(index));
			}
			
			performConnection(paths, score, usedIndices) {
				try {
					const pathA = paths[score.pathA];
					const pathB = paths[score.pathB];
					const conn = score.connectionType;
					
					let newPath;
					if (conn.endA && !conn.endB && !conn.reverseB) {
						newPath = [...pathA, ...pathB];
					} else if (conn.endA && conn.endB && conn.reverseB) {
						newPath = [...pathA, ...pathB.reverse()];
					} else if (!conn.endA && !conn.endB && conn.reverseB) {
						newPath = [...pathA.reverse(), ...pathB];
					} else {
						newPath = [...pathA.reverse(), ...pathB.reverse()];
					}
					
					paths[score.pathA] = newPath;
					usedIndices.add(score.pathB);
					return true;
				} catch (error) {
					console.warn('Connection failed:', error);
					return false;
				}
			}
		}

		class MultiLayerConnector {
			executeMultiLayerConnection(paths, connectionScores, maxDistancePixels = 20) {
				const connectedPaths = [...paths];
				const usedIndices = new Set();
				
				// Настраиваем пороги на основе максимального расстояния
				const highThreshold = 0.8;
				const mediumThreshold = 0.6;
				const lowThreshold = 0.4;
				
				// Если расстояние маленькое - делаем более строгие пороги
				if (maxDistancePixels < 10) {
					highThreshold = 0.9;
					mediumThreshold = 0.7;
					lowThreshold = 0.5;
				}
				
				// Уровень 1: Высокоприоритетные соединения
				this.executeLayer(connectedPaths, connectionScores, usedIndices, highThreshold, 1);
				// Уровень 2: Средние соединения
				this.executeLayer(connectedPaths, connectionScores, usedIndices, mediumThreshold, 2);
				// Уровень 3: Низкоприоритетные соединения
				this.executeLayer(connectedPaths, connectionScores, usedIndices, lowThreshold, 3);
				
				return {
					paths: connectedPaths.filter((path, index) => !usedIndices.has(index)),
					statistics: { 
						totalConnections: usedIndices.size,
						maxDistancePixels: maxDistancePixels
					}
				};
			}
			
			executeLayer(paths, scores, usedIndices, threshold, layer) {
				scores.forEach(score => {
					if (usedIndices.has(score.pathA) || usedIndices.has(score.pathB)) return;
					if (score.total > threshold) {
						this.performConnection(paths, score, usedIndices);
					}
				});
			}
			
			performConnection(paths, score, usedIndices) {
				try {
					const pathA = paths[score.pathA];
					const pathB = paths[score.pathB];
					const conn = score.connectionType;
					
					let newPath;
					if (conn.endA && !conn.endB && !conn.reverseB) {
						newPath = [...pathA, ...pathB];
					} else if (conn.endA && conn.endB && conn.reverseB) {
						newPath = [...pathA, ...pathB.reverse()];
					} else if (!conn.endA && !conn.endB && conn.reverseB) {
						newPath = [...pathA.reverse(), ...pathB];
					} else {
						newPath = [...pathA.reverse(), ...pathB.reverse()];
					}
					
					paths[score.pathA] = newPath;
					usedIndices.add(score.pathB);
					return true;
				} catch (error) {
					return false;
				}
			}
		}

		class ContextAnalyzer {
			calculateCentroid(points) {
				if (points.length === 0) return { x: 0, y: 0 };
				
				const sum = points.reduce((acc, point) => {
					acc.x += point.x;
					acc.y += point.y;
					return acc;
				}, { x: 0, y: 0 });
				
				return {
					x: sum.x / points.length,
					y: sum.y / points.length
				};
			}
			
			calculateOverallCentroid(allPaths) {
				const allPoints = allPaths.flat();
				return this.calculateCentroid(allPoints);
			}
			
			distance(pointA, pointB) {
				return Math.sqrt(
					Math.pow(pointB.x - pointA.x, 2) + 
					Math.pow(pointB.y - pointA.y, 2)
				);
			}
			
			analyzeVisualConnectivity(pathA, pathB, allPaths) {
				const connectionsBefore = this.countNearbyConnections(pathA, pathB, allPaths, false);
				const connectionsAfter = this.countNearbyConnections(pathA, pathB, allPaths, true);
				
				return Math.min(1, connectionsAfter / (connectionsBefore + 1));
			}
			
			analyzeRhythmConsistency(pathA, pathB, allPaths) {

				const avgLength = this.calculateAveragePathLength(allPaths);
				const combinedLength = this.calculatePathLength([...pathA, ...pathB]);
				
				const lengthDiff = Math.abs(combinedLength - avgLength);
				return Math.max(0, 1 - lengthDiff / avgLength);
			}
			
			countNearbyConnections(pathA, pathB, allPaths, assumeConnected = false) {
				// Подсчет соединений в окрестности
				let count = 0;
				const searchRadius = 20;
				
				allPaths.forEach(path => {
					if (path === pathA || path === pathB) return;
					
					if (this.arePathsNearby(pathA, path, searchRadius) ||
						this.arePathsNearby(pathB, path, searchRadius)) {
						count++;
					}
				});
				
				return count;
			}
			
			arePathsNearby(path1, path2, radius) {

				for (let p1 of path1) {
					for (let p2 of path2) {
						if (this.distance(p1, p2) <= radius) {
							return true;
						}
					}
				}
				return false;
			}
			
			calculateAveragePathLength(paths) {
				if (paths.length === 0) return 0;
				const totalLength = paths.reduce((sum, path) => sum + this.calculatePathLength(path), 0);
				return totalLength / paths.length;
			}
			
			calculatePathLength(path) {
				if (path.length < 2) return 0;
				let length = 0;
				for (let i = 1; i < path.length; i++) {
					length += this.distance(path[i-1], path[i]);
				}
				return length;
			}
		}

		class AestheticScorer {
			getEndDirection(path, fromEnd) {
				if (path.length < 2) return { x: 0, y: 0 };
				
				if (fromEnd) {
					const p1 = path[path.length - 2];
					const p2 = path[path.length - 1];
					return this.normalizeVector({ x: p2.x - p1.x, y: p2.y - p1.y });
				} else {

					const p1 = path[0];
					const p2 = path[1];
					return this.normalizeVector({ x: p2.x - p1.x, y: p2.y - p1.y });
				}
			}
			
			angleBetween(v1, v2) {
				const dot = v1.x * v2.x + v1.y * v2.y;
				const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
				const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
				
				if (mag1 === 0 || mag2 === 0) return 90;
				
				const cosAngle = Math.max(-1, Math.min(1, dot / (mag1 * mag2)));
				return Math.acos(cosAngle) * 180 / Math.PI;
			}
			
			normalizeVector(v) {
				const length = Math.sqrt(v.x * v.x + v.y * v.y);
				if (length === 0) return { x: 0, y: 0 };
				return { x: v.x / length, y: v.y / length };
			}
			
			assessVisualHarmony(pathA, pathB) {
				const curvatureA = this.calculateCurvature(pathA);
				const curvatureB = this.calculateCurvature(pathB);

				const curvatureMatch = 1 - Math.abs(curvatureA - curvatureB);
				
				const complexityA = this.calculateComplexity(pathA);
				const complexityB = this.calculateComplexity(pathB);
				const complexityMatch = 1 - Math.abs(complexityA - complexityB);
				
				return (curvatureMatch + complexityMatch) / 2;
			}
			
			assessNaturalForm(pathA, pathB, connectionType) {

				const combinedPath = this.simulateConnection(pathA, pathB, connectionType);
				const combinedCurvature = this.calculateCurvature(combinedPath);
				
				return Math.max(0, 1 - Math.abs(combinedCurvature - 0.5));
			}
			
			calculateCurvature(path) {
				if (path.length < 3) return 0;
				
				let totalAngle = 0;
				for (let i = 1; i < path.length - 1; i++) {
					const angle = this.calculateAngle(path[i-1], path[i], path[i+1]);
					totalAngle += Math.abs(angle);
				}
				
				return totalAngle / (path.length - 2);
			}
			
			calculateAngle(p1, p2, p3) {
				const v1 = { x: p1.x - p2.x, y: p1.y - p2.y };
				const v2 = { x: p3.x - p2.x, y: p3.y - p2.y };
				
				const dot = v1.x * v2.x + v1.y * v2.y;
				const mag1 = Math.sqrt(v1.x * v1.x + v1.y * v1.y);
				const mag2 = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
				
				if (mag1 === 0 || mag2 === 0) return 0;
				
				return Math.acos(dot / (mag1 * mag2)) * 180 / Math.PI;
			}
			
			calculateComplexity(path) {

				if (path.length < 3) return 0;
				
				let directionChanges = 0;
				let lastDirection = null;
				
				for (let i = 1; i < path.length; i++) {
					const direction = this.normalizeVector({
						x: path[i].x - path[i-1].x,
						y: path[i].y - path[i-1].y
					});
					
					if (lastDirection) {
						const dot = direction.x * lastDirection.x + direction.y * lastDirection.y;
						if (dot < 0.7) { 
							directionChanges++;
						}
					}
					
					lastDirection = direction;
				}
				
				return directionChanges / (path.length - 1);
			}
			
			simulateConnection(pathA, pathB, connectionType) {

				let connectedPath;
				
				if (connectionType.endA && !connectionType.endB && !connectionType.reverseB) {
					connectedPath = [...pathA, ...pathB];
				} else if (connectionType.endA && connectionType.endB && connectionType.reverseB) {
					connectedPath = [...pathA, ...pathB.reverse()];
				} else if (!connectionType.endA && !connectionType.endB && connectionType.reverseB) {
					connectedPath = [...pathA.reverse(), ...pathB];
				} else {
					connectedPath = [...pathA.reverse(), ...pathB.reverse()];
				}
				
				return connectedPath;
			}
		}

		
function optimizePaths() {
    const connectDistanceMM = parseFloat(connectDistanceInput.value);
    const minLineLengthMM = parseFloat(minLineLengthInput.value);
    window.removedPathsForDisplay = [];
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sourceWidth = isSvgFile ? svgPaths.width : originalImage.width;
    const sourceHeight = isSvgFile ? svgPaths.height : originalImage.height;
    const scaleX = areaWidth / sourceWidth;
    const scaleY = areaHeight / sourceHeight;
    const pixelToMM = Math.min(scaleX, scaleY);
    const connectDistancePixels = connectDistanceMM / pixelToMM;
    const minLineLengthPixels = minLineLengthMM / pixelToMM; 
    const validPaths = vectorPaths.filter(path => path.length >= 2);
    
    if (validPaths.length === 0) {
        optimizedPaths = [];
        filteredPaths = [];
        return;
    }
    
    // 1. ПЕРВОЕ соединение - очень близкие концы (микро-соединение)
    const tempConnectDistance = Math.min(connectDistancePixels, 10); 
    let connectedPaths = connectPathsGreedy(validPaths, tempConnectDistance);
    
    // 3. ОСНОВНОЕ соединение путей 
    optimizedPaths = connectPathsGreedy(connectedPaths, connectDistancePixels);
    
    // 4. ОБРЕЗКА ПУТЕЙ ПО ГРАНИЦАМ ЛИСТА (НОВАЯ ФУНКЦИЯ)
    optimizedPaths = clipPathsToSheetBounds(optimizedPaths);
    // 5. Финальная фильтрация по длине 
    filterPathsByLength();
    
    updatePathInfo();
    redrawVectorCanvas();
}

function clipPathsToSheetBounds(paths) {
    const clippedPaths = [];
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    // Функция для проверки, находится ли точка в пределах листа
    function isPointInSheet(x, y) {
        return x >= 0 && x <= sheetWidth && y >= 0 && y <= sheetHeight;
    }
    
    function findIntersection(p1, p2, bounds) {
        const { minX, minY, maxX, maxY } = bounds;
        const points = [];
        
        // Проверяем все 4 границы
        const edges = [
            { p1: { x: minX, y: minY }, p2: { x: maxX, y: minY } }, // верхняя
            { p1: { x: maxX, y: minY }, p2: { x: maxX, y: maxY } }, // правая
            { p1: { x: minX, y: maxY }, p2: { x: maxX, y: maxY } }, // нижняя
            { p1: { x: minX, y: minY }, p2: { x: minX, y: maxY } }  // левая
        ];
        
        for (const edge of edges) {
            const intersection = lineIntersection(p1, p2, edge.p1, edge.p2);
            if (intersection && 
                isPointOnSegment(intersection, edge.p1, edge.p2) &&
                isPointOnSegment(intersection, p1, p2)) {
                points.push(intersection);
            }
        }
        
        return points.length > 0 ? points[0] : null;
    }
    
    // Функция для нахождения пересечения двух отрезков
    function lineIntersection(p1, p2, p3, p4) {
        const denominator = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
        
        if (denominator === 0) return null; // Параллельные линии
        
        const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denominator;
        const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denominator;
        
        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
            return {
                x: p1.x + ua * (p2.x - p1.x),
                y: p1.y + ua * (p2.y - p1.y)
            };
        }
        
        return null;
    }
   
    function isPointOnSegment(p, segStart, segEnd) {
        const dx = segEnd.x - segStart.x;
        const dy = segEnd.y - segStart.y;
        const dx2 = p.x - segStart.x;
        const dy2 = p.y - segStart.y;
        
        // Проверка коллинеарности
        if (Math.abs(dx * dy2 - dy * dx2) > 0.001) return false;
        
        // Проверка, что точка между концами отрезка
        if (dx !== 0) {
            if (dx > 0) {
                return p.x >= segStart.x && p.x <= segEnd.x;
            } else {
                return p.x <= segStart.x && p.x >= segEnd.x;
            }
        } else {
            if (dy > 0) {
                return p.y >= segStart.y && p.y <= segEnd.y;
            } else {
                return p.y <= segStart.y && p.y >= segEnd.y;
            }
        }
    }
    
    // Функция для трансформации точки в координаты листа
    function transformPointToSheet(point) {
        const width = isSvgFile ? svgPaths.width : originalImage.width;
        const height = isSvgFile ? svgPaths.height : originalImage.height;
        const areaWidth = parseInt(areaWidthInput.value);
        const areaHeight = parseInt(areaHeightInput.value);
        
        const scaleX = areaWidth / width;
        const scaleY = areaHeight / height;
        const scale = Math.min(scaleX, scaleY);
        
        let pointX = point.x * scale;
        let pointY = (height - point.y) * scale;
        
        const centerX = areaWidth / 2;
        const centerY = areaHeight / 2;
        
        const relX = pointX - centerX;
        const relY = pointY - centerY;
        
        const rad = -rotation * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        
        const rotatedX = relX * cos - relY * sin;
        const rotatedY = relX * sin + relY * cos;
        
        const finalX = offsetX + centerX + rotatedX;
        const finalY = offsetY + centerY + rotatedY;
        
        return { x: finalX, y: finalY };
    }
    
    // Функция для интерполяции точки на отрезке
    function interpolatePoint(p1, p2, ratio) {
        return {
            x: p1.x + (p2.x - p1.x) * ratio,
            y: p1.y + (p2.y - p1.y) * ratio
        };
    }
    
    // Основной алгоритм обрезки 
    for (const path of paths) {
        if (path.length < 2) continue;
        
        const clippedPath = [];
        let prevTransformed = transformPointToSheet(path[0]);
        let prevInside = isPointInSheet(prevTransformed.x, prevTransformed.y);
        
        // Добавляем первую точку, если она внутри
        if (prevInside) {
            clippedPath.push(path[0]);
        }
        
        for (let i = 1; i < path.length; i++) {
            const currentTransformed = transformPointToSheet(path[i]);
            const currentInside = isPointInSheet(currentTransformed.x, currentTransformed.y);
            
            if (prevInside && currentInside) {
                // Обе точки внутри - добавляем текущую точку
                clippedPath.push(path[i]);
            } 
            else if (prevInside && !currentInside) {
                // Выход за границу - находим точку пересечения
                const intersection = findIntersection(prevTransformed, currentTransformed, {
                    minX: 0, minY: 0, maxX: sheetWidth, maxY: sheetHeight
                });
                
                if (intersection) {
                    // Вычисляем соотношение для интерполяции
                    const totalDist = distanceBetweenPoints(prevTransformed, currentTransformed);
                    const intersectDist = distanceBetweenPoints(prevTransformed, intersection);
                    const ratio = totalDist > 0 ? intersectDist / totalDist : 0;
                    
                    // Интерполируем точку в оригинальных координатах
                    const interpolatedPoint = interpolatePoint(path[i-1], path[i], ratio);
                    clippedPath.push(interpolatedPoint);
                }
            }
            else if (!prevInside && currentInside) {
                // Вход внутрь - находим точку пересечения
                const intersection = findIntersection(prevTransformed, currentTransformed, {
                    minX: 0, minY: 0, maxX: sheetWidth, maxY: sheetHeight
                });
                
                if (intersection) {
                    // Вычисляем соотношение для интерполяции
                    const totalDist = distanceBetweenPoints(prevTransformed, currentTransformed);
                    const intersectDist = distanceBetweenPoints(prevTransformed, intersection);
                    const ratio = totalDist > 0 ? intersectDist / totalDist : 0;
                    
                    // Интерполируем точку в оригинальных координатах
                    const interpolatedPoint = interpolatePoint(path[i-1], path[i], ratio);
                    
                    // Добавляем точку пересечения И текущую точку
                    clippedPath.push(interpolatedPoint);
                    clippedPath.push(path[i]);
                }
            }
            // Если обе точки снаружи - не добавляем ничего
            
            prevTransformed = currentTransformed;
            prevInside = currentInside;
        }
        
        // Добавляем путь только если в нем есть хотя бы 2 точки
        if (clippedPath.length >= 2) {
            // Упрощаем путь, удаляя слишком близкие точки
            const simplifiedPath = [clippedPath[0]];
            for (let i = 1; i < clippedPath.length; i++) {
                const dist = distanceBetweenPoints(
                    {x: simplifiedPath[simplifiedPath.length-1].x, y: simplifiedPath[simplifiedPath.length-1].y},
                    {x: clippedPath[i].x, y: clippedPath[i].y}
                );
                if (dist > 0.1) { // Минимальное расстояние между точками
                    simplifiedPath.push(clippedPath[i]);
                }
            }
            
            if (simplifiedPath.length >= 2) {
                clippedPaths.push(simplifiedPath);
            }
        }
    }

    return clippedPaths;
}


		function connectPathsGreedy(paths, maxDistance) {
			if (paths.length === 0) return [];
			
			const connected = [];
			const used = new Set();
			
			let currentIndex = findLongestPathIndex(paths);
			connected.push([...paths[currentIndex]]);
			used.add(currentIndex);
			
			let improvements = true;
			let iterations = 0;
			const maxIterations = paths.length * 2;
			
			while (used.size < paths.length && improvements && iterations < maxIterations) {
				iterations++;
				improvements = false;
				
				const currentGroup = connected[connected.length - 1];
				const groupStart = currentGroup[0];
				const groupEnd = currentGroup[currentGroup.length - 1];
				
				let bestIndex = -1;
				let bestDistance = Infinity;
				let connectTo = null;
				let shouldReverse = false;
				
				for (let i = 0; i < paths.length; i++) {
					if (used.has(i)) continue;
					
					const path = paths[i];
					if (path.length < 2) continue;
					
					const pathStart = path[0];
					const pathEnd = path[path.length - 1];
					
					const connections = [
						{ from: groupEnd, to: pathStart, connectTo: 'end', reverse: false, distance: distanceBetweenPoints(groupEnd, pathStart) },
						{ from: groupEnd, to: pathEnd, connectTo: 'end', reverse: true, distance: distanceBetweenPoints(groupEnd, pathEnd) },
						{ from: groupStart, to: pathStart, connectTo: 'start', reverse: true, distance: distanceBetweenPoints(groupStart, pathStart) },
						{ from: groupStart, to: pathEnd, connectTo: 'start', reverse: false, distance: distanceBetweenPoints(groupStart, pathEnd) }
					];
					
					for (const conn of connections) {
						if (conn.distance < bestDistance && conn.distance <= maxDistance) {
							bestDistance = conn.distance;
							bestIndex = i;
							connectTo = conn.connectTo;
							shouldReverse = conn.reverse;
						}
					}
				}
				
				if (bestIndex !== -1) {
					const pathToConnect = paths[bestIndex];
					let newSegment = shouldReverse ? [...pathToConnect].reverse() : [...pathToConnect];
					
					if (connectTo === 'start') {
						connected[connected.length - 1] = [...newSegment, ...currentGroup];
					} else {
						connected[connected.length - 1] = [...currentGroup, ...newSegment];
					}
					
					used.add(bestIndex);
					improvements = true;
				} else {
					const nextIndex = findLongestUnusedPathIndex(paths, used);
					if (nextIndex !== -1) {
						connected.push([...paths[nextIndex]]);
						used.add(nextIndex);
						improvements = true;
					}
				}
			}
			
			// Фаза 2: объединяем группы между собой
			let groupsMerged = true;
			let mergeIterations = 0;
			
			while (groupsMerged && connected.length > 1 && mergeIterations < 10) {
				mergeIterations++;
				groupsMerged = false;
				
				for (let i = 0; i < connected.length && !groupsMerged; i++) {
					for (let j = i + 1; j < connected.length && !groupsMerged; j++) {
						const groupA = connected[i];
						const groupB = connected[j];
						
						const aStart = groupA[0];
						const aEnd = groupA[groupA.length - 1];
						const bStart = groupB[0];
						const bEnd = groupB[groupB.length - 1];
						
						const connections = [
							{ from: aEnd, to: bStart, reverseB: false, newGroup: [...groupA, ...groupB] },
							{ from: aEnd, to: bEnd, reverseB: true, newGroup: [...groupA, ...groupB.reverse()] },
							{ from: aStart, to: bStart, reverseB: false, newGroup: [...groupB, ...groupA] },
							{ from: aStart, to: bEnd, reverseB: true, newGroup: [...groupB.reverse(), ...groupA] }
						];
						
						for (const conn of connections) {
							const distance = distanceBetweenPoints(conn.from, conn.to);
							if (distance <= maxDistance) {
								connected[i] = conn.newGroup;
								connected.splice(j, 1);
								groupsMerged = true;
								break;
							}
						}
					}
				}
			}
			
			for (let i = 0; i < paths.length; i++) {
				if (!used.has(i)) {
					connected.push([...paths[i]]);
				}
			}
			
			return connected;
		}

		// Вспомогательные функции
		function findLongestPathIndex(paths) {
			let maxLength = 0;
			let maxIndex = 0;
			
			for (let i = 0; i < paths.length; i++) {
				const length = calculatePathLength(paths[i]);
				if (length > maxLength) {
					maxLength = length;
					maxIndex = i;
				}
			}
			return maxIndex;
		}

		function findLongestUnusedPathIndex(paths, used) {
			let maxLength = 0;
			let maxIndex = -1;
			
			for (let i = 0; i < paths.length; i++) {
				if (!used.has(i)) {
					const length = calculatePathLength(paths[i]);
					if (length > maxLength) {
						maxLength = length;
						maxIndex = i;
					}
				}
			}
			return maxIndex;
		}

		// Фильтрация путей по минимальной длине
		function filterPathsByLength() {
			const minLineLengthMM = parseFloat(minLineLengthInput.value);
			

			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sourceWidth = isSvgFile ? svgPaths.width : originalImage.width;
			const sourceHeight = isSvgFile ? svgPaths.height : originalImage.height;
			
			const scaleX = areaWidth / sourceWidth;
			const scaleY = areaHeight / sourceHeight;
			const pixelToMM = Math.min(scaleX, scaleY);
			
			const minLineLengthPixels = minLineLengthMM / pixelToMM;
			
			filteredPaths = [];
			let removedCount = 0;
			const removedPaths = [];
			
			for (let i = 0; i < optimizedPaths.length; i++) {
				const path = optimizedPaths[i];
				if (path.length < 2) continue;
				
				const lengthPixels = calculatePathLength(path);
				const lengthMM = lengthPixels * pixelToMM;
				
				if (lengthMM >= minLineLengthMM) {
					filteredPaths.push(path);
				} else {
					removedCount++;
					removedPaths.push(path);
				}
			}
			
			window.removedPathsForDisplay = removedPaths;
			
			if (removedCount > 0) {
				updateStatus(`Удалено коротких путей: ${removedCount}`, 'success');
			}

			redrawVectorCanvas();
			updatePathInfo();
		}
				
		// Обновление информации о путях
		function updatePathInfo() {
			const totalPaths = vectorPaths.length;
			const optimizedCount = optimizedPaths.length;
			const filteredCount = filteredPaths.length;
			const removedCount = optimizedPaths.length - filteredPaths.length;
			
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sourceWidth = isSvgFile ? svgPaths.width : originalImage.width;
			const sourceHeight = isSvgFile ? svgPaths.height : originalImage.height;
			
			const scaleX = areaWidth / sourceWidth;
			const scaleY = areaHeight / sourceHeight;
			const currentPixelToMM = Math.min(scaleX, scaleY);
			
			const totalLengthPixels = optimizedPaths.reduce((sum, path) => sum + calculatePathLength(path), 0);
			const filteredLengthPixels = filteredPaths.reduce((sum, path) => sum + calculatePathLength(path), 0);
			
			const totalLengthMM = totalLengthPixels * currentPixelToMM;
			const filteredLengthMM = filteredLengthPixels * currentPixelToMM;
			
			let info = `Путей: ${totalPaths}`;
			if (optimizedCount > 0) {
				info += ` → Оптимизировано: ${optimizedCount}`;
			}
			if (filteredCount > 0) {
				info += ` → После фильтрации: ${filteredCount}`;
			}
			info += `, Длина: ${filteredLengthMM.toFixed(1)}мм`;
			
			if (removedCount > 0) {
				info += ` (удалено ${removedCount} путей)`;
			}
			
			info += ` | Масштаб: 1px = ${currentPixelToMM.toFixed(4)}мм`;
			
			pathInfo.textContent = info;
		}

		// Улучшенная трассировка контура - соединяет все точки непрерывной линией
		function traceContinuousContour(edgeMap, visited, startX, startY, width, height) {
			const contour = [];
			let x = startX;
			let y = startY;
			
			// Направления для поиска следующей точки (8-связность)
			const directions = [
				{dx: 1, dy: 0},   // вправо
				{dx: 1, dy: 1},   // вправо-вниз
				{dx: 0, dy: 1},   // вниз
				{dx: -1, dy: 1},  // влево-вниз
				{dx: -1, dy: 0},  // влево
				{dx: -1, dy: -1}, // влево-вверх
				{dx: 0, dy: -1},  // вверх
				{dx: 1, dy: -1}   // вправо-вверх
			];
			
			let currentDir = 0;
			let steps = 0;
			const maxSteps = width * height; // защита от бесконечного цикла
			
			do {
				contour.push({x, y});
				visited[y * width + x] = true;
				
				let foundNext = false;
				
				for (let i = 0; i < directions.length; i++) {
					const dirIndex = (currentDir + i) % directions.length;
					const dir = directions[dirIndex];
					const nextX = x + dir.dx;
					const nextY = y + dir.dy;
					
					if (nextX >= 0 && nextX < width && nextY >= 0 && nextY < height) {
						const nextIndex = nextY * width + nextX;
						
						if (edgeMap[nextIndex] === 1 && !visited[nextIndex]) {
							x = nextX;
							y = nextY;
							currentDir = dirIndex;
							foundNext = true;
							break;
						}
					}
				}
				
				if (!foundNext) {
					let closestPoint = null;
					let minDistance = Infinity;
					
					for (let dy = -5; dy <= 5; dy++) {
						for (let dx = -5; dx <= 5; dx++) {
							const searchX = x + dx;
							const searchY = y + dy;
							
							if (searchX >= 0 && searchX < width && searchY >= 0 && searchY < height) {
								const searchIndex = searchY * width + searchX;
								
								if (edgeMap[searchIndex] === 1 && !visited[searchIndex]) {
									const distance = Math.abs(dx) + Math.abs(dy); 
									if (distance < minDistance) {
										minDistance = distance;
										closestPoint = {x: searchX, y: searchY};
									}
								}
							}
						}
					}
					
					if (closestPoint) {

						const pointsBetween = interpolatePoints({x, y}, closestPoint);
						contour.push(...pointsBetween);
						
						x = closestPoint.x;
						y = closestPoint.y;
						foundNext = true;
					}
				}
				
				if (!foundNext) break;
				
				steps++;
				if (steps > maxSteps) {

					break;
				}
				
			} while (!(x === startX && y === startY)); 
			
			return contour.length > 3 ? contour : null;
		}

		// Интерполяция точек между двумя точками для плавного соединения
		function interpolatePoints(p1, p2) {
			const points = [];
			const dx = p2.x - p1.x;
			const dy = p2.y - p1.y;
			const steps = Math.max(Math.abs(dx), Math.abs(dy));
			
			if (steps <= 1) return [];
			
			for (let i = 1; i < steps; i++) {
				const t = i / steps;
				points.push({
					x: Math.round(p1.x + dx * t),
					y: Math.round(p1.y + dy * t)
				});
			}
			
			return points;
		}

        function distanceBetweenPoints(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }
		
		// Морфологическая эрозия - сжимает черные области
		function erodeBinary(binary, radius) {
			const width = originalImage.width;
			const height = originalImage.height;
			const eroded = new Array(width * height).fill(0);
			
			for (let y = radius; y < height - radius; y++) {
				for (let x = radius; x < width - radius; x++) {
					const index = y * width + x;
					if (binary[index] === 1) {

						let allBlack = true;
						for (let dy = -radius; dy <= radius; dy++) {
							for (let dx = -radius; dx <= radius; dx++) {
								const nIndex = (y + dy) * width + (x + dx);
								if (binary[nIndex] === 0) {
									allBlack = false;
									break;
								}
							}
							if (!allBlack) break;
						}
						if (allBlack) {
							eroded[index] = 1;
						}
					}
				}
			}
			return eroded;
		}

		// Функция для рисования перекрестия в точке старта
		function drawCrosshair(ctx, canvas, sheetWidth, sheetHeight) {
			const scaleX = canvas.width / sheetWidth;
			const scaleY = canvas.height / sheetHeight;
			
			const startX = parseInt(startXInput.value);
			const startY = parseInt(startYInput.value);
			
			const crossX = startX * scaleX;
			const crossY = canvas.height - (startY * scaleY);
			
			ctx.save();
			applyLineStyle(ctx, 'crosshair');

			ctx.beginPath();
			ctx.arc(crossX, crossY, 8, 0, Math.PI * 2);
			ctx.stroke();

			ctx.beginPath();
			ctx.moveTo(crossX - 15, crossY);
			ctx.lineTo(crossX - 8, crossY);
			ctx.moveTo(crossX + 8, crossY);
			ctx.lineTo(crossX + 15, crossY);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.moveTo(crossX, crossY - 15);
			ctx.lineTo(crossX, crossY - 8);
			ctx.moveTo(crossX, crossY + 8);
			ctx.lineTo(crossX, crossY + 15);
			ctx.stroke();
			
			ctx.beginPath();
			ctx.arc(crossX, crossY, 0.5, 0, Math.PI * 2);
			ctx.fillStyle = getLineSettings('crosshair').color;
			ctx.fill();
			
			ctx.restore();
		}

		function redrawImageWithCrosshair() {
			if (!originalImage && !isSvgFile) return;
			
			imageCtx.fillStyle = 'white';
			imageCtx.fillRect(0, 0, imagePreview.width, imagePreview.height);
			
			if (isSvgFile) {
				displaySvg();
			} else {
				displayImage(originalImage);
			}
			
			if (showCrosshair.checked) {
				const sheetWidth = parseInt(sheetWidthInput.value);
				const sheetHeight = parseInt(sheetHeightInput.value);
				drawCrosshair(imageCtx, imagePreview, sheetWidth, sheetHeight);
			}
		}

		// Полная перерисовка (векторы + прицел)
		function redrawVectorCanvas() {
			if (!originalImage && !isSvgFile) return;

			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);

			if (vectorSnapshot && vectorSnapshot.complete) {
				vectorCtx.drawImage(vectorSnapshot, 0, 0);
			} else {
				drawVectorPaths(vectorCtx, vectorPreview);
			}
			
			if (isErasing && erasePoints.length > 0) {
				drawErasePreview();
			}

			if (showCrosshair.checked) {
				const sheetWidth = parseInt(sheetWidthInput.value);
				const sheetHeight = parseInt(sheetHeightInput.value);
				drawCrosshair(vectorCtx, vectorPreview, sheetWidth, sheetHeight);
			}
		}

		// Функция для отрисовки только путей (без прицела)
		function drawVectorPaths(ctx, canvas) {
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			const scaleX = canvas.width / sheetWidth;
			const scaleY = canvas.height / sheetHeight;
			
			const areaCanvasX = offsetX * scaleX;
			const areaCanvasY = canvas.height - (offsetY * scaleY) - (areaHeight * scaleY);
			const areaCanvasWidth = areaWidth * scaleX;
			const areaCanvasHeight = areaHeight * scaleY;
			
			ctx.save();
			ctx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
			ctx.rotate(rotation * Math.PI / 180);
			
			const width = isSvgFile ? svgPaths.width : originalImage.width;
			const height = isSvgFile ? svgPaths.height : originalImage.height;
			
			const imageRatio = width / height;
			const areaRatio = areaWidth / areaHeight;
			
			let drawScaleX, drawScaleY;
			
			// ДОБАВЛЯЕМ ПРОВЕРКУ ГАЛОЧКИ ПРОПОРЦИЙ
			const lockProportions = document.getElementById('lockProportions').checked;
			
			if (lockProportions) {
				// СОХРАНЯЕМ ПРОПОРЦИИ
				if (areaRatio > imageRatio) {
					drawScaleY = areaCanvasHeight / height;
					drawScaleX = drawScaleY;
				} else {
					drawScaleX = areaCanvasWidth / width;
					drawScaleY = drawScaleX;
				}
			} else {
				// РАСТЯГИВАЕМ БЕЗ ПРОПОРЦИЙ
				drawScaleX = areaCanvasWidth / width;
				drawScaleY = areaCanvasHeight / height;
			}
			
			// 1. ИСХОДНЫЕ ПУТИ (желтые)
			applyLineStyle(ctx, 'original');
			for (const path of vectorPaths) {
				if (path.length < 2) continue;
				
				ctx.beginPath();
				ctx.moveTo(
					(path[0].x - width / 2) * drawScaleX, 
					(path[0].y - height / 2) * drawScaleY
				);
				
				for (let i = 1; i < path.length; i++) {
					ctx.lineTo(
						(path[i].x - width / 2) * drawScaleX, 
						(path[i].y - height / 2) * drawScaleY
					);
				}
				ctx.stroke();
			}

			// 2. ФИНАЛЬНЫЕ ПУТИ (черные)
			applyLineStyle(ctx, 'optimized');
			for (const path of filteredPaths) {
				if (path.length < 2) continue;
				
				ctx.beginPath();
				ctx.moveTo(
					(path[0].x - width / 2) * drawScaleX, 
					(path[0].y - height / 2) * drawScaleY
				);
				
				for (let j = 1; j < path.length; j++) {
					ctx.lineTo(
						(path[j].x - width / 2) * drawScaleX, 
						(path[j].y - height / 2) * drawScaleY
					);
				}
				ctx.stroke();
			}

			// 3. УДАЛЕННЫЕ ПУТИ (красные)
			if (showRemovedPaths && window.removedPathsForDisplay && window.removedPathsForDisplay.length > 0) {
				applyLineStyle(ctx, 'filtered');
				for (const path of window.removedPathsForDisplay) {
					if (path.length < 2) continue;
					
					ctx.beginPath();
					ctx.moveTo(
						(path[0].x - width / 2) * drawScaleX, 
						(path[0].y - height / 2) * drawScaleY
					);
					
					for (let j = 1; j < path.length; j++) {
						ctx.lineTo(
							(path[j].x - width / 2) * drawScaleX, 
							(path[j].y - height / 2) * drawScaleY
						);
					}
					ctx.stroke();
				}
			}
			
			ctx.restore();
		}
		// Функция для обновления прицела на imagePreview
		function redrawImageCrosshairOnly() {
			if (!originalImage && !isSvgFile) return;

			if (isSvgFile) {
				displaySvg();
			} else {
				displayImage(originalImage);
			}

			if (showCrosshair.checked) {
				const sheetWidth = parseInt(sheetWidthInput.value);
				const sheetHeight = parseInt(sheetHeightInput.value);
				drawCrosshair(imageCtx, imagePreview, sheetWidth, sheetHeight);
			}
		}

		// Отрисовка векторного превью с соединениями
		function drawVectorPreview() {
			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
			
			drawVectorPaths(vectorCtx, vectorPreview);

			if (showCrosshair.checked) {
				const sheetWidth = parseInt(sheetWidthInput.value);
				const sheetHeight = parseInt(sheetHeightInput.value);
				drawCrosshair(vectorCtx, vectorPreview, sheetWidth, sheetHeight);
			}
		}
				

        // Получение пикселя
        function getPixel(imageData, x, y) {
            const index = (y * imageData.width + x) * 4;
            return [
                imageData.data[index],
                imageData.data[index + 1],
                imageData.data[index + 2],
                imageData.data[index + 3]
            ];
        }

		// генерация G-code
		function generateGCode(pauseTime, travelSpeed, drawSpeed, areaWidth, areaHeight, startX, startY, minLineLength, offsetX, offsetY, rotation) {
			let gcode = [];
			
			// Колонтитулы
			gcode.push('; G-code для Sovol SO-1');
			//gcode.push('; Сгенерировано автоматически');
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			gcode.push(`; Лист: ${sheetWidth}x${sheetHeight}мм`);
			gcode.push(`; Начало: X${startX} Y${startY}`);
			gcode.push(`; Смещение: X${offsetX}мм Y${offsetY}мм`);
			gcode.push(`; Вращение: ${rotation}°`);
			gcode.push('');
			
			// Инициализация
			gcode.push('G21');
			gcode.push('G90');
			gcode.push('G92 X0.00 Y0.00 Z0.00');
			gcode.push('M280 P0 S30.00');
			gcode.push('G4 P' + pauseTime);
			gcode.push('');
			
			if (filteredPaths.length === 0) {
				gcode.push('G1 X0 Y0 F' + travelSpeed);
				gcode.push('M2');
				gcode.push('; Нет путей для рисования');
				return gcode.join('\n');
			}
			
			const width = isSvgFile ? svgPaths.width : originalImage.width;
			const height = isSvgFile ? svgPaths.height : originalImage.height;
			
			const scaleX = areaWidth / width;
			const scaleY = areaHeight / height;
			const scale = Math.min(scaleX, scaleY);
			
			const rad = rotation * Math.PI / 180;
			const cos = Math.cos(rad);
			const sin = Math.sin(rad);
			
			// Функция преобразования точки
			function transformPoint(point) {

				let pointX = point.x * scale;
				let pointY = (height - point.y) * scale;
				
				const centerX = areaWidth / 2;
				const centerY = areaHeight / 2;
				
				const relX = pointX - centerX;
				const relY = pointY - centerY;
				
				const rad = -rotation * Math.PI / 180;  // МИНУС перед rotation
				const cos = Math.cos(rad);
				const sin = Math.sin(rad);
				
				const rotatedX = relX * cos - relY * sin;
				const rotatedY = relX * sin + relY * cos;
				
				const finalX = offsetX + centerX + rotatedX - startX;
				const finalY = offsetY + centerY + rotatedY - startY;
				
				return { x: finalX, y: finalY };
			}
						
			// Подготавливаем данные путей
			const pathsData = filteredPaths.map(path => {
				const transformedPath = path.map(point => transformPoint(point));
				return {
					originalPath: path,
					transformedPath: transformedPath,
					start: transformedPath[0],
					end: transformedPath[transformedPath.length - 1]
				};
			});
			
			// СОРТИРУЕМ ПУТИ
			const sortedPathsData = sortPathsByDistance(pathsData);
			
			let pathCount = 0;
			let totalLengthMM = 0;
			let totalDrawTime = 0;
			let totalTravelTime = 0;
			let currentPosition = { x: 0, y: 0 };
				
			// ПЕРВЫЙ ПУТЬ - перемещаемся к его началу
			if (sortedPathsData.length > 0) {
				const firstPath = sortedPathsData[0];
				const travelDistance = distanceBetweenPoints(currentPosition, firstPath.start);
				const travelTime = (travelDistance / travelSpeed) * 60; // секунды
				totalTravelTime += travelTime;
				
				gcode.push('G1 X' + firstPath.start.x.toFixed(2) + ' Y' + firstPath.start.y.toFixed(2) + ' F' + travelSpeed);
				currentPosition = firstPath.start;
			}
			
			// ОБРАБАТЫВАЕМ ВСЕ ПУТИ
			for (let i = 0; i < sortedPathsData.length; i++) {
				const pathData = sortedPathsData[i];
				const transformedPath = pathData.transformedPath;
				
				// ОПУСКАЕМ ПЕРО
				gcode.push('G4 P' + pauseTime);
				gcode.push('M280 P0 S0');
				gcode.push('G4 P' + pauseTime);
				
				// РИСУЕМ ПУТЬ
				for (let j = 1; j < transformedPath.length; j++) {
					const point = transformedPath[j];
					const segmentLength = distanceBetweenPoints(transformedPath[j-1], point);
					const segmentTime = (segmentLength / drawSpeed) * 60; // секунды
					totalDrawTime += segmentTime;
					
					gcode.push('G1 X' + point.x.toFixed(2) + ' Y' + point.y.toFixed(2) + ' F' + drawSpeed);
					currentPosition = point;
				}
				
				// ПОДНИМАЕМ ПЕРО
				gcode.push('G4 P' + pauseTime);
				gcode.push('M280 P0 S30');
				gcode.push('G4 P' + pauseTime);
				
				// ПЕРЕМЕЩАЕМСЯ К СЛЕДУЮЩЕМУ ПУТИ
				if (i < sortedPathsData.length - 1) {
					const nextPath = sortedPathsData[i + 1];
					const travelDistance = distanceBetweenPoints(currentPosition, nextPath.start);
					const travelTime = (travelDistance / travelSpeed) * 60; // секунды
					totalTravelTime += travelTime;
					
					gcode.push('G1 X' + nextPath.start.x.toFixed(2) + ' Y' + nextPath.start.y.toFixed(2) + ' F' + travelSpeed);
					currentPosition = nextPath.start;
				}
				
				pathCount++;
				
				// Считаем длину пути
				let pathLength = 0;
				for (let j = 1; j < transformedPath.length; j++) {
					pathLength += distanceBetweenPoints(transformedPath[j-1], transformedPath[j]);
				}
				totalLengthMM += pathLength;
			}
			
			// ВОЗВРАТ В НАЧАЛО
			const returnDistance = distanceBetweenPoints(currentPosition, {x: 0, y: 0});
			const returnTime = (returnDistance / travelSpeed) * 60;
			totalTravelTime += returnTime;
			
			gcode.push('G1 X0 Y0 F' + travelSpeed);
			gcode.push('M2');
			
			// Расчет общего времени печати
			const totalTimeSeconds = totalDrawTime + totalTravelTime + (pauseTime * pathsData.length * 4 / 1000);
			const minutes = Math.floor(totalTimeSeconds / 60);
			const seconds = Math.round(totalTimeSeconds % 60);
			
			// Статистика
			gcode.push('');
			gcode.push('; Статистика:');
			gcode.push('; Путей: ' + pathCount);
			gcode.push('; Общая длина: ' + totalLengthMM.toFixed(1) + 'мм');
			gcode.push('; Время печати: ' + minutes + 'м ' + seconds + 'с');
			
			return gcode.join('\n');
		}

		// Сортировка путей с учетом разворота путей для минимальных перемещений
		function sortPathsByDistance(pathsData) {
			if (pathsData.length === 0) return [];
			
			const sorted = [];
			const used = new Set();
			
			// Начинаем с пути, ближайшего к стартовой точке (0,0)
			let currentIndex = findNearestToStart(pathsData);
			let current = pathsData[currentIndex];
			sorted.push(current);
			used.add(currentIndex);
			
			// Последовательно находим ближайший путь
			while (used.size < pathsData.length) {
				let nearestIndex = -1;
				let minDistance = Infinity;
				let shouldReverse = false;
				
				for (let i = 0; i < pathsData.length; i++) {
					if (used.has(i)) continue;
					
					const path = pathsData[i];
					
					// Вариант 1: от конца текущего к началу следующего
					const distanceToStart = distanceBetweenPoints(current.end, path.start);
					if (distanceToStart < minDistance) {
						minDistance = distanceToStart;
						nearestIndex = i;
						shouldReverse = false;
					}
					
					// Вариант 2: от конца текущего к концу следующего (и разворачиваем следующий)
					const distanceToEnd = distanceBetweenPoints(current.end, path.end);
					if (distanceToEnd < minDistance) {
						minDistance = distanceToEnd;
						nearestIndex = i;
						shouldReverse = true;
					}
				}
				
				if (nearestIndex !== -1) {
					let nextPath = pathsData[nearestIndex];
					
					// Если нужно развернуть путь - создаем развернутую копию
					if (shouldReverse) {
						nextPath = {
							originalPath: [...nextPath.originalPath].reverse(),
							transformedPath: [...nextPath.transformedPath].reverse(),
							start: nextPath.end,
							end: nextPath.start
						};
					}
					
					current = nextPath;
					sorted.push(current);
					used.add(nearestIndex);
				} else {
					break;
				}
			}
			
			return sorted;
		}

		// Находит путь, ближайший к стартовой точке (0,0)
		function findNearestToStart(pathsData) {
			let nearestIndex = 0;
			let minDistance = distanceBetweenPoints({x:0, y:0}, pathsData[0].start);
			
			for (let i = 1; i < pathsData.length; i++) {
				const path = pathsData[i];
				const distToStart = distanceBetweenPoints({x:0, y:0}, path.start);
				const distToEnd = distanceBetweenPoints({x:0, y:0}, path.end);
				
				const minDist = Math.min(distToStart, distToEnd);
				if (minDist < minDistance) {
					minDistance = minDist;
					nearestIndex = i;
				}
			}
			
			return nearestIndex;
		}

        // Обновление статуса
        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = 'status ' + type;
        }

		function debounce(func, wait) {
			let timeout;
			return function executedFunction(...args) {
				const later = () => {
					clearTimeout(timeout);
					func(...args);
				};
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		}

		function saveLayoutState() {
			localStorage.setItem('canvasLayoutState', layoutState.toString());
		}

		function loadLayoutState() {
			const saved = localStorage.getItem('canvasLayoutState');
			if (saved !== null) {
				const savedLayout = parseInt(saved);

				applyLayout(savedLayout);
			}

		}

		// переключатель		
		function switchLayout() {
			layoutState = (layoutState + 1) % 3;
			applyLayout(layoutState);
			saveLayoutState();
		}

		function applyLayout(targetLayout) {
			const mainContainer = document.getElementById('mainContainer');
			const layoutToggle = document.getElementById('layoutToggle');
			
			const imageUpload = document.querySelector('.image-upload-panel');
			const tracingSettings = document.querySelector('.tracing-settings-panel');
			const originalImage = document.querySelector('.original-image-panel');
			const vectorPreviewPanel = document.querySelector('.vector-preview-panel');

			mainContainer.innerHTML = '';
			
			switch(targetLayout) {
				case 0: 
					mainContainer.style.gridTemplateColumns = '1fr 1fr';
					mainContainer.style.gridTemplateRows = 'auto';
					mainContainer.style.gap = '20px';
					
					const leftPanel0 = document.createElement('div');
					leftPanel0.className = 'left-panel';
					leftPanel0.style.display = 'flex';
					leftPanel0.style.flexDirection = 'column';
					leftPanel0.style.gap = '20px';
					leftPanel0.appendChild(imageUpload);
					leftPanel0.appendChild(tracingSettings);
					
					const rightPanel0 = document.createElement('div');
					rightPanel0.className = 'right-panel';
					rightPanel0.style.display = 'flex';
					rightPanel0.style.flexDirection = 'column';
					rightPanel0.style.gap = '20px';
					rightPanel0.appendChild(originalImage);
					rightPanel0.appendChild(vectorPreviewPanel);
					
					mainContainer.appendChild(leftPanel0);
					mainContainer.appendChild(rightPanel0);
					layoutToggle.textContent = '☻☺☺';
					break;
					
				case 1: // Превью слева, настройки справа
					mainContainer.style.gridTemplateColumns = '1fr 1fr';
					mainContainer.style.gridTemplateRows = 'auto';
					mainContainer.style.gap = '20px';
					
					const leftPanel1 = document.createElement('div');
					leftPanel1.className = 'left-panel';
					leftPanel1.style.display = 'flex';
					leftPanel1.style.flexDirection = 'column';
					leftPanel1.style.gap = '20px';
					leftPanel1.appendChild(originalImage);
					leftPanel1.appendChild(vectorPreviewPanel);
					
					const rightPanel1 = document.createElement('div');
					rightPanel1.className = 'right-panel';
					rightPanel1.style.display = 'flex';
					rightPanel1.style.flexDirection = 'column';
					rightPanel1.style.gap = '20px';
					rightPanel1.appendChild(imageUpload);
					rightPanel1.appendChild(tracingSettings);
					
					mainContainer.appendChild(leftPanel1);
					mainContainer.appendChild(rightPanel1);
					layoutToggle.textContent = '☺☻☺';
					break;
					
				case 2: // Настройки сверху, превью снизу (рядом)
					mainContainer.style.gridTemplateColumns = '1fr 1fr';
					mainContainer.style.gridTemplateRows = 'auto auto';
					mainContainer.style.gap = '20px';
					
					imageUpload.style.gridColumn = '1';
					imageUpload.style.gridRow = '1';
					
					tracingSettings.style.gridColumn = '2';
					tracingSettings.style.gridRow = '1';
					
					originalImage.style.gridColumn = '1';
					originalImage.style.gridRow = '2';
					
					vectorPreviewPanel.style.gridColumn = '2';
					vectorPreviewPanel.style.gridRow = '2';
					
					mainContainer.appendChild(imageUpload);
					mainContainer.appendChild(tracingSettings);
					mainContainer.appendChild(originalImage);
					mainContainer.appendChild(vectorPreviewPanel);
					
					layoutToggle.textContent = '☺☺☻';
					break;
			}
			
			layoutState = targetLayout;
		}

        // Обработчики изменений
		document.getElementById('centerX').addEventListener('click', function() {
			const sheetWidth = parseInt(sheetWidthInput.value);
			const areaWidth = parseInt(areaWidthInput.value);
			offsetXInput.value = Math.round((sheetWidth - areaWidth) / 2);
			updatePositioningOnly();
			setTimeout(updatePositioningWithRecalculation, 100);
		});

		document.getElementById('centerY').addEventListener('click', function() {
			const sheetHeight = parseInt(sheetHeightInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			offsetYInput.value = Math.round((sheetHeight - areaHeight) / 2);
			updatePositioningOnly();
			setTimeout(updatePositioningWithRecalculation, 100);
		});
		
        document.getElementById('invertImage').addEventListener('change', function() {
            if (originalImage && !isSvgFile) {
			displayImage(originalImage);
			processAndDrawVectors();
        }});
        
		
		
conversionMethod.addEventListener('change', function() {
    // Показ/скрытие опций для трассировки по центру линии
    const centerlineOptions = document.getElementById('centerlineOptions');
    if (conversionMethod.value === 'centerline') {
        centerlineOptions.style.display = 'block';
    } else {
        centerlineOptions.style.display = 'none';
    }
    
    if (document.getElementById('loadingIcon').style.display === 'block') {
        updateStatus('Дождитесь завершения текущей обработки', 'error');
        return;
    }
    
    if (!originalImage && !isSvgFile) {
        updateStatus('Сначала загрузите изображение', 'error');
        return;
    }

    processAndDrawVectors();
});

		// Добавляем функциональность переключения макета
		document.getElementById('layoutToggle').addEventListener('click', switchLayout);


        // ==================== ОБРАБОТКА SVG ====================

		function processSvgFileContent(svgContent) {
			updateStatus('Обработка SVG файла...', 'success');
			
			try {
				const parser = new DOMParser();
				const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
				
				const parserError = svgDoc.querySelector('parsererror');
				if (parserError) {
					throw new Error('Ошибка парсинга SVG: ' + parserError.textContent);
				}
				
				const svgElement = svgDoc.documentElement;
				
				let svgWidth = 210;
				let svgHeight = 297;
				
				const widthAttr = svgElement.getAttribute('width');
				const heightAttr = svgElement.getAttribute('height');
				
				if (widthAttr && heightAttr) {
					svgWidth = parseFloat(widthAttr.replace('mm', ''));
					svgHeight = parseFloat(heightAttr.replace('mm', ''));
				}
				
				const viewBox = svgElement.getAttribute('viewBox');
				if (viewBox) {
					const viewBoxParts = viewBox.split(/[\s,]+/).filter(part => part !== '');
					if (viewBoxParts.length >= 4) {
						svgWidth = parseFloat(viewBoxParts[2]);
						svgHeight = parseFloat(viewBoxParts[3]);
					}
				}
					
				svgPaths = {
					width: svgWidth,
					height: svgHeight,
					content: svgContent,
					paths: []
				};
				
				extractPathsFromSvg(svgElement);
				
				setupSvgDisplay(svgWidth, svgHeight);
				processAndDrawVectors();
				updateStatus('SVG загружен (автоматически выбран метод "SVG пути")', 'success');
				
			} catch (error) {
				console.error('Ошибка обработки SVG:', error);
				updateStatus('Ошибка загрузки SVG: ' + error.message, 'error');
			}
		}

		function setupSvgDisplay(svgWidth, svgHeight) {
			
			imageAspectRatio = svgWidth / svgHeight;
			
			areaWidthInput.value = Math.round(svgWidth);
			areaHeightInput.value = Math.round(svgHeight);
			
			updateCanvasSizes();
			
			displaySvgVector();
			updateStatus('SVG файл загружен', 'success');
		}

		// ОБНОВЛЯЕМ ФУНКЦИЮ СОЗДАНИЯ BMP - ФИКСИРУЕМ МАСШТАБ
		function createBitmapFromSheet() {
			if (!svgPaths || !svgPaths.paths) {
				console.error('Нет SVG данных для создания BMP');
				return null;
			}
			
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
						
			try {

				const bmpCanvas = document.createElement('canvas');
				bmpCanvas.width = svgPaths.width; 
				bmpCanvas.height = svgPaths.height;
				const bmpCtx = bmpCanvas.getContext('2d');
								
				bmpCtx.fillStyle = 'white';
				bmpCtx.fillRect(0, 0, bmpCanvas.width, bmpCanvas.height);

				bmpCtx.strokeStyle = 'black';
				bmpCtx.fillStyle = 'black';
				bmpCtx.lineWidth = 1;
				
				let pathsDrawn = 0;
				for (const svgPath of svgPaths.paths) {
					try {
						const pathData = parseSvgPath(svgPath.d);
						
						for (const path of pathData) {
							if (path.length < 2) continue;
							
							let transformedPath = path;
							if (svgPath.transform) {
								transformedPath = applyTransformationToPath(path, svgPath.transform);
							}
							
							bmpCtx.beginPath();
							bmpCtx.moveTo(transformedPath[0].x, transformedPath[0].y);
							
							for (let i = 1; i < transformedPath.length; i++) {
								bmpCtx.lineTo(transformedPath[i].x, transformedPath[i].y);
							}
							
							bmpCtx.stroke();
							pathsDrawn++;
						}
					} catch (e) {
						console.warn('Ошибка отрисовки пути в BMP:', e);
					}
				}

				const bmpImage = new Image();
				bmpImage.src = bmpCanvas.toDataURL('image/png');
				
				return bmpImage;
				
			} catch (error) {
				console.error('Ошибка создания BMP:', error);
				return null;
			}
		}

		// ОБНОВЛЯЕМ ОБРАБОТКУ SVG ФАЙЛОВ
		function extractPathsFromSvg(element, currentTransform = '') {
			if (!element || !element.children) return;
			
			for (let child of element.children) {
				const tagName = child.tagName.toLowerCase();
				
				const elementTransform = child.getAttribute('transform') || '';
				const combinedTransform = currentTransform + 
					(currentTransform && elementTransform ? ' ' : '') + 
					elementTransform;
				
				if (tagName === 'path') {
					const pathData = child.getAttribute('d');
					if (pathData) {
						svgPaths.paths.push({
							d: pathData,
							transform: combinedTransform
						});
					}
				} else if (tagName === 'rect') {
					const x = parseFloat(child.getAttribute('x') || 0);
					const y = parseFloat(child.getAttribute('y') || 0);
					const width = parseFloat(child.getAttribute('width'));
					const height = parseFloat(child.getAttribute('height'));
					
					if (width && height) {
						const rectPath = `M ${x} ${y} L ${x+width} ${y} L ${x+width} ${y+height} L ${x} ${y+height} Z`;
						svgPaths.paths.push({
							d: rectPath,
							transform: combinedTransform
						});
					}
				} else if (tagName === 'line') {
					const x1 = parseFloat(child.getAttribute('x1') || 0);
					const y1 = parseFloat(child.getAttribute('y1') || 0);
					const x2 = parseFloat(child.getAttribute('x2') || 0);
					const y2 = parseFloat(child.getAttribute('y2') || 0);
					
					const linePath = `M ${x1} ${y1} L ${x2} ${y2}`;
					svgPaths.paths.push({
						d: linePath,
						transform: combinedTransform
					});
				} else if (tagName === 'g') {
					extractPathsFromSvg(child, combinedTransform);
				}
			}
		}

		function convertSvgPathsToVectorPaths() {
			const paths = [];
			
			if (!svgPaths || !svgPaths.paths || svgPaths.paths.length === 0) {
				console.warn('Нет SVG путей для конвертации');
				return paths;
			}
				
			for (let i = 0; i < svgPaths.paths.length; i++) {
				const svgPath = svgPaths.paths[i];
				
				const pathData = parseSvgPath(svgPath.d);
				
				if (pathData && pathData.length > 0) {
					for (const path of pathData) {
						let transformedPath = path;
						if (svgPath.transform) {
							transformedPath = applyTransformationToPath(path, svgPath.transform);
						}

						const validPoints = [];
						for (const point of transformedPath) {
							if (typeof point.x === 'number' && !isNaN(point.x) &&
								typeof point.y === 'number' && !isNaN(point.y)) {
								validPoints.push({
									x: point.x,
									y: point.y
								});
							} else {
								console.warn('🚨 Пропущена невалидная точка:', point);
							}
						}
						
						if (validPoints.length >= 2) {
							paths.push(validPoints);

						}
					}
				}
			}
			
			return paths;
		}

		function applyTransformationToPath(path, transform) {
			if (!transform || transform === '') return path;
			
			let matrix = [1, 0, 0, 1, 0, 0]; // identity matrix
			
			const matrixMatch = transform.match(/matrix\(([^)]+)\)/);
			if (matrixMatch) {
				const values = matrixMatch[1].split(/[\s,]+/).map(parseFloat);
				if (values.length === 6) {
					matrix = values;
				}
			}

			const translateMatch = transform.match(/translate\(([^)]+)\)/);
			if (translateMatch) {
				const values = translateMatch[1].split(/[\s,]+/).map(parseFloat);
				if (values.length >= 1) {
					const tx = values[0];
					const ty = values[1] || 0;
					matrix[4] += tx;
					matrix[5] += ty;
				}
			}

			const scaleMatch = transform.match(/scale\(([^)]+)\)/);
			if (scaleMatch) {
				const values = scaleMatch[1].split(/[\s,]+/).map(parseFloat);
				if (values.length >= 1) {
					const sx = values[0];
					const sy = values[1] || sx;
					matrix[0] *= sx;
					matrix[3] *= sy;
				}
			}
			
			const [a, b, c, d, e, f] = matrix;
			
			return path.map(point => {
				const x = a * point.x + c * point.y + e;
				const y = b * point.x + d * point.y + f;
				return {x, y};
			});
		}

		function parseSvgPath(pathData) {
			const paths = [];
			if (!pathData) return paths;
				
			try {

				const commands = pathData.split(/(?=[MmLlHhVvCcSsQqTtAaZz])/).filter(cmd => cmd.trim());
				
				let currentPath = [];
				let currentX = 0;
				let currentY = 0;
				let startX = 0;
				let startY = 0;
				
				for (let cmd of commands) {
					const command = cmd[0];
					const relative = command === command.toLowerCase();
					const cmdType = command.toUpperCase();
					const args = cmd.slice(1).trim().split(/[\s,]+/).map(parseFloat).filter(n => !isNaN(n));
							  
					switch (cmdType) {
						case 'M': // MoveTo
							if (currentPath.length > 0) {
								paths.push(currentPath);
							}
							currentPath = [];
							if (args.length >= 2) {
								currentX = relative ? currentX + args[0] : args[0];
								currentY = relative ? currentY + args[1] : args[1];
								startX = currentX;
								startY = currentY;
								currentPath.push({x: currentX, y: currentY});
								
								for (let i = 2; i < args.length; i += 2) {
									if (i + 1 < args.length) {
										currentX = relative ? currentX + args[i] : args[i];
										currentY = relative ? currentY + args[i+1] : args[i+1];
										currentPath.push({x: currentX, y: currentY});
									}
								}
							}
							break;
							
						case 'L': // LineTo
							for (let i = 0; i < args.length; i += 2) {
								if (i + 1 < args.length) {
									currentX = relative ? currentX + args[i] : args[i];
									currentY = relative ? currentY + args[i+1] : args[i+1];
									currentPath.push({x: currentX, y: currentY});
								}
							}
							break;
							
						case 'H': // Horizontal LineTo
							for (let i = 0; i < args.length; i++) {
								currentX = relative ? currentX + args[i] : args[i];
								currentPath.push({x: currentX, y: currentY});
							}
							break;
							
						case 'V': // Vertical LineTo
							for (let i = 0; i < args.length; i++) {
								currentY = relative ? currentY + args[i] : args[i];
								currentPath.push({x: currentX, y: currentY});
							}
							break;
							
						case 'Z': // ClosePath
						case 'z':
							if (currentPath.length > 0) {
								currentPath.push({x: startX, y: startY});
								paths.push(currentPath);
								currentPath = [];
							}
							break;
							
		case 'C': // Cubic Bezier

			for (let i = 0; i + 5 < args.length; i += 6) {
				const x1 = relative ? currentX + args[i] : args[i];
				const y1 = relative ? currentY + args[i+1] : args[i+1];
				const x2 = relative ? currentX + args[i+2] : args[i+2];
				const y2 = relative ? currentY + args[i+3] : args[i+3];
				const x = relative ? currentX + args[i+4] : args[i+4];
				const y = relative ? currentY + args[i+5] : args[i+5];
				
				const bezierPoints = approximateCubicBezierSimple(currentX, currentY, x1, y1, x2, y2, x, y, 10);
				
				for (let j = 1; j < bezierPoints.length; j++) {
					currentPath.push(bezierPoints[j]);
				}
				
				currentX = x;
				currentY = y;
			}
			break;
							
		case 'A': // Arc

			for (let i = 0; i + 6 < args.length; i += 7) {
				const rx = Math.abs(args[i]);
				const ry = Math.abs(args[i+1]);
				const xAxisRotation = args[i+2] * Math.PI / 180;
				const largeArcFlag = args[i+3];
				const sweepFlag = args[i+4];
				const x = relative ? currentX + args[i+5] : args[i+5];
				const y = relative ? currentY + args[i+6] : args[i+6];

				const arcPoints = approximateArcSimple(currentX, currentY, x, y, rx, ry, largeArcFlag, sweepFlag, 16);

				for (let j = 1; j < arcPoints.length; j++) {
					currentPath.push(arcPoints[j]);
				}
				
				currentX = x;
				currentY = y;
			}
			break;

		case 'S': // Smooth Cubic Bezier

			for (let i = 0; i + 3 < args.length; i += 4) {
				const x2 = relative ? currentX + args[i] : args[i];
				const y2 = relative ? currentY + args[i+1] : args[i+1];
				const x = relative ? currentX + args[i+2] : args[i+2];
				const y = relative ? currentY + args[i+3] : args[i+3];

				const x1 = 2 * currentX - (currentPath.length > 1 ? currentPath[currentPath.length-2].x : currentX);
				const y1 = 2 * currentY - (currentPath.length > 1 ? currentPath[currentPath.length-2].y : currentY);
						
				const bezierPoints = approximateCubicBezierSimple(currentX, currentY, x1, y1, x2, y2, x, y, 10);
				
				for (let j = 1; j < bezierPoints.length; j++) {
					currentPath.push(bezierPoints[j]);
				}
				
				currentX = x;
				currentY = y;
			}
			break;
							
						default:

							break;
					}
				}

				if (currentPath.length > 0) {
					paths.push(currentPath);
				}
				
			} catch (error) {

			}
			
			return paths;
		}

		function approximateArcSimple(x1, y1, x2, y2, rx, ry, largeArcFlag, sweepFlag, segments) {
			const points = [{x: x1, y: y1}];

			const cosPhi = Math.cos(0); // xAxisRotation (упрощенно)
			const sinPhi = Math.sin(0);

			const rxAbs = Math.abs(rx);
			const ryAbs = Math.abs(ry);

			const x1p = cosPhi * (x1 - x2) / 2 + sinPhi * (y1 - y2) / 2;
			const y1p = -sinPhi * (x1 - x2) / 2 + cosPhi * (y1 - y2) / 2;

			const lambda = (x1p * x1p) / (rxAbs * rxAbs) + (y1p * y1p) / (ryAbs * ryAbs);
			if (lambda > 1) {
				rxAbs *= Math.sqrt(lambda);
				ryAbs *= Math.sqrt(lambda);
			}
			
			const sign = (largeArcFlag === sweepFlag) ? -1 : 1;
			const factor = sign * Math.sqrt(
				Math.max(0, 
					(rxAbs * rxAbs * ryAbs * ryAbs - rxAbs * rxAbs * y1p * y1p - ryAbs * ryAbs * x1p * x1p) /
					(rxAbs * rxAbs * y1p * y1p + ryAbs * ryAbs * x1p * x1p)
				)
			);
			
			const cxp = factor * (rxAbs * y1p) / ryAbs;
			const cyp = factor * (-ryAbs * x1p) / rxAbs;
			
			const cx = cosPhi * cxp - sinPhi * cyp + (x1 + x2) / 2;
			const cy = sinPhi * cxp + cosPhi * cyp + (y1 + y2) / 2;
			
			const vectorAngle = (ux, uy, vx, vy) => {
				const dot = ux * vx + uy * vy;
				const len = Math.sqrt(ux * ux + uy * uy) * Math.sqrt(vx * vx + vy * vy);
				const angle = Math.acos(Math.max(-1, Math.min(1, dot / len)));
				return ((ux * vy - uy * vx) < 0) ? -angle : angle;
			};
			
			const startVectorX = (x1p - cxp) / rxAbs;
			const startVectorY = (y1p - cyp) / ryAbs;
			const endVectorX = (-x1p - cxp) / rxAbs;
			const endVectorY = (-y1p - cyp) / ryAbs;
			
			let startAngle = vectorAngle(1, 0, startVectorX, startVectorY);
			let deltaAngle = vectorAngle(startVectorX, startVectorY, endVectorX, endVectorY);
			
			if (sweepFlag === 0 && deltaAngle > 0) {
				deltaAngle -= 2 * Math.PI;
			} else if (sweepFlag === 1 && deltaAngle < 0) {
				deltaAngle += 2 * Math.PI;
			}
			
			if (largeArcFlag === 1 && Math.abs(deltaAngle) < Math.PI) {
				deltaAngle += (deltaAngle < 0) ? 2 * Math.PI : -2 * Math.PI;
			}

			for (let i = 1; i <= segments; i++) {
				const t = i / segments;
				const angle = startAngle + deltaAngle * t;
				
				const pointX = cx + rxAbs * Math.cos(angle) * cosPhi - ryAbs * Math.sin(angle) * sinPhi;
				const pointY = cy + rxAbs * Math.cos(angle) * sinPhi + ryAbs * Math.sin(angle) * cosPhi;
				
				points.push({x: pointX, y: pointY});
			}
			
			return points;
		}

		function approximateCubicBezierSimple(x1, y1, cx1, cy1, cx2, cy2, x2, y2, segments) {
			const points = [{x: x1, y: y1}];
			
			for (let i = 1; i <= segments; i++) {
				const t = i / segments;
				const u = 1 - t;
				
				const x = u*u*u*x1 + 3*u*u*t*cx1 + 3*u*t*t*cx2 + t*t*t*x2;
				const y = u*u*u*y1 + 3*u*u*t*cy1 + 3*u*t*t*cy2 + t*t*t*y2;
				
				points.push({x, y});
			}
			
			return points;
		}

		function displaySvg() {
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			imageCtx.fillStyle = 'white';
			imageCtx.fillRect(0, 0, imagePreview.width, imagePreview.height);

			displaySvgVector();
			
			if (showCrosshair.checked) {
				drawCrosshair(imageCtx, imagePreview, sheetWidth, sheetHeight);
			}

			pixelToMM = Math.min(areaWidth / svgPaths.width, areaHeight / svgPaths.height);
			
			const method = document.getElementById('conversionMethod').value;
			const methodInfo = method === 'svg' ? ' [векторная обработка]' : ' [растровая обработка]';
			const proportionsInfo = lockProportions.checked ? ' (пропорции заблокированы)' : ' (пропорции разблокированы)';
			
			imageInfo.textContent = `SVG: ${svgPaths.width}×${svgPaths.height}px | Область: ${areaWidth}×${areaHeight}мм${proportionsInfo}${methodInfo} | Лист: ${sheetWidth}×${sheetHeight}мм | Смещение: X${offsetX}мм Y${offsetY}мм | Вращение: ${rotation}°`;
		}

function canvasToImageCoordinates(canvasX, canvasY) {
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    const scaleX = imagePreview.width / sheetWidth;
    const scaleY = imagePreview.height / sheetHeight;
    
    const areaCanvasX = offsetX * scaleX;
    const areaCanvasY = imagePreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
    const areaCanvasWidth = areaWidth * scaleX;
    const areaCanvasHeight = areaHeight * scaleY;
    
    const width = originalImage.width;
    const height = originalImage.height;
    const lockProportions = document.getElementById('lockProportions').checked;

    // Проверяем, попадает ли точка в область изображения
    if (canvasX < areaCanvasX || canvasX > areaCanvasX + areaCanvasWidth ||
        canvasY < areaCanvasY || canvasY > areaCanvasY + areaCanvasHeight) {
        return { x: -1, y: -1 };
    }

    // Координаты относительно области (0,0 в левом верхнем углу области)
    let relX = canvasX - areaCanvasX;
    let relY = canvasY - areaCanvasY;

    // Учитываем вращение
    if (rotation !== 0) {
        const centerX = areaCanvasWidth / 2;
        const centerY = areaCanvasHeight / 2;
        const rad = -rotation * Math.PI / 180;
        const cos = Math.cos(rad);
        const sin = Math.sin(rad);
        
        // Смещаем к центру, вращаем, возвращаем обратно
        const tempX = relX - centerX;
        const tempY = relY - centerY;
        
        const rotatedX = tempX * cos - tempY * sin;
        const rotatedY = tempX * sin + tempY * cos;
        
        relX = rotatedX + centerX;
        relY = rotatedY + centerY;
    }

    let imageX, imageY;

    if (lockProportions) {
        // С ПРОПОРЦИЯМИ - изображение вписывается с сохранением соотношения
        const imageRatio = width / height;
        const areaRatio = areaCanvasWidth / areaCanvasHeight;
        
        let drawWidth, drawHeight;
        let offsetXDraw = 0, offsetYDraw = 0;
        
        if (areaRatio > imageRatio) {
            // Область шире - ограничение по высоте
            drawHeight = areaCanvasHeight;
            drawWidth = drawHeight * imageRatio;
            offsetXDraw = (areaCanvasWidth - drawWidth) / 2;
        } else {
            // Область уже - ограничение по ширине
            drawWidth = areaCanvasWidth;
            drawHeight = drawWidth / imageRatio;
            offsetYDraw = (areaCanvasHeight - drawHeight) / 2;
        }
        
        // Проверяем, попадает ли точка в изображение (после центрирования)
        if (relX >= offsetXDraw && relX <= offsetXDraw + drawWidth &&
            relY >= offsetYDraw && relY <= offsetYDraw + drawHeight) {
            
            imageX = Math.round((relX - offsetXDraw) * (width / drawWidth));
            imageY = Math.round((relY - offsetYDraw) * (height / drawHeight));
        } else {
            return { x: -1, y: -1 };
        }
    } else {
        // БЕЗ ПРОПОРЦИЙ - прямое растягивание
        imageX = Math.round(relX * (width / areaCanvasWidth));
        imageY = Math.round(relY * (height / areaCanvasHeight));
    }

    // Ограничиваем координаты размерами изображения
    return { 
        x: Math.max(0, Math.min(width - 1, imageX)), 
        y: Math.max(0, Math.min(height - 1, imageY)) 
    };
}

function applyEraseToImage() {
    if (erasePoints.length === 0 || !editedImageData) return 0;
    
    saveToHistory();
    let pixelsErased = 0;

    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    
    const scaleX = imagePreview.width / sheetWidth;
    const scaleY = imagePreview.height / sheetHeight;
    
    const areaCanvasWidth = areaWidth * scaleX;
    const areaCanvasHeight = areaHeight * scaleY;
    
    const width = originalImage.width;
    const height = originalImage.height;
    const lockProportions = document.getElementById('lockProportions').checked;

    // Создаем набор для отслеживания уже обработанных пикселей
    const processedPixels = new Set();
    
    // Интерполируем точки для создания непрерывной линии
    const interpolatedPoints = [];
    
    if (erasePoints.length > 1) {
        for (let i = 0; i < erasePoints.length - 1; i++) {
            const start = erasePoints[i];
            const end = erasePoints[i + 1];
            
            interpolatedPoints.push(start);
            
            // Интерполируем промежуточные точки с шагом в половину размера ластика
            const distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            const steps = Math.max(2, Math.floor(distance / (eraserSize / 2)));
            
            for (let j = 1; j < steps; j++) {
                const t = j / steps;
                interpolatedPoints.push({
                    x: start.x + (end.x - start.x) * t,
                    y: start.y + (end.y - start.y) * t
                });
            }
        }
        interpolatedPoints.push(erasePoints[erasePoints.length - 1]);
    } else {
        interpolatedPoints.push(...erasePoints);
    }

    // Обрабатываем все точки (оригинальные + интерполированные)
    for (let i = 0; i < interpolatedPoints.length; i++) {
        const point = interpolatedPoints[i];
        const imageCenter = canvasToImageCoordinates(point.x - 1, point.y - 1);
        
        if (imageCenter.x < 0 || imageCenter.y < 0) continue;
        
        let radiusX, radiusY;

        if (lockProportions) {
            // С ПРОПОРЦИЯМИ - круглый ластик
            const imageRatio = width / height;
            const areaRatio = areaCanvasWidth / areaCanvasHeight;
            
            let effectiveWidth;
            
            if (areaRatio > imageRatio) {
                const drawHeight = areaCanvasHeight;
                const drawWidth = drawHeight * imageRatio;
                effectiveWidth = drawWidth;
            } else {
                effectiveWidth = areaCanvasWidth;
            }
            
            const radius = Math.max(1, Math.round(eraserSize * (width / effectiveWidth)));
            radiusX = radius;
            radiusY = radius;
        } else {
            // БЕЗ ПРОПОРЦИЙ - эллиптический ластик
            const scaleXRatio = width / areaCanvasWidth;
            const scaleYRatio = height / areaCanvasHeight;
            
            radiusX = Math.max(1, Math.round(eraserSize * scaleXRatio));
            radiusY = Math.max(1, Math.round(eraserSize * scaleYRatio));
        }

        // Стираем область вокруг точки
        for (let dy = -radiusY; dy <= radiusY; dy++) {
            for (let dx = -radiusX; dx <= radiusX; dx++) {
                
                let shouldErase = false;
                if (lockProportions) {
                    // Круг для пропорционального режима
                    shouldErase = (dx * dx + dy * dy <= radiusX * radiusX);
                } else {
                    // Эллипс для непропорционального режима
                    shouldErase = ((dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) <= 1);
                }
                
                if (shouldErase) {
                    const imageX = imageCenter.x + dx;
                    const imageY = imageCenter.y + dy;
                    
                    // Проверяем, не обрабатывали ли уже этот пиксель
                    const pixelKey = `${imageX},${imageY}`;
                    if (processedPixels.has(pixelKey)) continue;
                    
                    if (imageX >= 0 && imageX < editedImageData.width && 
                        imageY >= 0 && imageY < editedImageData.height) {
                        
                        const index = (imageY * editedImageData.width + imageX) * 4;
                        editedImageData.data[index] = 255;
                        editedImageData.data[index + 1] = 255;
                        editedImageData.data[index + 2] = 255;
                        editedImageData.data[index + 3] = 255;
                        pixelsErased++;
                        processedPixels.add(pixelKey);
                    }
                }
            }
        }
    }
    
    updateEditedImageDisplay();
    
    if (pixelsErased > 0) {
        updateStatus(`Стерто пикселей: ${pixelsErased} (история: ${currentHistoryIndex + 1}/${MAX_HISTORY_SIZE})`, 'success');
    }
    
    return pixelsErased;
}


		// Функция для запуска ластика
		function startEraser(canvas, event) {
			isMouseDown = true;
			isErasing = true;
			isEraserActive = true;
			currentEraserCanvas = canvas;
			erasePoints = [];
			
			const rect = canvas.getBoundingClientRect();
			const x = event.clientX - rect.left;
			const y = event.clientY - rect.top;
			
			erasePoints.push({x, y});

			if (canvas === vectorPreview) {
				drawErasePreview('vector');
			} else {
				drawImageErasePreview();
			}
			
			// Добавляем глобальные обработчики
			document.addEventListener('mousemove', handleGlobalMouseMove);
			document.addEventListener('mouseup', handleGlobalMouseUp);
			
			event.preventDefault();
		}

		// Глобальный обработчик движения мыши
		function handleGlobalMouseMove(event) {
			if (!isMouseDown || !isEraserActive) return;
			
			const now = Date.now();
			if (now - lastEraseTime < ERASE_THROTTLE) return;
			lastEraseTime = now;
			
			const rect = currentEraserCanvas.getBoundingClientRect();
			let x = event.clientX - rect.left;
			let y = event.clientY - rect.top;
			
			x = Math.max(0, Math.min(currentEraserCanvas.width, x));
			y = Math.max(0, Math.min(currentEraserCanvas.height, y));
			
			erasePoints.push({x, y});
			
			if (currentEraserCanvas === vectorPreview) {
				drawErasePreview('vector');
			} else {
				drawImageErasePreview();
			}
		}

		// Глобальный обработчик отпускания мыши
		function handleGlobalMouseUp(event) {
			if (!isEraserActive) return;
			
			finishEraserOperation();

			document.removeEventListener('mousemove', handleGlobalMouseMove);
			document.removeEventListener('mouseup', handleGlobalMouseUp);
			
			isEraserActive = false;
			currentEraserCanvas = null;
		}

		// Функция завершения операции ластика
		function finishEraserOperation() {
			isMouseDown = false;
			isErasing = false;
			
			if (erasePoints.length > 0) {
				if (currentEraserCanvas === vectorPreview) {
					applyEraseToPaths();
				} else {
					applyEraseToImage();
				}
			}
			
			erasePoints = [];

			if (currentEraserCanvas === vectorPreview) {
				redrawVectorCanvas();
			} else {
				redrawImageWithCrosshair();
				scheduleVectorUpdateAfterErase();
			}
		}


		// Обработчики мыши для верхнего canvas	
		imagePreview.addEventListener('click', function(e) {
			if (currentTool === 'eraser') return;
			if (!originalImage && !isSvgFile) {

				imageInput.click();
				return;
			}
			
			openImageZoom();
		});		
				
		imagePreview.addEventListener('mousedown', function(event) {
			if (!originalImage || isSvgFile) return;
			if (!imageEditMode || !editedImageData) return;
			
			if (currentTool !== 'eraser') return;
			
			startEraser(imagePreview, event);
		});

		imagePreview.addEventListener('mousemove', function(event) {
			if (!originalImage || isSvgFile || !isMouseDown) return;
			
			if (imageEditMode && editedImageData) {
				const now = Date.now();
				if (now - lastEraseTime < ERASE_THROTTLE) return;
				lastEraseTime = now;
				
				const rect = imagePreview.getBoundingClientRect();
				const x = event.clientX - rect.left;
				const y = event.clientY - rect.top;
				
				erasePoints.push({x, y});
				drawImageErasePreview();
			}
		});

		imagePreview.addEventListener('mouseup', function() {
			if (isMouseDown && imageEditMode) {
				isMouseDown = false;
				isErasing = false;

				if (erasePoints.length > 0) {
					applyEraseToImage();
				}
				
				erasePoints = [];
				redrawImageWithCrosshair();
				scheduleVectorUpdateAfterErase();
			}
			isMouseDown = false;
		});

		// Обработчики мыши для нижнего canvas (векторный превью)
		vectorPreview.addEventListener('click', function(e) {
			if (currentTool === 'eraser') return;
			if (!originalImage && !isSvgFile) {
				imageInput.click();
				return;
			}
			if (filteredPaths.length === 0 && vectorPaths.length === 0) {
				updateStatus('Нет векторных данных для отображения', 'error');
				return;
			}
			openVectorZoom();
		});

		vectorPreview.addEventListener('mousedown', function(event) {
			if (!originalImage && !isSvgFile) return;
			if (currentTool !== 'eraser') {
				openVectorZoom();
				return;
			}
			startEraser(vectorPreview, event);
		});

		vectorPreview.addEventListener('mousemove', function(event) {
			if ((!originalImage && !isSvgFile) || !isMouseDown) return;
			if (currentTool !== 'eraser') return;
			
			const now = Date.now();
			if (now - lastEraseTime < ERASE_THROTTLE) return;
			lastEraseTime = now;
			
			const rect = vectorPreview.getBoundingClientRect();
			const x = event.clientX - rect.left;
			const y = event.clientY - rect.top;
			
			erasePoints.push({x, y});

				drawErasePreview('vector');
		});

		vectorPreview.addEventListener('mouseup', function() {
			if (isMouseDown && currentTool === 'eraser') {
				isMouseDown = false;
				isErasing = false;

				if (erasePoints.length > 0) {
					applyEraseToPaths();
				}

				erasePoints = [];
				redrawVectorCanvas();
			}
		});

		// Функция для отрисовки предпросмотра области стирания
function drawImageErasePreview() {
    if (erasePoints.length === 0) return;
    
    redrawImageWithCrosshair();
    
    const lockProportions = document.getElementById('lockProportions').checked;
    
    imageCtx.save();
    imageCtx.globalCompositeOperation = 'source-over';
    imageCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
    imageCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    
    if (lockProportions) {
        // С ПРОПОРЦИЯМИ - непрерывная круглая полоса
        imageCtx.lineWidth = eraserSize * 2;
        imageCtx.lineCap = 'round';
        imageCtx.lineJoin = 'round';
        
        if (erasePoints.length === 1) {
            // Одна точка - просто круг
            const point = erasePoints[0];
            imageCtx.beginPath();
            imageCtx.arc(point.x, point.y, eraserSize, 0, Math.PI * 2);
            imageCtx.fill();
        } else {
            // Несколько точек - непрерывная линия с закругленными концами
            imageCtx.beginPath();
            imageCtx.moveTo(erasePoints[0].x, erasePoints[0].y);
            for (let i = 1; i < erasePoints.length; i++) {
                imageCtx.lineTo(erasePoints[i].x, erasePoints[i].y);
            }
            imageCtx.stroke();
        }
    } else {
        // БЕЗ ПРОПОРЦИЙ - непрерывная круглая полоса (фикс: убираем эллиптическую форму)
        imageCtx.lineWidth = eraserSize * 2;
        imageCtx.lineCap = 'round';
        imageCtx.lineJoin = 'round';
        
        if (erasePoints.length === 1) {
            // Одна точка - круг
            const point = erasePoints[0];
            imageCtx.beginPath();
            imageCtx.arc(point.x, point.y, eraserSize, 0, Math.PI * 2);
            imageCtx.fill();
        } else {
            // Несколько точек - непрерывная линия с закругленными концами
            imageCtx.beginPath();
            imageCtx.moveTo(erasePoints[0].x, erasePoints[0].y);
            for (let i = 1; i < erasePoints.length; i++) {
                imageCtx.lineTo(erasePoints[i].x, erasePoints[i].y);
            }
            imageCtx.stroke();
        }
    }
    
    imageCtx.restore();
}

		function drawErasePreview() {
			if (erasePoints.length === 0) return;

			if (currentEraserCanvas === vectorPreview) {
				vectorCtx.fillStyle = 'white';
				vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
				
				if (vectorSnapshot && vectorSnapshot.complete) {
					vectorCtx.drawImage(vectorSnapshot, 0, 0);
				} else {
					drawVectorPaths(vectorCtx, vectorPreview);
				}
			}

			const ctx = currentEraserCanvas === vectorPreview ? vectorCtx : imageCtx;
			
			ctx.save();
			ctx.globalCompositeOperation = 'source-over';
			ctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
			ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
			ctx.lineWidth = eraserSize * 2;
			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';
			
			if (erasePoints.length >= 1) {
				ctx.beginPath();
				
				if (erasePoints.length === 1) {
					const point = erasePoints[0];
					ctx.arc(point.x-1, point.y-1, eraserSize, 0, Math.PI * 2);
					ctx.fill();
				} else {
					ctx.moveTo(erasePoints[0].x-1, erasePoints[0].y-1);
					for (let i = 1; i < erasePoints.length; i++) {
						ctx.lineTo(erasePoints[i].x, erasePoints[i].y);
					}
					ctx.stroke();
				}
			}
			
			ctx.restore();
		}

		// Функция применения стирания к путям
function applyEraseToPaths() {
    if (erasePoints.length === 0) return 0;
    
    saveToHistory();
    
    // 1. ПРЕОБРАЗУЕМ ВСЕ ВЕКТОРЫ В КООРДИНАТЫ CANVAS
    const transformedPaths = [];
    
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    const scaleX = vectorPreview.width / sheetWidth;
    const scaleY = vectorPreview.height / sheetHeight;
    
    const areaCanvasX = offsetX * scaleX;
    const areaCanvasY = vectorPreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
    const areaCanvasWidth = areaWidth * scaleX;
    const areaCanvasHeight = areaHeight * scaleY;
    
    const width = isSvgFile ? svgPaths.width : originalImage.width;
    const height = isSvgFile ? svgPaths.height : originalImage.height;
    
    const imageRatio = width / height;
    const areaRatio = areaWidth / areaHeight;
    
    const lockProportions = document.getElementById('lockProportions').checked;
    
    let drawScaleX, drawScaleY;
    
    if (lockProportions) {
        if (areaRatio > imageRatio) {
            drawScaleY = areaCanvasHeight / height;
            drawScaleX = drawScaleY;
        } else {
            drawScaleX = areaCanvasWidth / width;
            drawScaleY = drawScaleX;
        }
    } else {
        drawScaleX = areaCanvasWidth / width;
        drawScaleY = areaCanvasHeight / height;
    }
    
    // Преобразуем все точки векторов в координаты canvas
    for (let i = 0; i < filteredPaths.length; i++) {
        const originalPath = filteredPaths[i];
        const transformedPath = [];
        
        for (let j = 0; j < originalPath.length; j++) {
            const point = originalPath[j];
            
            let x = (point.x - width / 2) * drawScaleX;
            let y = (point.y - height / 2) * drawScaleY;
            
            const rad = rotation * Math.PI / 180;
            const cos = Math.cos(rad);
            const sin = Math.sin(rad);
            const rotatedX = x * cos - y * sin;
            const rotatedY = x * sin + y * cos;
            
            const finalX = areaCanvasX + areaCanvasWidth / 2 + rotatedX + 2;
            const finalY = areaCanvasY + areaCanvasHeight / 2 + rotatedY + 2;
            
            transformedPath.push({ 
                x: finalX, 
                y: finalY, 
                originalPoint: point,
                index: j 
            });
        }
        
        transformedPaths.push({
            originalPath: originalPath,
            transformedPath: transformedPath,
            pathIndex: i
        });
    }
    
    // 2. СОЗДАЕМ МАСКУ СТИРАНИЯ
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = vectorPreview.width;
    maskCanvas.height = vectorPreview.height;
    const maskCtx = maskCanvas.getContext('2d');
    
    // Заполняем черным
    maskCtx.fillStyle = 'black';
    maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
    
    // Рисуем белые области стирания
    maskCtx.strokeStyle = 'white';
    maskCtx.fillStyle = 'white';
    maskCtx.lineWidth = eraserSize * 2;
    maskCtx.lineCap = 'round';
    maskCtx.lineJoin = 'round';
    
    if (erasePoints.length === 1) {
        // Одна точка - круг
        const point = erasePoints[0];
        maskCtx.beginPath();
        maskCtx.arc(point.x, point.y, eraserSize, 0, Math.PI * 2);
        maskCtx.fill();
    } else {
        // Несколько точек - линия с закругленными концами
        maskCtx.beginPath();
        maskCtx.moveTo(erasePoints[0].x, erasePoints[0].y);
        for (let i = 1; i < erasePoints.length; i++) {
            maskCtx.lineTo(erasePoints[i].x, erasePoints[i].y);
        }
        maskCtx.stroke();
        
        // Закрашиваем концы
        maskCtx.beginPath();
        maskCtx.arc(erasePoints[0].x, erasePoints[0].y, eraserSize, 0, Math.PI * 2);
        maskCtx.arc(erasePoints[erasePoints.length - 1].x, erasePoints[erasePoints.length - 1].y, eraserSize, 0, Math.PI * 2);
        maskCtx.fill();
    }
    
    const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
    
    // 3. ФУНКЦИЯ ПРОВЕРКИ ТОЧКИ В ОБЛАСТИ СТИРАНИЯ
    function isPointInEraseArea(canvasX, canvasY) {
        if (canvasX < 0 || canvasX >= maskCanvas.width || 
            canvasY < 0 || canvasY >= maskCanvas.height) {
            return false;
        }
        const index = (Math.floor(canvasY) * maskCanvas.width + Math.floor(canvasX)) * 4;
        return maskData.data[index] === 255; // Белый = область стирания
    }
    
    // 4. ФУНКЦИЯ НАХОЖДЕНИЯ ТОЧКИ ПЕРЕСЕЧЕНИЯ (точная)
    function findIntersectionPoint(p1, p2, steps = 20) {
        const p1Erased = isPointInEraseArea(p1.x, p1.y);
        const p2Erased = isPointInEraseArea(p2.x, p2.y);
        
        // Если оба конца в одной зоне - пересечений нет
        if (p1Erased === p2Erased) return null;
        
        // Бинарный поиск точки пересечения
        let low = 0, high = 1;
        
        for (let i = 0; i < steps; i++) {
            const mid = (low + high) / 2;
            const midPoint = {
                x: p1.x + (p2.x - p1.x) * mid,
                y: p1.y + (p2.y - p1.y) * mid
            };
            const midErased = isPointInEraseArea(midPoint.x, midPoint.y);
            
            if (midErased === p1Erased) {
                low = mid;
            } else {
                high = mid;
            }
        }
        
        // Возвращаем точку на границе
        const t = (low + high) / 2;
        return {
            x: p1.x + (p2.x - p1.x) * t,
            y: p1.y + (p2.y - p1.y) * t,
            t: t
        };
    }
    
    // 5. ОБРАБАТЫВАЕМ ПУТИ С ТОЧНЫМ ОПРЕДЕЛЕНИЕМ ПЕРЕСЕЧЕНИЙ
    const newFilteredPaths = [];
    let totalPathsModified = 0;
    
    for (const pathData of transformedPaths) {
        const originalPath = pathData.originalPath;
        const transformedPath = pathData.transformedPath;
        
        if (transformedPath.length < 2) {
            newFilteredPaths.push(originalPath);
            continue;
        }
        
        const pathSegments = [];
        let currentSegment = [];
        let hasIntersections = false;
        
        // Проверяем весь путь на пересечения
        for (let j = 0; j < transformedPath.length; j++) {
            const transformedPoint = transformedPath[j];
            const originalPoint = transformedPoint.originalPoint;
            const pointErased = isPointInEraseArea(transformedPoint.x, transformedPoint.y);
            
            if (j === 0) {
                // Первая точка
                currentSegment.push(originalPoint);
            } else {
                const prevTransformed = transformedPath[j-1];
                const prevOriginal = prevTransformed.originalPoint;
                const prevErased = isPointInEraseArea(prevTransformed.x, prevTransformed.y);
                
                if (prevErased !== pointErased) {
                    // Найдено пересечение границы - находим точную точку пересечения
                    hasIntersections = true;
                    const intersection = findIntersectionPoint(prevTransformed, transformedPoint);
                    
                    if (intersection) {
                        // Интерполируем оригинальную точку пересечения
                        const intersectionOriginal = {
                            x: prevOriginal.x + (originalPoint.x - prevOriginal.x) * intersection.t,
                            y: prevOriginal.y + (originalPoint.y - prevOriginal.y) * intersection.t
                        };
                        
                        // Завершаем текущий сегмент до точки пересечения
                        currentSegment.push(intersectionOriginal);
                        if (currentSegment.length >= 2) {
                            pathSegments.push([...currentSegment]);
                        }
                        
                        // Начинаем новый сегмент с точки пересечения
                        currentSegment = [intersectionOriginal];
                        
                        // Добавляем текущую точку если она не в зоне стирания
                        if (!pointErased) {
                            currentSegment.push(originalPoint);
                        }
                    } else {
                        // Если не нашли пересечение, продолжаем текущий сегмент
                        currentSegment.push(originalPoint);
                    }
                } else if (pointErased) {
                    // Точка в зоне стирания - завершаем сегмент если он есть
                    if (currentSegment.length >= 2) {
                        pathSegments.push([...currentSegment]);
                    }
                    currentSegment = [];
                } else {
                    // Точка не в зоне стирания - продолжаем сегмент
                    currentSegment.push(originalPoint);
                }
            }
        }
        
        // Добавляем последний сегмент если он есть
        if (currentSegment.length >= 2) {
            pathSegments.push([...currentSegment]);
        }
        
        if (hasIntersections && pathSegments.length > 0) {
            totalPathsModified++;
            newFilteredPaths.push(...pathSegments);
        } else if (!hasIntersections) {
            // Проверяем, не находится ли весь путь в зоне стирания
            let allPointsErased = true;
            for (let j = 0; j < transformedPath.length; j++) {
                if (!isPointInEraseArea(transformedPath[j].x, transformedPath[j].y)) {
                    allPointsErased = false;
                    break;
                }
            }
            
            if (!allPointsErased) {
                newFilteredPaths.push(originalPath);
            } else {
                totalPathsModified++; // Весь путь удален
            }
        }
    }
    
    // 6. ОБНОВЛЯЕМ ПУТИ
    filteredPaths.length = 0;
    filteredPaths.push(...newFilteredPaths);
    
    // 7. ОБНОВЛЯЕМ ОТОБРАЖЕНИЕ
    saveVectorSnapshot();
    updatePathInfo();
    
    if (totalPathsModified > 0) {
        updateStatus(`Удалено сегментов: ${totalPathsModified}`, 'success');
    }
    
    return totalPathsModified;
}

		// Функция для отложенного пересчета векторов после стирания
		function scheduleVectorUpdateAfterErase() {
			if (vectorUpdateTimer) {
				clearTimeout(vectorUpdateTimer);
			}

			vectorUpdateTimer = setTimeout(() => {
				if (originalImage && !isSvgFile) {
					updateStatus('Пересчет векторов...', 'success');
					processAndDrawVectors();
				}
				vectorUpdateTimer = null;
			}, VECTOR_UPDATE_DELAY_AFTER_ERASE);
		}

		function displaySvgVector() {
			const areaWidth = parseInt(areaWidthInput.value);
			const areaHeight = parseInt(areaHeightInput.value);
			const sheetWidth = parseInt(sheetWidthInput.value);
			const sheetHeight = parseInt(sheetHeightInput.value);
			const offsetX = parseFloat(offsetXInput.value);
			const offsetY = parseFloat(offsetYInput.value);
			const rotation = parseFloat(rotationInput.value);
			
			imageCtx.fillStyle = 'white';
			imageCtx.fillRect(0, 0, imagePreview.width, imagePreview.height);
			
			const scaleX = imagePreview.width / sheetWidth;
			const scaleY = imagePreview.height / sheetHeight;
			
			const areaCanvasX = offsetX * scaleX;
			const areaCanvasY = imagePreview.height - (offsetY * scaleY) - (areaHeight * scaleY);
			const areaCanvasWidth = areaWidth * scaleX;
			const areaCanvasHeight = areaHeight * scaleY;
			
			imageCtx.save();
			
			imageCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
			
			imageCtx.rotate(rotation * Math.PI / 180);
			
			const svgRatio = svgPaths.width / svgPaths.height;
			const areaRatio = areaWidth / areaHeight;
			
			const lockProportions = document.getElementById('lockProportions').checked;
			
			
			let drawWidth, drawHeight;
			
			if (lockProportions) {
				// СОХРАНЯЕМ ПРОПОРЦИИ
				if (areaRatio > svgRatio) {
					drawHeight = areaCanvasHeight;
					drawWidth = drawHeight * svgRatio;
				} else {
					drawWidth = areaCanvasWidth;
					drawHeight = drawWidth / svgRatio;
				}
			} else {
				// РАСТЯГИВАЕМ БЕЗ ПРОПОРЦИЙ
				drawWidth = areaCanvasWidth;
				drawHeight = areaCanvasHeight;
			}
			
			const scaleXDraw = drawWidth / svgPaths.width;
			const scaleYDraw = drawHeight / svgPaths.height;

			imageCtx.scale(scaleXDraw, scaleYDraw);

			imageCtx.translate(-svgPaths.width / 2, -svgPaths.height / 2);
			
			imageCtx.strokeStyle = 'black';
			imageCtx.fillStyle = 'black';
			imageCtx.lineWidth = 1;
			
			for (const svgPath of svgPaths.paths) {
				try {

					const pathData = parseSvgPath(svgPath.d);
					
					for (const path of pathData) {
						if (path.length < 2) continue;

						let transformedPath = path;
						if (svgPath.transform) {
							transformedPath = applyTransformationToPath(path, svgPath.transform);
						}

						imageCtx.beginPath();
						imageCtx.moveTo(transformedPath[0].x, transformedPath[0].y);
						
						for (let i = 1; i < transformedPath.length; i++) {
							imageCtx.lineTo(transformedPath[i].x, transformedPath[i].y);
						}
						
						imageCtx.stroke();
					}
				} catch (e) {
					console.warn('Ошибка отрисовки пути:', e);
				}
			}
			
			imageCtx.restore();
			
			if (showCrosshair.checked) {
				drawCrosshair(imageCtx, imagePreview, sheetWidth, sheetHeight);
			}

			pixelToMM = Math.min(areaWidth / svgPaths.width, areaHeight / svgPaths.height);
			
			const proportionsInfo = lockProportions.checked ? ' (пропорции заблокированы)' : ' (пропорции разблокированы)';
			imageInfo.textContent = `SVG: ${svgPaths.width}×${svgPaths.height}px | Область: ${areaWidth}×${areaHeight}мм${proportionsInfo} | Лист: ${sheetWidth}×${sheetHeight}мм | Смещение: X${offsetX}мм Y${offsetY}мм | Вращение: ${rotation}°`;
		}
// ==================== СИСТЕМА ОТМЕНЫ ДЕЙСТВИЙ ЛАСТИКА ====================

		let eraseHistory = [];
		let currentHistoryIndex = -1;
		const MAX_HISTORY_SIZE = 20;

		// Функция для сохранения состояния перед стиранием
		function saveToHistory() {

			if (currentHistoryIndex < eraseHistory.length - 1) {
				eraseHistory = eraseHistory.slice(0, currentHistoryIndex + 1);
			}

			let state;
			if (currentTool === 'eraser' && editedImageData) {

				state = {
					type: 'image',
					data: new ImageData(
						new Uint8ClampedArray(editedImageData.data),
						editedImageData.width,
						editedImageData.height
					),
					filteredPaths: JSON.parse(JSON.stringify(filteredPaths)),
					vectorPaths: JSON.parse(JSON.stringify(vectorPaths))
				};
			} else {

				state = {
					type: 'vector',
					filteredPaths: JSON.parse(JSON.stringify(filteredPaths)),
					vectorPaths: JSON.parse(JSON.stringify(vectorPaths))
				};
			}
			
			eraseHistory.push(state);
			currentHistoryIndex = eraseHistory.length - 1;

			if (eraseHistory.length > MAX_HISTORY_SIZE) {
				eraseHistory.shift();
				currentHistoryIndex--;
			}
			
			updateUndoButton();
		}

		// Функция отмены последнего действия
		function undoLastErase() {
			if (currentHistoryIndex < 0) {
				updateStatus('Нет действий для отмены', 'warning');
				return false;
			}
			
			const previousState = eraseHistory[currentHistoryIndex];
			
			try {
				if (previousState.type === 'image' && editedImageData) {
					// Восстанавливаем изображение
					editedImageData.data.set(previousState.data.data);
					filteredPaths = JSON.parse(JSON.stringify(previousState.filteredPaths));
					vectorPaths = JSON.parse(JSON.stringify(previousState.vectorPaths));
					
					updateEditedImageDisplay();
					saveVectorSnapshot();
					updatePathInfo();
					
					updateStatus(`Отменено действие с изображением (осталось: ${currentHistoryIndex})`, 'success');
				} else {
					// Восстанавливаем векторы
					filteredPaths = JSON.parse(JSON.stringify(previousState.filteredPaths));
					vectorPaths = JSON.parse(JSON.stringify(previousState.vectorPaths));
					
					saveVectorSnapshot();
					updatePathInfo();
					
					updateStatus(`Отменено действие с векторами (осталось: ${currentHistoryIndex})`, 'success');
				}
				
				currentHistoryIndex--;

				redrawVectorCanvas();
				redrawImageWithCrosshair();
				
				updateUndoButton();
				return true;
				
			} catch (error) {
				console.error('Ошибка при отмене действия:', error);
				updateStatus('Ошибка при отмене действия', 'error');
				return false;
			}
		}

		// Функция обновления состояния кнопки отмены
		function updateUndoButton() {
			const undoBtn = document.getElementById('resetImageBtn');
			const hasHistory = currentHistoryIndex >= 0;
			
			if (hasHistory) {
				undoBtn.textContent = `↶ (${currentHistoryIndex + 1})`;
				undoBtn.title = `Отменить последнее действие (осталось: ${currentHistoryIndex + 1})`;
				undoBtn.style.background = '#007cba';
				undoBtn.style.fontWeight = 'bold';
			} else {
				undoBtn.textContent = 'Исходник';
				undoBtn.title = 'Нет действий для отмены';
				undoBtn.style.background = '';
				undoBtn.style.fontWeight = 'normal';
			}
		}


function openImageZoom() {
    const zoomOverlay = document.createElement('div');
    zoomOverlay.style.cssText = `
        position: fixed;
        top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.95);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: default;
        overflow: hidden;
    `;
    
    const zoomContainer = document.createElement('div');
    zoomContainer.style.cssText = `
        position: relative;
        display: inline-block;
        width: ${window.innerWidth}px;
        height: ${window.innerHeight}px;
    `;
    
    const zoomedCanvas = document.createElement('canvas');
    zoomedCanvas.width = window.innerWidth;
    zoomedCanvas.height = window.innerHeight;
    
    zoomedCanvas.style.cssText = `
        border: 2px solid #444;
        border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        background: white;
        cursor: default;
        display: block;
        position: absolute;
        top: 0;
        left: 0;
    `;
    
    const zoomCtx = zoomedCanvas.getContext('2d');

    // ПЕРЕМЕННЫЕ ДЛЯ ЗУМА И ПЕРЕТАСКИВАНИЯ
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    // ПЕРЕМЕННЫЕ ДЛЯ РЕЖИМА ЛАСТИКА
    let isZoomEraserMode = false;
    let isZoomErasing = false;
    let zoomErasePoints = [];
    let zoomLastEraseTime = 0;
    const ZOOM_ERASE_THROTTLE = 50;
    
    // ИСТОРИЯ ДЛЯ ОТМЕНЫ ДЕЙСТВИЙ И ФЛАГ ИЗМЕНЕНИЙ
    let eraseHistory = [];
    const MAX_HISTORY_SIZE = 20;
    let hasChanges = false;
    
    // РАЗМЕР ЛАСТИКА ДЛЯ ЗУМА
    let zoomEraserSize = eraserSize || 20;

    // Функция для сохранения состояния перед стиранием
    function saveToHistory() {
        if (!editedImageData) return;
        
        const historyState = new ImageData(
            new Uint8ClampedArray(editedImageData.data),
            editedImageData.width,
            editedImageData.height
        );
        
        eraseHistory.push(historyState);
        
        if (eraseHistory.length > MAX_HISTORY_SIZE) {
            eraseHistory.shift();
        }
        
        hasChanges = true;
        updateUndoButton();
    }

    // Функция отмены последнего действия
    function undoLastErase() {
        if (eraseHistory.length === 0) {
            updateStatus('Нет действий для отмены', 'warning');
            return;
        }
        
        const previousState = eraseHistory.pop();
        if (previousState && editedImageData) {
            editedImageData.data.set(previousState.data);
            updateEditedImageDisplay();
            redrawZoomedContent();
            redrawImageWithCrosshair();
            
            updateStatus(`Отменено действие из истории (осталось: ${eraseHistory.length})`, 'success');
            
            if (eraseHistory.length === 0) {
                hasChanges = false;
            }
        }
        
        updateUndoButton();
    }

    // Функция обновления состояния кнопки отмены
    function updateUndoButton() {
        undoBtn.disabled = eraseHistory.length === 0;
        if (eraseHistory.length === 0) {
            undoBtn.style.background = 'rgba(0,0,0,0.3)';
            undoBtn.style.color = '#888';
            undoBtn.title = 'Нет действий для отмены';
        } else {
            undoBtn.style.background = 'rgba(0,0,0,0.7)';
            undoBtn.style.color = 'white';
            undoBtn.title = `Отменить последнее стирание (осталось: ${eraseHistory.length})`;
        }
    }

    // Функция для расчета радиуса ластика в координатах зума (видимый размер)
    function getZoomEraserRadius() {
        return zoomEraserSize;
    }

    // Функция обновления курсора ластика
    function updateEraserCursor() {
        if (isZoomEraserMode) {
            const cursorSize = Math.max(20, zoomEraserSize * 2);
            const cursorSVG = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${cursorSize}" height="${cursorSize}" viewBox="0 0 ${cursorSize} ${cursorSize}"><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="${zoomEraserSize}" fill="none" stroke="red" stroke-width="1"/><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="2" fill="red"/></svg>`;
            zoomedCanvas.style.cursor = `url('${cursorSVG}') ${cursorSize/2} ${cursorSize/2}, auto`;
        }
    }

    // Функция обновления отображения размера ластика
    function updateEraserSizeDisplay() {
        eraserSizeValue.textContent = zoomEraserSize + 'px';
        eraserSizeSlider.value = zoomEraserSize;
        
        if (isZoomEraserMode) {
            updateEraserCursor();
        }
        
        if (isZoomErasing) {
            redrawZoomedContent();
            drawZoomErasePreview();
        }
    }

	// Функция преобразования координат canvas в координаты изображения
	function zoomCanvasToImageCoordinates(canvasX, canvasY) {
		const areaWidth = parseInt(areaWidthInput.value);
		const areaHeight = parseInt(areaHeightInput.value);
		const sheetWidth = parseInt(sheetWidthInput.value);
		const sheetHeight = parseInt(sheetHeightInput.value);
		const offsetX = parseFloat(offsetXInput.value);
		const offsetY = parseFloat(offsetYInput.value);
		const rotation = parseFloat(rotationInput.value);
		
		const sheetScaleX = zoomedCanvas.width / sheetWidth;
		const sheetScaleY = zoomedCanvas.height / sheetHeight;
		const sheetScale = Math.min(sheetScaleX, sheetScaleY);
		
		const sheetCanvasWidth = sheetWidth * sheetScale;
		const sheetCanvasHeight = sheetHeight * sheetScale;
		const sheetCanvasX = (zoomedCanvas.width - sheetCanvasWidth) / 2;
		const sheetCanvasY = (zoomedCanvas.height - sheetCanvasHeight) / 2;
		
		const areaScaleX = sheetCanvasWidth / sheetWidth;
		const areaScaleY = sheetCanvasHeight / sheetHeight;
		
		const areaCanvasX = sheetCanvasX + (offsetX * areaScaleX);
		const areaCanvasY = sheetCanvasY + sheetCanvasHeight - (offsetY * areaScaleY) - (areaHeight * areaScaleY);
		const areaCanvasWidth = areaWidth * areaScaleX;
		const areaCanvasHeight = areaHeight * areaScaleY;
		
		const width = originalImage.width;
		const height = originalImage.height;
		const lockProportions = document.getElementById('lockProportions').checked;

		// Учитываем трансформации зума
		let worldX = (canvasX - translateX) / scale;
		let worldY = (canvasY - translateY) / scale;

		// Проверяем, попадает ли точка в область изображения
		if (worldX < areaCanvasX || worldX > areaCanvasX + areaCanvasWidth ||
			worldY < areaCanvasY || worldY > areaCanvasY + areaCanvasHeight) {
			return { x: -1, y: -1 };
		}

		// Координаты относительно области
		let relX = worldX - areaCanvasX;
		let relY = worldY - areaCanvasY;

		// Учитываем вращение
		if (rotation !== 0) {
			const centerX = areaCanvasWidth / 2;
			const centerY = areaCanvasHeight / 2;
			const rad = -rotation * Math.PI / 180;
			const cos = Math.cos(rad);
			const sin = Math.sin(rad);
			
			const tempX = relX - centerX;
			const tempY = relY - centerY;
			
			const rotatedX = tempX * cos - tempY * sin;
			const rotatedY = tempX * sin + tempY * cos;
			
			relX = rotatedX + centerX;
			relY = rotatedY + centerY;
		}

		let imageX, imageY;

		if (lockProportions) {
			// С ПРОПОРЦИЯМИ
			const imageRatio = width / height;
			const areaRatio = areaCanvasWidth / areaCanvasHeight;
			
			let drawWidth, drawHeight;
			let offsetXDraw = 0, offsetYDraw = 0;
			
			if (areaRatio > imageRatio) {
				drawHeight = areaCanvasHeight;
				drawWidth = drawHeight * imageRatio;
				offsetXDraw = (areaCanvasWidth - drawWidth) / 2;
			} else {
				drawWidth = areaCanvasWidth;
				drawHeight = drawWidth / imageRatio;
				offsetYDraw = (areaCanvasHeight - drawHeight) / 2;
			}
			
			if (relX >= offsetXDraw && relX <= offsetXDraw + drawWidth &&
				relY >= offsetYDraw && relY <= offsetYDraw + drawHeight) {
				
				imageX = Math.round((relX - offsetXDraw) * (width / drawWidth));
				imageY = Math.round((relY - offsetYDraw) * (height / drawHeight));
			} else {
				return { x: -1, y: -1 };
			}
		} else {
			// БЕЗ ПРОПОРЦИЙ - прямое преобразование
			imageX = Math.round(relX * (width / areaCanvasWidth));
			imageY = Math.round(relY * (height / areaCanvasHeight));
		}

		return { 
			x: Math.max(0, Math.min(width - 1, imageX)), 
			y: Math.max(0, Math.min(height - 1, imageY)) 
		};
	}

	// Функция применения стирания в зуме
function applyZoomEraseToImage() {
    if (zoomErasePoints.length === 0 || !editedImageData) return 0;
    
    let pixelsErased = 0;
	
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    
    const sheetScaleX = zoomedCanvas.width / sheetWidth;
    const sheetScaleY = zoomedCanvas.height / sheetHeight;
    const sheetScale = Math.min(sheetScaleX, sheetScaleY);
    
    const sheetCanvasWidth = sheetWidth * sheetScale;
    const sheetCanvasHeight = sheetHeight * sheetScale;
    
    const areaScaleX = sheetCanvasWidth / sheetWidth;
    const areaScaleY = sheetCanvasHeight / sheetHeight;
    
    const areaCanvasWidth = areaWidth * areaScaleX;
    const areaCanvasHeight = areaHeight * areaScaleY;
    
    const width = originalImage.width;
    const height = originalImage.height;
    const lockProportions = document.getElementById('lockProportions').checked;

    // Создаем набор для отслеживания уже обработанных пикселей
    const processedPixels = new Set();
    
    // Интерполируем точки для создания непрерывной линии
    const interpolatedPoints = [];
    
    if (zoomErasePoints.length > 1) {
        for (let i = 0; i < zoomErasePoints.length - 1; i++) {
            const start = zoomErasePoints[i];
            const end = zoomErasePoints[i + 1];
            
            interpolatedPoints.push(start);
            
            // Интерполируем промежуточные точки
            const distance = Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
            const steps = Math.max(2, Math.floor(distance / (zoomEraserSize / 2)));
            
            for (let j = 1; j < steps; j++) {
                const t = j / steps;
                interpolatedPoints.push({
                    x: start.x + (end.x - start.x) * t,
                    y: start.y + (end.y - start.y) * t
                });
            }
        }
        interpolatedPoints.push(zoomErasePoints[zoomErasePoints.length - 1]);
    } else {
        interpolatedPoints.push(...zoomErasePoints);
    }

    // Обрабатываем все точки (оригинальные + интерполированные)
    for (let i = 0; i < interpolatedPoints.length; i++) {
        const point = interpolatedPoints[i];
        const imageCenter = zoomCanvasToImageCoordinates(point.x - 2, point.y - 2);
        
        if (imageCenter.x < 0 || imageCenter.y < 0) continue;
        
        let radiusX, radiusY;

        if (lockProportions) {
            // С ПРОПОРЦИЯМИ - круглый ластик
            const imageRatio = width / height;
            const areaRatio = areaCanvasWidth / areaCanvasHeight;
            
            let effectiveWidth;
            
            if (areaRatio > imageRatio) {
                const drawHeight = areaCanvasHeight;
                const drawWidth = drawHeight * imageRatio;
                effectiveWidth = drawWidth;
            } else {
                effectiveWidth = areaCanvasWidth;
            }
            
            const radius = Math.max(1, Math.round(zoomEraserSize * (width / effectiveWidth) / scale));
            radiusX = radius;
            radiusY = radius;
        } else {
            // БЕЗ ПРОПОРЦИЙ - эллиптический ластик
            const scaleXRatio = width / areaCanvasWidth;
            const scaleYRatio = height / areaCanvasHeight;
            
            radiusX = Math.max(1, Math.round(zoomEraserSize * scaleXRatio / scale));
            radiusY = Math.max(1, Math.round(zoomEraserSize * scaleYRatio / scale));
        }

        // Стираем область вокруг точки
        for (let dy = -radiusY; dy <= radiusY; dy++) {
            for (let dx = -radiusX; dx <= radiusX; dx++) {
                
                let shouldErase = false;
                if (lockProportions) {
                    // Круг для пропорционального режима
                    shouldErase = (dx * dx + dy * dy <= radiusX * radiusX);
                } else {
                    // Эллипс для непропорционального режима
                    shouldErase = ((dx * dx) / (radiusX * radiusX) + (dy * dy) / (radiusY * radiusY) <= 1);
                }
                
                if (shouldErase) {
                    const imageX = imageCenter.x + dx;
                    const imageY = imageCenter.y + dy;
                    
                    // Проверяем, не обрабатывали ли уже этот пиксель
                    const pixelKey = `${imageX},${imageY}`;
                    if (processedPixels.has(pixelKey)) continue;
                    
                    if (imageX >= 0 && imageX < editedImageData.width && 
                        imageY >= 0 && imageY < editedImageData.height) {
                        
                        const index = (imageY * editedImageData.width + imageX) * 4;
                        editedImageData.data[index] = 255;
                        editedImageData.data[index + 1] = 255;
                        editedImageData.data[index + 2] = 255;
                        editedImageData.data[index + 3] = 255;
                        pixelsErased++;
                        processedPixels.add(pixelKey);
                    }
                }
            }
        }
    }
    
    return pixelsErased;
}

	// Функция отрисовки предпросмотра стирания
function drawZoomErasePreview() {
    if (zoomErasePoints.length === 0) return;
    
    const lockProportions = document.getElementById('lockProportions').checked;
    
    zoomCtx.save();
    zoomCtx.globalCompositeOperation = 'source-over';
    zoomCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
    zoomCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    
    // ФИКС: всегда используем круглую форму для предсказуемости
    const visibleRadius = getZoomEraserRadius();
    zoomCtx.lineWidth = visibleRadius * 2;
    zoomCtx.lineCap = 'round';
    zoomCtx.lineJoin = 'round';
    const offsetX = -2;
    const offsetY = -2;
    
    if (zoomErasePoints.length === 1) {
        // Одна точка - просто круг
        const point = zoomErasePoints[0];
        zoomCtx.beginPath();
        zoomCtx.arc(point.x + offsetX, point.y + offsetY, visibleRadius, 0, Math.PI * 2);
        zoomCtx.fill();
    } else {
        // Несколько точек - непрерывная линия с закругленными концами
        zoomCtx.beginPath();
        zoomCtx.moveTo(zoomErasePoints[0].x + offsetX, zoomErasePoints[0].y + offsetY);
        for (let i = 1; i < zoomErasePoints.length; i++) {
            zoomCtx.lineTo(zoomErasePoints[i].x + offsetX, zoomErasePoints[i].y + offsetY);
        }
        zoomCtx.stroke();
    }
    
    zoomCtx.restore();
}

    // Обработчики для режима ластика в зуме
    function startZoomErase(canvasX, canvasY) {
        isZoomErasing = true;
        zoomErasePoints = [{x: canvasX, y: canvasY}];
		saveToHistory();
        redrawZoomedContent();
        drawZoomErasePreview();
    }

    function continueZoomErase(canvasX, canvasY) {
        if (!isZoomErasing) return;
        
        const now = Date.now();
        if (now - zoomLastEraseTime < ZOOM_ERASE_THROTTLE) return;
        zoomLastEraseTime = now;
        
        zoomErasePoints.push({x: canvasX, y: canvasY});
        redrawZoomedContent();
        drawZoomErasePreview();
    }

    function finishZoomErase() {
        if (isZoomErasing) {
            isZoomErasing = false;
            
            if (zoomErasePoints.length > 0) {
                const pixelsErased = applyZoomEraseToImage();
                if (pixelsErased > 0) {
                    updateStatus(`В зуме стерто пикселей: ${pixelsErased} (история: ${eraseHistory.length}/${MAX_HISTORY_SIZE})`, 'success');
                    updateEditedImageDisplay();
                    redrawImageWithCrosshair();
                }
            }
            
            zoomErasePoints = [];
            redrawZoomedContent();
        }
    }

    // Функция перерисовки содержимого зума
function redrawZoomedContent() {
    zoomCtx.fillStyle = 'white';
    zoomCtx.fillRect(0, 0, zoomedCanvas.width, zoomedCanvas.height);
    
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    
    const sheetScaleX = zoomedCanvas.width / sheetWidth;
    const sheetScaleY = zoomedCanvas.height / sheetHeight;
    const sheetScale = Math.min(sheetScaleX, sheetScaleY);
    
    const sheetCanvasWidth = sheetWidth * sheetScale;
    const sheetCanvasHeight = sheetHeight * sheetScale;
    const sheetCanvasX = (zoomedCanvas.width - sheetCanvasWidth) / 2;
    const sheetCanvasY = (zoomedCanvas.height - sheetCanvasHeight) / 2;
    
    zoomCtx.save();
    zoomCtx.translate(translateX, translateY);
    zoomCtx.scale(scale, scale);
    

    
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    const areaScaleX = sheetCanvasWidth / sheetWidth;
    const areaScaleY = sheetCanvasHeight / sheetHeight;
    
    const areaCanvasX = sheetCanvasX + (offsetX * areaScaleX);
    const areaCanvasY = sheetCanvasY + sheetCanvasHeight - (offsetY * areaScaleY) - (areaHeight * areaScaleY);
    const areaCanvasWidth = areaWidth * areaScaleX;
    const areaCanvasHeight = areaHeight * areaScaleY;
    
    zoomCtx.save();
    zoomCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
    zoomCtx.rotate(rotation * Math.PI / 180);
    
    if (isSvgFile) {
            const width = svgPaths.width;
            const height = svgPaths.height;
            
            const imageRatio = width / height;
            const areaRatio = areaWidth / areaHeight;
            
            let drawWidth, drawHeight;
            
            if (areaRatio > imageRatio) {
                drawHeight = areaCanvasHeight;
                drawWidth = drawHeight * imageRatio;
            } else {
                drawWidth = areaCanvasWidth;
                drawHeight = drawWidth / imageRatio;
            }
            
            zoomCtx.scale(drawWidth / width, drawHeight / height);
            zoomCtx.translate(-width / 2, -height / 2);
            
            zoomCtx.strokeStyle = 'black';
            zoomCtx.fillStyle = 'black';
            zoomCtx.lineWidth = 2;
            
            for (const svgPath of svgPaths.paths) {
                try {
                    const pathData = parseSvgPath(svgPath.d);
                    
                    for (const path of pathData) {
                        if (path.length < 2) continue;
                        
                        let transformedPath = path;
                        if (svgPath.transform) {
                            transformedPath = applyTransformationToPath(path, svgPath.transform);
                        }
                        
                        zoomCtx.beginPath();
                        zoomCtx.moveTo(transformedPath[0].x, transformedPath[0].y);
                        
                        for (let i = 1; i < transformedPath.length; i++) {
                            zoomCtx.lineTo(transformedPath[i].x, transformedPath[i].y);
                        }
                        
                        zoomCtx.stroke();
                    }
                } catch (e) {
                    console.warn('Ошибка отрисовки SVG пути в зуме:', e);
                }
            }
    } else {
        const width = originalImage.width;
        const height = originalImage.height;
        
        const imageRatio = width / height;
        const areaRatio = areaWidth / areaHeight;
        
        let drawWidth, drawHeight;
        
        // ДОБАВЛЯЕМ ПРОВЕРКУ ГАЛОЧКИ ПРОПОРЦИЙ
        const lockProportions = document.getElementById('lockProportions').checked;
        
        if (lockProportions) {
            // СОХРАНЯЕМ ПРОПОРЦИИ
            if (areaRatio > imageRatio) {
                drawHeight = areaCanvasHeight;
                drawWidth = drawHeight * imageRatio;
            } else {
                drawWidth = areaCanvasWidth;
                drawHeight = drawWidth / imageRatio;
            }
        } else {
            // РАСТЯГИВАЕМ БЕЗ ПРОПОРЦИЙ
            drawWidth = areaCanvasWidth;
            drawHeight = areaCanvasHeight;
        }
        
        if (editedImageData) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.putImageData(editedImageData, 0, 0);
            zoomCtx.drawImage(tempCanvas, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
        } else {
            zoomCtx.drawImage(originalImage, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
        }
    }
    
	zoomCtx.restore();
	
	zoomCtx.strokeStyle = 'green';
    zoomCtx.lineWidth = 2;
    zoomCtx.strokeRect(sheetCanvasX, sheetCanvasY, sheetCanvasWidth, sheetCanvasHeight);
        if (showCrosshair.checked) {
            const startX = parseInt(startXInput.value);
            const startY = parseInt(startYInput.value);
            
            const crossX = sheetCanvasX + (startX * areaScaleX);
            const crossY = sheetCanvasY + sheetCanvasHeight - (startY * areaScaleY);
            
            zoomCtx.save();
            zoomCtx.strokeStyle = '#ff0000';
            zoomCtx.lineWidth = 3;
            zoomCtx.setLineDash([]);
            
            zoomCtx.beginPath();
            zoomCtx.arc(crossX, crossY, 12, 0, Math.PI * 2);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.moveTo(crossX - 20, crossY);
            zoomCtx.lineTo(crossX - 10, crossY);
            zoomCtx.moveTo(crossX + 10, crossY);
            zoomCtx.lineTo(crossX + 20, crossY);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.moveTo(crossX, crossY - 20);
            zoomCtx.lineTo(crossX, crossY - 10);
            zoomCtx.moveTo(crossX, crossY + 10);
            zoomCtx.lineTo(crossX, crossY + 20);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.arc(crossX, crossY, 2, 0, Math.PI * 2);
            zoomCtx.fillStyle = '#ff0000';
            zoomCtx.fill();
            
			zoomCtx.restore();
        }
        
        zoomCtx.restore();
    }

    // КНОПКА ЛАСТИКА ДЛЯ ЗУМА
    const eraserBtn = document.createElement('button');
    eraserBtn.textContent = '🧽 Ластик';
    eraserBtn.style.cssText = `
        position: fixed;
        top: 70px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        border: 2px solid #666;
        padding: 8px 12px;
        border-radius: 20px;
        cursor: pointer;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
        transition: all 0.3s ease;
    `;

    // КНОПКА ОТМЕНЫ
    const undoBtn = document.createElement('button');
    undoBtn.textContent = '↶ Отмена';
    undoBtn.style.cssText = `
        position: fixed;
        top: 120px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        border: 2px solid #666;
        padding: 8px 12px;
        border-radius: 20px;
        cursor: pointer;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 14px;
        transition: all 0.3s ease;
    `;
	
    // ПОЛЗУНОК РАЗМЕРА ЛАСТИКА
    const eraserSizeContainer = document.createElement('div');
    eraserSizeContainer.style.cssText = `
        position: fixed;
        top: 170px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        border: 2px solid #666;
        padding: 12px 16px;
        border-radius: 20px;
        z-index: 10001;
        font-family: Arial, sans-serif;
        font-size: 12px;
        min-width: 150px;
        display: ${isZoomEraserMode ? 'block' : 'none'};
    `;

    const eraserSizeLabel = document.createElement('div');
    eraserSizeLabel.textContent = 'Размер ластика:';
    eraserSizeLabel.style.cssText = `
        margin-bottom: 8px;
        font-weight: bold;
        text-align: center;
    `;

    const eraserSizeSlider = document.createElement('input');
    eraserSizeSlider.type = 'range';
    eraserSizeSlider.min = '5';
    eraserSizeSlider.max = '100';
    eraserSizeSlider.step = '1';
    eraserSizeSlider.value = zoomEraserSize;
    eraserSizeSlider.style.cssText = `
        width: 100%;
        margin-bottom: 8px;
        cursor: pointer;
    `;

    const eraserSizeValue = document.createElement('div');
    eraserSizeValue.textContent = zoomEraserSize + 'px';
    eraserSizeValue.style.cssText = `
        text-align: center;
        font-size: 11px;
        color: #ccc;
    `;

    eraserSizeContainer.appendChild(eraserSizeLabel);
    eraserSizeContainer.appendChild(eraserSizeSlider);
    eraserSizeContainer.appendChild(eraserSizeValue);

    // Обработчик изменения размера ластика
    eraserSizeSlider.addEventListener('input', function() {
        zoomEraserSize = parseInt(this.value);
        updateEraserSizeDisplay();
        updateStatus(`Размер ластика изменен: ${zoomEraserSize}px`, 'info');
    });

    function updateEraserButton() {
        if (isZoomEraserMode) {
            eraserBtn.style.background = '#007cba';
            eraserBtn.style.borderColor = '#005a87';
            eraserBtn.style.fontWeight = 'bold';
            eraserBtn.textContent = '🧽 Ластик ВКЛ';
            eraserSizeContainer.style.display = 'block';
            updateEraserCursor();
        } else {
            eraserBtn.style.background = 'rgba(0,0,0,0.7)';
            eraserBtn.style.borderColor = '#666';
            eraserBtn.style.fontWeight = 'normal';
            eraserBtn.textContent = '🧽 Ластик';
            eraserSizeContainer.style.display = 'none';
            zoomedCanvas.style.cursor = 'default';
        }
    }

    eraserBtn.addEventListener('click', function() {
        isZoomEraserMode = !isZoomEraserMode;
        updateEraserButton();
        
        if (isZoomEraserMode) {
            updateStatus(`Режим ластика в зуме включен (размер: ${zoomEraserSize}px) - зажмите ЛКМ для стирания`, 'success');
        } else {
            updateStatus('Режим ластика в зуме выключен', 'success');
        }
    });

    undoBtn.addEventListener('click', function() {
        undoLastErase();
    });

    // ОБРАБОТЧИКИ СОБЫТИЙ
    zoomedCanvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        e.stopPropagation();
        
        const rect = zoomedCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        const worldX = (mouseX - translateX) / scale;
        const worldY = (mouseY - translateY) / scale;
        
        const zoomStep = 0.1;
        
        if (e.deltaY < 0) {
            scale = Math.min(5, scale * (1 + zoomStep));
        } else {
            scale = Math.max(0.3, scale * (1 - zoomStep));
        }
        
        translateX = mouseX - worldX * scale;
        translateY = mouseY - worldY * scale;
        
        redrawZoomedContent();
        updateScaleIndicator();
    });
    
    zoomedCanvas.addEventListener('mousemove', function(e) {
        const rect = zoomedCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        
        if (isZoomEraserMode) {
            if (isZoomErasing) {
                continueZoomErase(mouseX, mouseY);
            }
        } else if (!isDragging) {
            zoomedCanvas.style.cursor = 'default';
        }
    });

    zoomedCanvas.addEventListener('mousedown', function(e) {
        if (e.button === 0) {
            if (isZoomEraserMode) {
                const rect = zoomedCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                startZoomErase(mouseX, mouseY);
            } else {
                isDragging = true;
                zoomedCanvas.style.cursor = 'grabbing';
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
            e.preventDefault();
        }
    });
    
    zoomedCanvas.addEventListener('mouseup', function() {
        if (isZoomEraserMode) {
            finishZoomErase();
        } else {
            isDragging = false;
            zoomedCanvas.style.cursor = 'default';
        }
    });
    
    zoomedCanvas.addEventListener('mouseleave', function() {
        if (isZoomEraserMode) {
            finishZoomErase();
        }
        if (!isZoomEraserMode) {
            zoomedCanvas.style.cursor = 'default';
        }
    });

    function handleMouseMove(e) {
        if (isDragging && !isZoomEraserMode) {
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            
            translateX += deltaX;
            translateY += deltaY;
            
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            redrawZoomedContent();
        }
    }
    
    function handleMouseUp() {
        isDragging = false;
        if (!isZoomEraserMode) {
            zoomedCanvas.style.cursor = 'default';
        }
    }
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    // UI ЭЛЕМЕНТЫ
    const scaleIndicator = document.createElement('div');
    scaleIndicator.style.cssText = `
        position: fixed;
        top: 20px;
        left: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 20px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 10001;
        pointer-events: none;
    `;
    
    function updateScaleIndicator() {
        scaleIndicator.textContent = `Масштаб: ${Math.round(scale * 100)}%`;
    }
    
    const resetBtn = document.createElement('button');
    resetBtn.textContent = '✕ Выход';
    resetBtn.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0,0,0,0.7);
        color: white;
        border: none;
        padding: 8px 12px;
        border-radius: 20px;
        cursor: pointer;
        z-index: 10001;
    `;
    resetBtn.addEventListener('click', function() {
		closeZoom();
    });
    
	const controlsHint = document.createElement('div');
	controlsHint.style.cssText = `
		position: fixed; 
		bottom: 20px; 
		left: 20px; 
		background: rgba(0,0,0,0.7); 
		color: white; 
		padding: 8px 16px; 
		border-radius: 20px; 
		font-size: 12px; 
		z-index: 10001; 
		white-space: pre-line; 
		pointer-events: none;
		text-align: right;
	`;
    controlsHint.textContent = 'Колесико мыши - масштаб\nПеретаскивание - перемещение\nESC - отмена ластика/выход';
    
    // ФУНКЦИЯ ЗАКРЫТИЯ
    function closeZoom() {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        document.removeEventListener('keydown', handleKeydown);
        document.body.removeChild(zoomOverlay);
        
        if (eraseHistory.length > 0) {
            updateStatus('Пересчет векторов после стирания...', 'success');
            processAndDrawVectors();
        } else {
            updateStatus('Зум закрыт (изменений не было)', 'success');
        }
    }
    
	function handleKeydown(e) {
		if (e.key === 'Escape') {
			if (isZoomEraserMode) {
				// Первое нажатие - выключаем ластик
				isZoomEraserMode = false;
				updateEraserButton();
				updateStatus('Режим ластика в зуме выключен', 'success');
			} else {
				// Второе нажатие - закрываем зум
				closeZoom();
			}
			e.preventDefault();
		}
		if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
			e.preventDefault();
			undoLastErase();
		}
	}
    
    document.addEventListener('keydown', handleKeydown);
    
    // СБОРКА И ИНИЦИАЛИЗАЦИЯ
    zoomContainer.appendChild(zoomedCanvas);
    zoomOverlay.appendChild(zoomContainer);
    zoomOverlay.appendChild(scaleIndicator);
    zoomOverlay.appendChild(resetBtn);
    zoomOverlay.appendChild(eraserBtn);
    zoomOverlay.appendChild(undoBtn);
    zoomOverlay.appendChild(eraserSizeContainer);
    zoomOverlay.appendChild(controlsHint);
    document.body.appendChild(zoomOverlay);
    
    if (!originalImageData && originalImage && !isSvgFile) {
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalImage.width;
        tempCanvas.height = originalImage.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(originalImage, 0, 0);
        originalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        if (!editedImageData) {
            editedImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        }
    }
    
    updateEraserButton();
    updateUndoButton();
    updateEraserSizeDisplay();
    redrawZoomedContent();
    updateScaleIndicator();
    
    zoomOverlay.focus();
}


function openVectorZoom() {
    if (document.getElementById('loadingIcon').style.display === 'block') {
        updateStatus('Дождитесь завершения обработки векторов', 'error');
        return;
    }
    const zoomOverlay = document.createElement('div');
    zoomOverlay.style.cssText = `
        position: fixed; top: 0; left: 0;
        width: 100vw; height: 100vh;
        background: rgba(0,0,0,0.95);
        z-index: 10000; display: flex;
        align-items: center; justify-content: center;
        cursor: default; overflow: hidden;
    `;
    
    const zoomContainer = document.createElement('div');
    zoomContainer.style.cssText = `
        position: relative; display: inline-block;
        width: ${window.innerWidth}px; height: ${window.innerHeight}px;
    `;
    
    const zoomedCanvas = document.createElement('canvas');
    zoomedCanvas.width = window.innerWidth;
    zoomedCanvas.height = window.innerHeight;
    zoomedCanvas.style.cssText = `
        border: 2px solid #444; border-radius: 8px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        background: white; cursor: default; display: block;
        position: absolute; top: 0; left: 0;
    `;
    
    const zoomCtx = zoomedCanvas.getContext('2d');

    // СОЗДАЕМ ГЛУБОКИЕ КОПИИ при входе в зум
    let zoomFilteredPaths = JSON.parse(JSON.stringify(filteredPaths));
    let zoomVectorPaths = JSON.parse(JSON.stringify(vectorPaths));

    // Переменные для зума и управления
    let scale = 1;
    let translateX = 0;
    let translateY = 0;
    let isDragging = false;
    let lastMouseX = 0;
    let lastMouseY = 0;

    let isZoomEraserMode = false;
    let isZoomErasing = false;
    let zoomErasePoints = [];
    let zoomLastEraseTime = 0;
    const ZOOM_ERASE_THROTTLE = 50;
    
    // История для работы ТОЛЬКО с копией
    let eraseHistory = [];
    const MAX_HISTORY_SIZE = 20;
    let hasChanges = false;
    
    let zoomEraserSize = 20;

    // Функции для работы с копией в зуме
    function saveToHistory() {
        const currentState = {
            filteredPaths: JSON.parse(JSON.stringify(zoomFilteredPaths)),
            vectorPaths: JSON.parse(JSON.stringify(zoomVectorPaths)),
            scale: scale, 
            translateX: translateX, 
            translateY: translateY
        };
        eraseHistory.push(currentState);
        if (eraseHistory.length > MAX_HISTORY_SIZE) {
            eraseHistory.shift();
        }
        hasChanges = true;
        updateUndoButton();
    }

    function undoLastErase() {
        if (eraseHistory.length === 0) return;
        
        const previousState = eraseHistory.pop();
        if (previousState) {
            // Восстанавливаем ТОЛЬКО копию
            zoomFilteredPaths = JSON.parse(JSON.stringify(previousState.filteredPaths));
            zoomVectorPaths = JSON.parse(JSON.stringify(previousState.vectorPaths));
            scale = previousState.scale;
            translateX = previousState.translateX;
            translateY = previousState.translateY;
            
            redrawZoomedContent();
            updateScaleIndicator();
            
            if (eraseHistory.length === 0) {
                hasChanges = false;
            }
        }
        updateUndoButton();
    }

    function updateUndoButton() {
        undoBtn.disabled = eraseHistory.length === 0;
        if (eraseHistory.length === 0) {
            undoBtn.style.background = 'rgba(0,0,0,0.3)';
            undoBtn.style.color = '#888';
        } else {
            undoBtn.style.background = 'rgba(0,0,0,0.7)';
            undoBtn.style.color = 'white';
        }
    }

    function getZoomEraserRadius() { 
        return zoomEraserSize; 
    }

    function updateEraserCursor() {
        if (isZoomEraserMode) {
            const cursorSize = Math.max(20, zoomEraserSize * 2);
            const cursorSVG = `data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="${cursorSize}" height="${cursorSize}" viewBox="0 0 ${cursorSize} ${cursorSize}"><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="${zoomEraserSize}" fill="none" stroke="red" stroke-width="1"/><circle cx="${cursorSize/2}" cy="${cursorSize/2}" r="2" fill="red"/></svg>`;
            zoomedCanvas.style.cursor = `url('${cursorSVG}') ${cursorSize/2} ${cursorSize/2}, auto`;
        } else {
            zoomedCanvas.style.cursor = isDragging ? 'grabbing' : 'grab';
        }
    }

    function updateEraserSizeDisplay() {
        eraserSizeValue.textContent = zoomEraserSize + 'px';
        eraserSizeSlider.value = zoomEraserSize;
        if (isZoomEraserMode) updateEraserCursor();
        if (isZoomErasing) { 
            redrawZoomedContent(); 
            drawZoomErasePreview(); 
        }
    }

function applyZoomEraseToVectors() {
    if (zoomErasePoints.length === 0) return 0;
    
    saveToHistory();
    
    const maskCanvas = document.createElement('canvas');
    maskCanvas.width = zoomedCanvas.width;
    maskCanvas.height = zoomedCanvas.height;
    const maskCtx = maskCanvas.getContext('2d');
    
    maskCtx.fillStyle = 'black';
    maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
    
    maskCtx.strokeStyle = 'white';
    maskCtx.fillStyle = 'white';
    maskCtx.lineWidth = zoomEraserSize * 2;
    maskCtx.lineCap = 'round';
    maskCtx.lineJoin = 'round';
    
    if (zoomErasePoints.length === 1) {
        const point = zoomErasePoints[0];
        maskCtx.beginPath();
        maskCtx.arc(point.x, point.y, zoomEraserSize, 0, Math.PI * 2);
        maskCtx.fill();
    } else {
        maskCtx.beginPath();
        maskCtx.moveTo(zoomErasePoints[0].x, zoomErasePoints[0].y);
        for (let i = 1; i < zoomErasePoints.length; i++) {
            maskCtx.lineTo(zoomErasePoints[i].x, zoomErasePoints[i].y);
        }
        maskCtx.stroke();
        
        maskCtx.beginPath();
        maskCtx.arc(zoomErasePoints[0].x, zoomErasePoints[0].y, zoomEraserSize, 0, Math.PI * 2);
        maskCtx.arc(zoomErasePoints[zoomErasePoints.length - 1].x, zoomErasePoints[zoomErasePoints.length - 1].y, zoomEraserSize, 0, Math.PI * 2);
        maskCtx.fill();
    }
    
    const maskData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
    
    // Функция проверки попадания точки в область стирания
    function isPointInEraseArea(canvasX, canvasY) {
        if (canvasX < 0 || canvasX >= maskCanvas.width || 
            canvasY < 0 || canvasY >= maskCanvas.height) {
            return false;
        }
        const index = (Math.floor(canvasY) * maskCanvas.width + Math.floor(canvasX)) * 4;
        return maskData.data[index] === 255;
    }

    // Функция нахождения ТОЧНОЙ точки пересечения отрезка с границей маски
    function findIntersectionPoint(p1, p2, steps = 20) {
        const canvasP1 = vectorToCanvasCoords(p1.x, p1.y);
        const canvasP2 = vectorToCanvasCoords(p2.x, p2.y);
        
        const p1Erased = isPointInEraseArea(canvasP1.x, canvasP1.y);
        const p2Erased = isPointInEraseArea(canvasP2.x, canvasP2.y);
        
        // Если оба конца в одной зоне - пересечений нет
        if (p1Erased === p2Erased) return null;
        
        // Бинарный поиск точки пересечения
        let low = 0, high = 1;
        let lowPoint = p1, highPoint = p2;
        let lowErased = p1Erased, highErased = p2Erased;
        
        for (let i = 0; i < steps; i++) {
            const mid = (low + high) / 2;
            const midPoint = {
                x: p1.x + (p2.x - p1.x) * mid,
                y: p1.y + (p2.y - p1.y) * mid
            };
            const midCanvas = vectorToCanvasCoords(midPoint.x, midPoint.y);
            const midErased = isPointInEraseArea(midCanvas.x, midCanvas.y);
            
            if (midErased === lowErased) {
                low = mid;
                lowPoint = midPoint;
                lowErased = midErased;
            } else {
                high = mid;
                highPoint = midPoint;
                highErased = midErased;
            }
        }
        
        // Возвращаем точку на границе (ближе к нестираемой области)
        return lowErased ? lowPoint : highPoint;
    }

    // НОВЫЙ АЛГОРИТМ РАЗБИЕНИЯ ПУТЕЙ
    let totalPathsModified = 0;
    const newFilteredPaths = [];
    
    for (let pathIndex = 0; pathIndex < zoomFilteredPaths.length; pathIndex++) {
        const originalPath = zoomFilteredPaths[pathIndex];
        
        if (originalPath.length < 2) {
            newFilteredPaths.push(originalPath);
            continue;
        }
        
        const pathSegments = [];
        let currentSegment = [];
        let hasIntersections = false;
        
        // Проверяем весь путь на пересечения
        for (let i = 0; i < originalPath.length; i++) {
            const point = originalPath[i];
            const canvasCoords = vectorToCanvasCoords(point.x, point.y);
            const pointErased = isPointInEraseArea(canvasCoords.x, canvasCoords.y);
            
            if (i === 0) {
                // Первая точка - просто добавляем
                currentSegment.push(point);
            } else {
                const prevPoint = originalPath[i-1];
                const prevCanvasCoords = vectorToCanvasCoords(prevPoint.x, prevPoint.y);
                const prevErased = isPointInEraseArea(prevCanvasCoords.x, prevCanvasCoords.y);
                
                if (prevErased !== pointErased) {
                    // Найдено пересечение границы - находим точную точку пересечения
                    hasIntersections = true;
                    const intersection = findIntersectionPoint(prevPoint, point);
                    
                    if (intersection) {
                        // Завершаем текущий сегмент до точки пересечения
                        currentSegment.push(intersection);
                        if (currentSegment.length >= 2) {
                            pathSegments.push([...currentSegment]);
                        }
                        
                        // Начинаем новый сегмент с точки пересечения
                        currentSegment = [intersection];
                        
                        // Добавляем текущую точку если она не в зоне стирания
                        if (!pointErased) {
                            currentSegment.push(point);
                        }
                    } else {
                        // Если не нашли пересечение, продолжаем текущий сегмент
                        currentSegment.push(point);
                    }
                } else if (pointErased) {
                    // Обе точки в зоне стирания - пропускаем точку
                    // Но завершаем текущий сегмент если он есть
                    if (currentSegment.length >= 2) {
                        pathSegments.push([...currentSegment]);
                    }
                    currentSegment = [];
                } else {
                    // Обе точки НЕ в зоне стирания - продолжаем сегмент
                    currentSegment.push(point);
                }
            }
        }
        
        // Добавляем последний сегмент если он есть
        if (currentSegment.length >= 2) {
            pathSegments.push([...currentSegment]);
        }
        
        if (hasIntersections && pathSegments.length > 0) {
            totalPathsModified++;
            newFilteredPaths.push(...pathSegments);
        } else if (!hasIntersections) {
            // Проверяем, не находится ли весь путь в зоне стирания
            let allPointsErased = true;
            for (let i = 0; i < originalPath.length; i++) {
                const point = originalPath[i];
                const canvasCoords = vectorToCanvasCoords(point.x, point.y);
                if (!isPointInEraseArea(canvasCoords.x, canvasCoords.y)) {
                    allPointsErased = false;
                    break;
                }
            }
            
            if (!allPointsErased) {
                newFilteredPaths.push(originalPath);
            } else {
                totalPathsModified++; // Весь путь удален
            }
        }
    }
    
    // Обновляем КОПИЮ filteredPaths
    zoomFilteredPaths.length = 0;
    zoomFilteredPaths.push(...newFilteredPaths);
    
    return totalPathsModified;
}

function vectorToCanvasCoords(vectorX, vectorY) {
    const areaWidth = parseInt(areaWidthInput.value);
    const areaHeight = parseInt(areaHeightInput.value);
    const sheetWidth = parseInt(sheetWidthInput.value);
    const sheetHeight = parseInt(sheetHeightInput.value);
    const offsetX = parseFloat(offsetXInput.value);
    const offsetY = parseFloat(offsetYInput.value);
    const rotation = parseFloat(rotationInput.value);
    
    const width = isSvgFile ? svgPaths.width : originalImage.width;
    const height = isSvgFile ? svgPaths.height : originalImage.height;
    
    const sheetScaleX = zoomedCanvas.width / sheetWidth;
    const sheetScaleY = zoomedCanvas.height / sheetHeight;
    const sheetScale = Math.min(sheetScaleX, sheetScaleY);
    
    const sheetCanvasWidth = sheetWidth * sheetScale;
    const sheetCanvasHeight = sheetHeight * sheetScale;
    const sheetCanvasX = (zoomedCanvas.width - sheetCanvasWidth) / 2;
    const sheetCanvasY = (zoomedCanvas.height - sheetCanvasHeight) / 2;
    
    const areaScaleX = sheetCanvasWidth / sheetWidth;
    const areaScaleY = sheetCanvasHeight / sheetHeight;
    
    const areaCanvasX = sheetCanvasX + (offsetX * areaScaleX);
    const areaCanvasY = sheetCanvasY + sheetCanvasHeight - (offsetY * areaScaleY) - (areaHeight * areaScaleY);
    const areaCanvasWidth = areaWidth * areaScaleX;
    const areaCanvasHeight = areaHeight * areaScaleY;
    
    const imageRatio = width / height;
    const areaRatio = areaWidth / areaHeight;
    
    const lockProportions = document.getElementById('lockProportions').checked;
    
    let drawWidth, drawHeight;
    
    if (lockProportions) {
        // СОХРАНЯЕМ ПРОПОРЦИИ
        if (areaRatio > imageRatio) {
            drawHeight = areaCanvasHeight;
            drawWidth = drawHeight * imageRatio;
        } else {
            drawWidth = areaCanvasWidth;
            drawHeight = drawWidth / imageRatio;
        }
    } else {
        // РАСТЯГИВАЕМ БЕЗ ПРОПОРЦИЙ
        drawWidth = areaCanvasWidth;
        drawHeight = areaCanvasHeight;
    }
    
    const scaleXDraw = drawWidth / width;
    const scaleYDraw = drawHeight / height;
    
    let relativeX = (vectorX - width / 2) * scaleXDraw;
    let relativeY = (vectorY - height / 2) * scaleYDraw;
    
    const rad = rotation * Math.PI / 180;
    const cos = Math.cos(rad);
    const sin = Math.sin(rad);
    
    const rotatedX = relativeX * cos - relativeY * sin;
    const rotatedY = relativeX * sin + relativeY * cos;
    
    let canvasX = rotatedX + (areaCanvasX + areaCanvasWidth / 2) + 2;
    let canvasY = rotatedY + (areaCanvasY + areaCanvasHeight / 2) + 2;
    
    canvasX = canvasX * scale + translateX;
    canvasY = canvasY * scale + translateY;
    
    return { 
        x: Math.round(canvasX), 
        y: Math.round(canvasY) 
    };
}


    function drawZoomErasePreview() {
        if (zoomErasePoints.length === 0) return;
        
        zoomCtx.save();
        zoomCtx.globalCompositeOperation = 'source-over';
        zoomCtx.strokeStyle = 'rgba(255, 0, 0, 0.3)';
        zoomCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        
        const visibleRadius = getZoomEraserRadius();
        zoomCtx.lineWidth = visibleRadius * 2;
        zoomCtx.lineCap = 'round';
        zoomCtx.lineJoin = 'round';
        
		const offsetX = -2;
		const offsetY = -2;
		
		if (zoomErasePoints.length === 1) {
			// Одна точка - просто круг
			const point = zoomErasePoints[0];
			zoomCtx.beginPath();
			zoomCtx.arc(point.x + offsetX, point.y + offsetY, visibleRadius, 0, Math.PI * 2);
			zoomCtx.fill();
		} else {
			// Несколько точек - непрерывная линия с закругленными концами
			zoomCtx.beginPath();
			zoomCtx.moveTo(zoomErasePoints[0].x + offsetX, zoomErasePoints[0].y + offsetY);
			for (let i = 1; i < zoomErasePoints.length; i++) {
				zoomCtx.lineTo(zoomErasePoints[i].x + offsetX, zoomErasePoints[i].y + offsetY);
			}
			zoomCtx.stroke();
        }
        
        zoomCtx.restore();
    }

    function startZoomErase(canvasX, canvasY) {
        isZoomErasing = true;
        zoomErasePoints = [{x: canvasX, y: canvasY}];
        redrawZoomedContent();
        drawZoomErasePreview();
    }

    function continueZoomErase(canvasX, canvasY) {
        if (!isZoomErasing) return;
        
        const now = Date.now();
        if (now - zoomLastEraseTime < ZOOM_ERASE_THROTTLE) return;
        zoomLastEraseTime = now;
        
        zoomErasePoints.push({x: canvasX, y: canvasY});
        redrawZoomedContent();
        drawZoomErasePreview();
    }

    function finishZoomErase() {
        if (isZoomErasing) {
            isZoomErasing = false;
            if (zoomErasePoints.length > 0) {
                const pathsModified = applyZoomEraseToVectors();
                if (pathsModified > 0) {
                    updateStatus(`Удалено сегментов: ${pathsModified}`, 'success');
                }
            }
            zoomErasePoints = [];
            redrawZoomedContent();
        }
    }

    function redrawZoomedContent() {
        zoomCtx.fillStyle = 'white';
        zoomCtx.fillRect(0, 0, zoomedCanvas.width, zoomedCanvas.height);
        
        const sheetWidth = parseInt(sheetWidthInput.value);
        const sheetHeight = parseInt(sheetHeightInput.value);
        
        const sheetScaleX = zoomedCanvas.width / sheetWidth;
        const sheetScaleY = zoomedCanvas.height / sheetHeight;
        const sheetScale = Math.min(sheetScaleX, sheetScaleY);
        
        const sheetCanvasWidth = sheetWidth * sheetScale;
        const sheetCanvasHeight = sheetHeight * sheetScale;
        const sheetCanvasX = (zoomedCanvas.width - sheetCanvasWidth) / 2;
        const sheetCanvasY = (zoomedCanvas.height - sheetCanvasHeight) / 2;
        
        zoomCtx.save();
        zoomCtx.translate(translateX, translateY);
        zoomCtx.scale(scale, scale);
        
        zoomCtx.strokeStyle = 'green';
        zoomCtx.lineWidth = 2;
        zoomCtx.strokeRect(sheetCanvasX, sheetCanvasY, sheetCanvasWidth, sheetCanvasHeight);
        
        const areaWidth = parseInt(areaWidthInput.value);
        const areaHeight = parseInt(areaHeightInput.value);
        const offsetX = parseFloat(offsetXInput.value);
        const offsetY = parseFloat(offsetYInput.value);
        const rotation = parseFloat(rotationInput.value);
        
        const areaScaleX = sheetCanvasWidth / sheetWidth;
        const areaScaleY = sheetCanvasHeight / sheetHeight;
        
        const areaCanvasX = sheetCanvasX + (offsetX * areaScaleX);
        const areaCanvasY = sheetCanvasY + sheetCanvasHeight - (offsetY * areaScaleY) - (areaHeight * areaScaleY);
        const areaCanvasWidth = areaWidth * areaScaleX;
        const areaCanvasHeight = areaHeight * areaScaleY;
        
        zoomCtx.save();
        zoomCtx.translate(areaCanvasX + areaCanvasWidth / 2, areaCanvasY + areaCanvasHeight / 2);
        zoomCtx.rotate(rotation * Math.PI / 180);
        
        const width = isSvgFile ? svgPaths.width : originalImage.width;
        const height = isSvgFile ? svgPaths.height : originalImage.height;
        
        const imageRatio = width / height;
        const areaRatio = areaWidth / areaHeight;
        
		const lockProportions = document.getElementById('lockProportions').checked;
		
		let drawScaleX, drawScaleY;
		
		if (lockProportions) {
			// СОХРАНЯЕМ ПРОПОРЦИИ
			if (areaRatio > imageRatio) {
				drawScaleY = areaCanvasHeight / height;
				drawScaleX = drawScaleY;
			} else {
				drawScaleX = areaCanvasWidth / width;
				drawScaleY = drawScaleX;
			}
		} else {
			// РАСТЯГИВАЕМ БЕЗ ПРОПОРЦИЙ
			drawScaleX = areaCanvasWidth / width;
			drawScaleY = areaCanvasHeight / height;
		}
        
        // Рисуем векторные пути из КОПИИ
        const lineMultiplier = 2;
        
        // Исходные пути (желтые) из копии
        zoomCtx.strokeStyle = '#ffebb8';
        zoomCtx.lineWidth = 0.5 * lineMultiplier;
        zoomCtx.lineCap = 'round';
        zoomCtx.lineJoin = 'round';
        
        for (const path of zoomVectorPaths) {
            if (path.length < 2) continue;
            zoomCtx.beginPath();
            zoomCtx.moveTo((path[0].x - width / 2) * drawScaleX, (path[0].y - height / 2) * drawScaleY);
            for (let j = 1; j < path.length; j++) {
                zoomCtx.lineTo((path[j].x - width / 2) * drawScaleX, (path[j].y - height / 2) * drawScaleY);
            }
            zoomCtx.stroke();
        }

        // Финальные пути (черные) из копии
        zoomCtx.strokeStyle = 'black';
        zoomCtx.lineWidth = 0.6 * lineMultiplier;
        
        for (const path of zoomFilteredPaths) {
            if (path.length < 2) continue;
            zoomCtx.beginPath();
            zoomCtx.moveTo((path[0].x - width / 2) * drawScaleX, (path[0].y - height / 2) * drawScaleY);
            for (let i = 1; i < path.length; i++) {
                zoomCtx.lineTo((path[i].x - width / 2) * drawScaleX, (path[i].y - height / 2) * drawScaleY);
            }
            zoomCtx.stroke();
        }

        // Удаленные пути (красные) - здесь логика может потребовать доработки
		if (showRemovedPaths && window.removedPathsForDisplay && window.removedPathsForDisplay.length > 0) {
			zoomCtx.strokeStyle = '#ff4444';
			zoomCtx.lineWidth = 1 * lineMultiplier;
			
			// Рисуем все удаленные пути из глобального массива
			for (const path of window.removedPathsForDisplay) {
				if (path.length < 2) continue;
				zoomCtx.beginPath();
				zoomCtx.moveTo((path[0].x - width / 2) * drawScaleX, (path[0].y - height / 2) * drawScaleY);
				for (let j = 1; j < path.length; j++) {
					zoomCtx.lineTo((path[j].x - width / 2) * drawScaleX, (path[j].y - height / 2) * drawScaleY);
				}
				zoomCtx.stroke();
			}
		}
        
        zoomCtx.restore();
        
        if (showCrosshair.checked) {
            const startX = parseInt(startXInput.value);
            const startY = parseInt(startYInput.value);
            const crossX = sheetCanvasX + (startX * areaScaleX);
            const crossY = sheetCanvasY + sheetCanvasHeight - (startY * areaScaleY);
            
            zoomCtx.save();
            zoomCtx.strokeStyle = '#ff0000';
            zoomCtx.lineWidth = 3;
            zoomCtx.setLineDash([]);
            
            zoomCtx.beginPath();
            zoomCtx.arc(crossX, crossY, 12, 0, Math.PI * 2);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.moveTo(crossX - 20, crossY); zoomCtx.lineTo(crossX - 10, crossY);
            zoomCtx.moveTo(crossX + 10, crossY); zoomCtx.lineTo(crossX + 20, crossY);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.moveTo(crossX, crossY - 20); zoomCtx.lineTo(crossX, crossY - 10);
            zoomCtx.moveTo(crossX, crossY + 10); zoomCtx.lineTo(crossX, crossY + 20);
            zoomCtx.stroke();
            
            zoomCtx.beginPath();
            zoomCtx.arc(crossX, crossY, 2, 0, Math.PI * 2);
            zoomCtx.fillStyle = '#ff0000';
            zoomCtx.fill();
            zoomCtx.restore();
        }
        
        zoomCtx.restore();
    }

    function updateScaleIndicator() {
        scaleIndicator.textContent = `Масштаб: ${Math.round(scale * 100)}%`;
    }

    // UI элементы (остаются без изменений)
    const scaleIndicator = document.createElement('div');
    scaleIndicator.style.cssText = `position: fixed; top: 20px; left: 20px; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 20px; font-size: 14px; z-index: 10001; pointer-events: none;`;
    
    const resetBtn = document.createElement('button');
    resetBtn.textContent = '✕ Выход';
    resetBtn.style.cssText = `position: fixed; top: 20px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: none; padding: 8px 12px; border-radius: 20px; cursor: pointer; z-index: 10001;`;
    resetBtn.addEventListener('click', function() { closeZoom(); });
    
    const eraserBtn = document.createElement('button');
    eraserBtn.textContent = '🧽 Ластик';
    eraserBtn.style.cssText = `position: fixed; top: 70px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: 2px solid #666; padding: 8px 12px; border-radius: 20px; cursor: pointer; z-index: 10001; font-size: 14px;`;
    
    const undoBtn = document.createElement('button');
    undoBtn.textContent = '↶ Отмена';
    undoBtn.style.cssText = `position: fixed; top: 120px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: 2px solid #666; padding: 8px 12px; border-radius: 20px; cursor: pointer; z-index: 10001; font-size: 14px;`;
    
    const eraserSizeContainer = document.createElement('div');
    eraserSizeContainer.style.cssText = `position: fixed; top: 170px; right: 20px; background: rgba(0,0,0,0.7); color: white; border: 2px solid #666; padding: 12px 16px; border-radius: 20px; z-index: 10001; font-size: 12px; min-width: 150px; display: none;`;
    
    const eraserSizeLabel = document.createElement('div');
    eraserSizeLabel.textContent = 'Размер ластика:';
    eraserSizeLabel.style.cssText = `margin-bottom: 8px; font-weight: bold; text-align: center;`;
    
    const eraserSizeSlider = document.createElement('input');
    eraserSizeSlider.type = 'range';
    eraserSizeSlider.min = '5';
    eraserSizeSlider.max = '100';
    eraserSizeSlider.step = '1';
    eraserSizeSlider.value = zoomEraserSize;
    eraserSizeSlider.style.cssText = `width: 100%; margin-bottom: 8px; cursor: pointer;`;
    
    const eraserSizeValue = document.createElement('div');
    eraserSizeValue.textContent = zoomEraserSize + 'px';
    eraserSizeValue.style.cssText = `text-align: center; font-size: 11px; color: #ccc;`;
    
    eraserSizeContainer.appendChild(eraserSizeLabel);
    eraserSizeContainer.appendChild(eraserSizeSlider);
    eraserSizeContainer.appendChild(eraserSizeValue);
    
    eraserSizeSlider.addEventListener('input', function() { 
        zoomEraserSize = parseInt(this.value); 
        updateEraserSizeDisplay(); 
    });
    
    function updateEraserButton() {
        if (isZoomEraserMode) {
            eraserBtn.style.background = '#007cba';
            eraserBtn.style.borderColor = '#005a87';
            eraserBtn.style.fontWeight = 'bold';
            eraserBtn.textContent = '🧽 Ластик ВКЛ';
            eraserSizeContainer.style.display = 'block';
            updateEraserCursor();
        } else {
            eraserBtn.style.background = 'rgba(0,0,0,0.7)';
            eraserBtn.style.borderColor = '#666';
            eraserBtn.style.fontWeight = 'normal';
            eraserBtn.textContent = '🧽 Ластик';
            eraserSizeContainer.style.display = 'none';
            zoomedCanvas.style.cursor = 'default';
        }
    }
    
    eraserBtn.addEventListener('click', function() {
        isZoomEraserMode = !isZoomEraserMode;
        updateEraserButton();
    });
    
    undoBtn.addEventListener('click', function() { 
        undoLastErase(); 
    });
    
    // Обработчики событий (остаются без изменений)
    zoomedCanvas.addEventListener('wheel', function(e) {
        e.preventDefault();
        e.stopPropagation();
        const rect = zoomedCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const worldX = (mouseX - translateX) / scale;
        const worldY = (mouseY - translateY) / scale;
        const zoomStep = 0.1;
        if (e.deltaY < 0) scale = Math.min(5, scale * (1 + zoomStep));
        else scale = Math.max(0.3, scale * (1 - zoomStep));
        translateX = mouseX - worldX * scale;
        translateY = mouseY - worldY * scale;
        redrawZoomedContent();
        updateScaleIndicator();
    });
    
    zoomedCanvas.addEventListener('mousemove', function(e) {
        const rect = zoomedCanvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        if (isZoomEraserMode) {
            if (isZoomErasing) continueZoomErase(mouseX, mouseY);
        } else if (!isDragging) zoomedCanvas.style.cursor = 'default';
    });
    
    zoomedCanvas.addEventListener('mousedown', function(e) {
        if (e.button === 0) {
            if (isZoomEraserMode) {
                const rect = zoomedCanvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                startZoomErase(mouseX, mouseY);
            } else {
                isDragging = true;
                zoomedCanvas.style.cursor = 'grabbing';
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
            e.preventDefault();
        }
    });
    
    zoomedCanvas.addEventListener('mouseup', function() {
        if (isZoomEraserMode) finishZoomErase();
        else { isDragging = false; zoomedCanvas.style.cursor = 'default'; }
    });
    
    zoomedCanvas.addEventListener('mouseleave', function() {
        if (isZoomEraserMode) finishZoomErase();
        if (!isZoomEraserMode) zoomedCanvas.style.cursor = 'default';
    });
    
    function handleMouseMove(e) {
        if (isDragging && !isZoomEraserMode) {
            const deltaX = e.clientX - lastMouseX;
            const deltaY = e.clientY - lastMouseY;
            translateX += deltaX;
            translateY += deltaY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            redrawZoomedContent();
        }
    }
    
    function handleMouseUp() {
        isDragging = false;
        if (!isZoomEraserMode) zoomedCanvas.style.cursor = 'default';
    }
    
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);
    
    const controlsHint = document.createElement('div');
controlsHint.style.cssText = `
    position: fixed; 
    bottom: 20px; 
    left: 20px; 
    background: rgba(0,0,0,0.7); 
    color: white; 
    padding: 8px 16px; 
    border-radius: 20px; 
    font-size: 12px; 
    z-index: 10001; 
    white-space: pre-line; 
    pointer-events: none;
    text-align: right;
`;
    controlsHint.textContent = 'Колесико мыши - масштаб\nПеретаскивание - перемещение\nESC - отмена ластика/выход';
    
    // ИЗМЕНЕННАЯ ФУНКЦИЯ ЗАКРЫТИЯ ЗУМА
    function closeZoom() {
        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        document.removeEventListener('keydown', handleKeydown);
        document.body.removeChild(zoomOverlay);
        
        // ПРИМЕНЯЕМ ИЗМЕНЕНИЯ ТОЛЬКО ЕСЛИ БЫЛИ РЕАЛЬНЫЕ ИЗМЕНЕНИЯ
        if (!undoBtn.disabled) {
            // Копируем изменения из зума в основные массивы
            filteredPaths = JSON.parse(JSON.stringify(zoomFilteredPaths));
            vectorPaths = JSON.parse(JSON.stringify(zoomVectorPaths));
            
            saveVectorSnapshot();
            updatePathInfo();
            redrawVectorCanvas();
            updateStatus('Изменения векторов применены', 'success');
        } else {
            // Просто перерисовываем без изменений
            redrawVectorCanvas();
            updateStatus('Зум закрыт (изменений не было)', 'success');
        }
    }
    
	function handleKeydown(e) {
		if (e.key === 'Escape') {
			if (isZoomEraserMode) {
				// Первое нажатие - выключаем ластик
				isZoomEraserMode = false;
				updateEraserButton();
				updateStatus('Режим ластика в зуме выключен', 'success');
			} else {
				// Второе нажатие - закрываем зум
				closeZoom();
			}
			e.preventDefault();
		}
		if ((e.ctrlKey || e.metaKey) && e.key === 'z') { 
			e.preventDefault(); 
			undoLastErase(); 
		}
	}
    
    document.addEventListener('keydown', handleKeydown);
    
    // Сборка UI
    zoomContainer.appendChild(zoomedCanvas);
    zoomOverlay.appendChild(zoomContainer);
    zoomOverlay.appendChild(scaleIndicator);
    zoomOverlay.appendChild(resetBtn);
    zoomOverlay.appendChild(eraserBtn);
    zoomOverlay.appendChild(undoBtn);
    zoomOverlay.appendChild(eraserSizeContainer);
    zoomOverlay.appendChild(controlsHint);
    document.body.appendChild(zoomOverlay);
    
    updateEraserButton();
    updateUndoButton();
    updateEraserSizeDisplay();
    redrawZoomedContent();
    updateScaleIndicator();
    zoomOverlay.focus();
}

		// DOM
		document.addEventListener('DOMContentLoaded', function() {
			// Инициализация canvas
			initCanvases();
			updateConversionMethods();
			updateStatus('Загрузите JPEG, PNG или SVG изображение', 'success');
			downloadSvgBtn.disabled = true;
			convertBtn.disabled = true;
			eraserTool.disabled = true;
			resetImageBtn.disabled = true;
			showRemovedPaths = document.getElementById('showRemovedPaths').checked;
			let eraserEnabled = false;
			let selectedPaths = new Set();
			loadLayoutState();
			updateUndoButton();
    const centerlineOptions = document.getElementById('centerlineOptions');
    const conversionMethod = document.getElementById('conversionMethod');
    if (conversionMethod.value === 'centerline') {
        centerlineOptions.style.display = 'block';
    } else {
        centerlineOptions.style.display = 'none';
    }
		document.getElementById('lockProportions').addEventListener('change', function() {
			if (originalImage || isSvgFile) {
				updateStatus('Пропорции ' + (this.checked ? 'включены' : 'выключены'), 'success');
				
				// Перерисовываем все
				if (isSvgFile) {
					displaySvg();
				} else {
					displayImage(originalImage);
				}
				
				// Пересчитываем векторы
				processAndDrawVectors();
			}
		});

		document.getElementById('showRemovedPaths').addEventListener('change', function() {
			showRemovedPaths = this.checked;

			vectorCtx.fillStyle = 'white';
			vectorCtx.fillRect(0, 0, vectorPreview.width, vectorPreview.height);
			drawVectorPaths(vectorCtx, vectorPreview);

			if (showCrosshair.checked) {
				const sheetWidth = parseInt(sheetWidthInput.value);
				const sheetHeight = parseInt(sheetHeightInput.value);
				drawCrosshair(vectorCtx, vectorPreview, sheetWidth, sheetHeight);
			}
			
			updateStatus(`Показ удаленных линий: ${this.checked ? 'включен' : 'выключен'}`, 'success');
		});
					
		// Добавляем кнопку сброса изображения
		document.getElementById('resetImageBtn').addEventListener('click', function() {
			if (currentHistoryIndex >= 0) {
				undoLastErase();
			} else if (originalImageData || originalImage) {
				if (originalImageData) {
					resetImageEdit(true); 
				} else {
					displayImage(originalImage);
					processAndDrawVectors(true); 
					updateStatus('Изображение восстановлено', 'success');
				}
			} else {
				clearAllImageData();
			}
		});

		// Обработчик клавиш для отмены (Ctrl+Z)
		document.addEventListener('keydown', function(e) {
			if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
				e.preventDefault();
				if (currentHistoryIndex >= 0) {
					undoLastErase();
				}
			}
		});

		window.addEventListener('beforeunload', function() {
			clearAllImageData();
		});

		// Очистка при нажатии Ctrl+F5 или полной перезагрузке
		window.addEventListener('unload', function() {
			clearAllImageData();
		});
			
			// Обработчики для ластика
		document.getElementById('eraserTool').addEventListener('click', function() {
			if (currentTool === 'eraser') {
				// Выключаем ластик
				currentTool = 'none';
				eraserEnabled = false;
				imageEditMode = false;
				this.classList.remove('active');
				vectorPreview.classList.remove('eraser-cursor');
				imagePreview.classList.remove('eraser-cursor');
				vectorPreview.style.cursor = 'default';
				imagePreview.style.cursor = 'default';
				updateStatus('Ластик выключен', 'success');
			} else {
				// Включаем ластик
				currentTool = 'eraser';
				eraserEnabled = true;
				imageEditMode = true;
				this.classList.add('active');
				vectorPreview.classList.add('eraser-cursor');
				imagePreview.classList.add('eraser-cursor');
				updateEraserCursor();
				
				// Сохраняем оригинальные данные изображения при первом включении
				if (!originalImageData && originalImage && !isSvgFile) {
					const tempCanvas = document.createElement('canvas');
					tempCanvas.width = originalImage.width;
					tempCanvas.height = originalImage.height;
					const tempCtx = tempCanvas.getContext('2d');
					tempCtx.drawImage(originalImage, 0, 0);
					originalImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
					editedImageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
				}
				
				updateStatus('Ластик включен - зажмите ЛКМ и ведите для удаления', 'success');
				    if (isSvgFile) {
        updateStatus('⚠️ Ластик не работает с исходным SVG изображением.', 'error');
    }
			}
			redrawVectorCanvas();
			redrawImageWithCrosshair();
		});
		  
		document.getElementById('eraserSize').addEventListener('input', function() {
			eraserSize = parseInt(this.value);
			document.getElementById('eraserSizeValue').textContent = eraserSize + 'px';
			
			if (currentTool === 'eraser') {
				updateEraserCursor();
			}
		});
								
	});

    </script>

</body>

</html>


