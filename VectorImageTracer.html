
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Å—Ç–æ–π –≤–µ–∫—Ç–æ—Ä–Ω—ã–π —Ä–µ–¥–∞–∫—Ç–æ—Ä</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: #2d2d2d;
            color: white;
            height: 100vh;
            overflow: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 250px;
            background: #1a1a1a;
            padding: 20px;
            border-right: 1px solid #444;
			overflow-y: auto;
        }
        
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: #1a1a1a;
        }
        
        #svg-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        
        .panel {
            background: #333;
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 8px;
        }
		.panel label {
			font-size: 10px;
		}
        
        h3 {
            margin-bottom: 15px;
            color: #4dabf7;
        }
        
        button {
            background: #4dabf7;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #339af0;
        }
        
        .tool-btn {
            background: #444;
            margin: 5px;
            width: 40px;
            height: 40px;
			padding: 6px;
        }
        
        .tool-btn.active {
            background: #4dabf7;
        }
        
        .tools {
            display: flex;
            flex-wrap: wrap;
            gap: 0px;
            margin-bottom: 0px;
        }
        
        input[type="range"] {
            width: 100%;
            margin: 0;
        }
        
        input[type="color"] {
			width: 40px;
			height: 40px;
			margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
            display: flex;
            gap: 10px;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            background: #444;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 20px;
        }
        
        .zoom-level {
            color: white;
            line-height: 40px;
            padding: 0 10px;
        }
        
        .coordinates {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
#eraser-indicator {
    pointer-events: none;
    stroke: #ff6b6b;
    stroke-width: 2;
    fill: rgba(255, 107, 107, 0.2);
    stroke-dasharray: 5,5;
}
#push-indicator {
    pointer-events: none;
    stroke: #ff6b6b;
    stroke-width: 1;
    fill: rgba(255, 107, 107, 0.1);
    stroke-dasharray: 3,3;
}
.push-mode {
    cursor: none !important;
}
		@keyframes pulse-ring {
			0% { stroke-opacity: 0.7; }
			50% { stroke-opacity: 1; }
			100% { stroke-opacity: 0.7; }
		}
		/* –¢–æ—á–∫–∞ –ù–ï –≤—ã–¥–µ–ª–µ–Ω–∞ */
.bezier-point {
    fill: #4dabf7;
    stroke: #1971c2;
    stroke-width: 2;
    r: 1%;
	opacity: 0.5;
    cursor: move;
}

.bezier-point.selected {
    fill: #ff6b6b;
    stroke: #e03131;
    stroke-width: 3;
	opacity: 0.5;
}

/* –í–µ–∫—Ç–æ—Ä—ã –ë–µ–∑—å–µ */
.bezier-vector {
    fill: none;
    stroke-linecap: round;
}

/* –ù–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ –ë–µ–∑—å–µ */
.bezier-guide-line {
    stroke: #868e96;
    stroke-width: 1;
    stroke-dasharray: 3,3;
    opacity: 0.5;
}

.bezier-control-point {
    fill: #ffd43b;
    stroke: #f08c00;
    stroke-width: 1;
    r: 0.7%;
    cursor: pointer;
	opacity: 0.5;
	
}

    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="panel">
                <h3>–ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</h3>
                <button id="loadImageBtn">–ó–∞–≥—Ä—É–∑–∏—Ç—å —Ñ–æ—Ç–æ</button>
                <div id="imageControls" style="display: none;">
                    <button id="removeImageBtn" style="background: #dc3545;">–£–¥–∞–ª–∏—Ç—å</button>
                    <label style="display: block; margin: 10px 0;">–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å: <span id="opacityValue">50%</span></label>
                    <input type="range" id="opacitySlider" min="1" max="100" value="50">
                </div>
            </div>
            
            <div class="panel">
                <h3>–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã</h3>
                <div class="tools">
                    <button class="tool-btn active" data-tool="select">‚úì</button>
					<button class="tool-btn" data-tool="push">üëÜ</button>
					<button class="tool-btn" data-tool="eraser">üßΩ</button>
                    <button class="tool-btn" data-tool="line">‚îÄ</button>
                    <button class="tool-btn" data-tool="rect">‚ñ≠</button>
                    <button class="tool-btn" data-tool="circle">‚óã</button>
					<button class="tool-btn" data-tool="pen">‚úèÔ∏è</button>
					<button class="tool-btn" data-tool="bezier-points">B</button>
					<input type="color" id="strokeColor" value="#4dabf7">
					<label style="display: block; margin-top: 0px; margin: 5px;">–¢–æ–ª—â–∏–Ω–∞: <span id="widthValue">3</span></label>
					<input type="range" id="widthSlider" min="1" max="20" value="3">
                </div>
                <div id="eraserSettings" style="display: none; margin-top: 10px;">
    <label>–†–∞–∑–º–µ—Ä –ª–∞—Å—Ç–∏–∫–∞: <span id="eraserSizeValue">20</span>px</label>
    <input type="range" id="eraserSizeSlider" min="5" max="100" value="20">

</div>
                <div id="penSettings" style="display: none;">
                    <label>–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ: <span id="smoothValue">5</span></label>
                    <input type="range" id="smoothSlider" min="1" max="20" value="5">
					<h3>–ü—Ä–∏–≤—è–∑–∫–∞</h3>
    <label style="display: block; margin: 10px 0;">
        <input type="checkbox" id="continueVectorToggle" checked> –ü—Ä–æ–¥–æ–ª–∂–∞—Ç—å –≤–µ–∫—Ç–æ—Ä
    </label>
    <label style="display: block; margin: 10px 0;">
        <input type="checkbox" id="blackSnapToggle" checked> –ü—Ä–∏–≤—è–∑–∫–∞ –∫ —á–µ—Ä–Ω–æ–π –ª–∏–Ω–∏–∏
    </label>
    <label style="display: block; margin: 10px 0;">
        –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ: <span id="snapDistanceValue">10</span>px
    </label>
    <input type="range" id="snapDistanceSlider" min="1" max="50" value="10">
                </div>
				<div id="pushSettings" style="display: none; margin-top: 10px;">
    <label>–†–∞–¥–∏—É—Å –≤–æ–∑–¥–µ–π—Å—Ç–≤–∏—è: <span id="pushRadiusValue">20</span>px</label>
    <input type="range" id="pushRadiusSlider" min="5" max="100" value="20">
    
    <label style="display: block; margin-top: 10px;">–°–∏–ª–∞: <span id="pushStrengthValue">0.5</span></label>
    <input type="range" id="pushStrengthSlider" min="1" max="100" value="50">
    
    <label style="display: block; margin-top: 10px;">
        <input type="checkbox" id="pushSmoothToggle" checked> –°–≥–ª–∞–∂–µ–Ω–Ω—ã–π —ç—Ñ—Ñ–µ–∫—Ç
    </label>
</div>

            </div>
            
            <div class="panel">
                <h3>–î–µ–π—Å—Ç–≤–∏—è</h3>
                <button id="saveBtn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å SVG</button>
                <button id="clearBtn" style="background: #6c757d;">–û—á–∏—Å—Ç–∏—Ç—å –≤–µ–∫—Ç–æ—Ä—ã</button>
            </div>
        </div>
        
        <div class="main-area">
            <div class="canvas-container" id="canvasContainer">
                <svg id="svg-canvas"></svg>
                
                <div id="noImage" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
                    <div style="font-size: 48px; margin-bottom: 20px;">üñºÔ∏è</div>
                    <h3>–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ</h3>
                    <p>–ù–∞—á–Ω–∏—Ç–µ —Å –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏ –∫–∞–∫ –ø–æ–¥–ª–æ–∂–∫–∏</p>
                </div>
                
                <div class="zoom-controls">
                    <button class="zoom-btn" id="zoomOut">-</button>
                    <div class="zoom-level" id="zoomLevel">100%</div>
                    <button class="zoom-btn" id="zoomIn">+</button>
                </div>
                
                <div class="coordinates" id="coordinates">X: 0, Y: 0</div>
            </div>
        </div>
    </div>
    
    <input type="file" id="imageInput" accept="image/*" style="display: none;">
    
    <script>
        class VectorEditor {
    constructor() {
        // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        this.state = {
            currentTool: 'select',
            isDrawing: false,
            currentElement: null,
            startPoint: {x: 0, y: 0},
            image: null,
            imageUrl: null,
            zoom: 1,
            viewBox: {x: 0, y: 0, width: 1000, height: 1000},
            strokeColor: '#4dabf7',
            strokeWidth: 3,
            smoothing: 5,
            penPoints: [],
            pushRadius: 20,
			pushStrength: 0.5,
			pushSmooth: true,
			imageForDisplay: null, 
			pushPoints: [], // –¢–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ —Å–¥–≤–∏–≥–∞–µ–º
			originalPoints: [], // –ò—Å—Ö–æ–¥–Ω—ã–µ –ø–æ–∑–∏—Ü–∏–∏ —Ç–æ—á–µ–∫
			pushStart: {x: 0, y: 0}, // –ù–∞—á–∞–ª—å–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è –º—ã—à–∏ –ø—Ä–∏ —Å–¥–≤–∏–≥–µ
			eraserSize: 20,
            isMoving: false,
            moveStart: {x: 0, y: 0},
            viewBoxStart: {x: 0, y: 0, width: 0, height: 0},
			eraserPoints: [],
			bezierSelectedPoint: null, // –í—ã–¥–µ–ª–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ –ë–µ–∑—å–µ
            bezierPoints: [],
            bezierVectors: [],
            
            // –§–ª–∞–≥–∏ –¥–ª—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
            isDraggingPoint: false,
            draggingPointIndex: null,
            draggingPointStartX: 0,
            draggingPointStartY: 0,
            draggingPointOriginalX: 0,
            draggingPointOriginalY: 0,
            
            isDraggingControl: false,
            draggingControlVectorIndex: null,
            draggingControlType: null,
            draggingControlStartX: 0,
            draggingControlStartY: 0,
            draggingControlOriginalX: 0,
            draggingControlOriginalY: 0,
			lastBezierDirection: null, // –ü–æ—Å–ª–µ–¥–Ω–µ–µ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞—Å–∞—Ç–µ–ª—å–Ω–æ–π
			lastBezierLength: null    // –ü–æ—Å–ª–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ –∫–∞—Å–∞—Ç–µ–ª—å–Ω–æ–π
        };
    this.snapSettings = {
        enabled: true,
        snapDistance: 10,
        blackThreshold: 50,
        searchRadius: 15,
        continueVector: true 
    };
this.pushData = null;
		this.pushUpdateQueue = [];
		this.isPushUpdatePending = false;
		this.pathCache = new Map();
		this.lastPushUpdate = 0;
	    this.lastEraseTime = null; 
		this.lastErasePoint = null; 
		this.imageCanvasCache = null;
		this.imageDataCache = null;
		this.init();
		this.setupCursorRestore();
    }
	

// –í–ò–ó–£–ê–õ–¨–ù–´–ô –ò–ù–î–ò–ö–ê–¢–û–† –õ–ê–°–¢–ò–ö–ê
showEraserIndicator(x, y, radius) {
    let indicator = document.getElementById('eraser-indicator');
    
    if (!indicator) {
        indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        indicator.id = 'eraser-indicator';
        indicator.setAttribute('stroke', '#ff6b6b');
        indicator.setAttribute('stroke-width', '2');
        indicator.setAttribute('fill', 'rgba(255, 107, 107, 0.2)');
        indicator.setAttribute('stroke-dasharray', '5,5');
        indicator.style.pointerEvents = 'none';

        const pushIndicator = document.getElementById('push-indicator');
        if (pushIndicator) {
            this.svg.insertBefore(indicator, pushIndicator.nextSibling);
        } else {
            this.svg.appendChild(indicator);
        }
    }
    
    indicator.setAttribute('cx', x);
    indicator.setAttribute('cy', y);
    indicator.setAttribute('r', radius);
    indicator.style.display = 'block';
    
    // –£–ë–ò–†–ê–ï–ú –∞–Ω–∏–º–∞—Ü–∏—é –ø—É–ª—å—Å–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä–∞—è –º–æ–∂–µ—Ç –≤—ã–∑—ã–≤–∞—Ç—å –æ—Å—Ç–∞—Ç–∫–∏
    indicator.style.animation = 'none';
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º z-index –¥–ª—è –≥–∞—Ä–∞–Ω—Ç–∏–∏, —á—Ç–æ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –±—É–¥–µ—Ç –ø–æ–≤–µ—Ä—Ö
    indicator.style.zIndex = '9999';
}

// –°–ö–†–´–í–ê–ï–ú –ò–ù–î–ò–ö–ê–¢–û–† –õ–ê–°–¢–ò–ö–ê
hideEraserIndicator() {
    const indicator = document.getElementById('eraser-indicator');
    if (indicator) {
        // –ü–æ–ª–Ω–æ—Å—Ç—å—é —Å–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä
        indicator.style.display = 'none';
        
        // –û—á–∏—â–∞–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –Ω–µ –±—ã–ª–æ –æ—Å—Ç–∞—Ç–∫–æ–≤
        indicator.setAttribute('cx', '-100');
        indicator.setAttribute('cy', '-100');
    }
}
         
init() {
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SVG
    this.svg = document.getElementById('svg-canvas');
    this.svg.setAttribute('width', '100%');
    this.svg.setAttribute('height', '100%');
    this.svg.setAttribute('viewBox', '0 0 1000 1000');
    this.svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    
    // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π
    this.setupEventListeners();
    
    // –û–ë–ù–û–í–õ–Ø–ï–ú –í–°–ï –¢–ï–ö–°–¢–û–í–´–ï –≠–õ–ï–ú–ï–ù–¢–´ –û–¢ –°–õ–ê–ô–î–ï–†–û–í –ü–†–ò –ó–ê–ì–†–£–ó–ö–ï
    this.updateAllSliderTexts();
    
    // –ó–∞–≥—Ä—É–∂–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ UI
    this.loadSettingsFromUI();
	this.setupGlobalDragHandlers();
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞
    this.updateZoomDisplay();
        // –°–æ–∑–¥–∞–µ–º –≥—Ä—É–ø–ø—É –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
        this.state.bezierControlGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        this.state.bezierControlGroup.id = 'bezier-control-group';
        this.svg.appendChild(this.state.bezierControlGroup);
	
}
setupGlobalDragHandlers() {
    // –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–≤–∏–∂–µ–Ω–∏—è –º—ã—à–∏
    document.addEventListener('mousemove', (e) => {
        // –ï—Å–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ç–æ—á–∫—É –ë–µ–∑—å–µ
        if (this.state.isDraggingPoint) {
            const coords = this.getSVGCoordinates(e);
            this.updatePointDrag(coords.x, coords.y);
        }
        
        // –ï—Å–ª–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—É—é —Ç–æ—á–∫—É –ë–µ–∑—å–µ
        if (this.state.isDraggingBezierControl) {
            const coords = this.getSVGCoordinates(e);
            this.updateBezierControlDrag(coords.x, coords.y);
        }
    });
    
    // –ì–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—Ç–ø—É—Å–∫–∞–Ω–∏—è –º—ã—à–∏
    document.addEventListener('mouseup', (e) => {
        // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –æ—Å–Ω–æ–≤–Ω–æ–π —Ç–æ—á–∫–∏ –ë–µ–∑—å–µ
        if (this.state.isDraggingPoint) {
            this.endPointDrag();
        }
        
        // –ó–∞–≤–µ—Ä—à–∞–µ–º –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏ –ë–µ–∑—å–µ
        if (this.state.isDraggingBezierControl) {
            this.endBezierControlDrag();
        }
    });
}

           setupEventListeners() {
                // –ó–∞–≥—Ä—É–∑–∫–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                document.getElementById('loadImageBtn').onclick = () => {
                    document.getElementById('imageInput').click();
                };
                
                document.getElementById('imageInput').onchange = (e) => {
                    if (e.target.files[0]) this.loadImage(e.target.files[0]);
                };
                
                document.getElementById('removeImageBtn').onclick = () => {
                    this.removeImage();
                };
                
                // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        const tool = e.target.dataset.tool;
                        this.setTool(tool);
                    };
                });
                
                // –°–≤–æ–π—Å—Ç–≤–∞
                document.getElementById('strokeColor').oninput = (e) => {
                    this.state.strokeColor = e.target.value;
                };
                
                
                document.getElementById('widthSlider').oninput = (e) => {
                    this.state.strokeWidth = parseInt(e.target.value);
                    document.getElementById('widthValue').textContent = e.target.value;
                };
document.getElementById('eraserSizeSlider').oninput = (e) => {
    this.state.eraserSize = parseInt(e.target.value);
    document.getElementById('eraserSizeValue').textContent = e.target.value;
};

                // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –ø–µ—Ä–∞
                document.getElementById('smoothSlider').oninput = (e) => {
                    this.state.smoothing = parseInt(e.target.value);
                    document.getElementById('smoothValue').textContent = e.target.value;
                };
                
                // –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
                document.getElementById('opacitySlider').oninput = (e) => {
                    const imageElement = document.getElementById('background-image');
                    if (imageElement) {
                        imageElement.style.opacity = e.target.value / 100;
                        document.getElementById('opacityValue').textContent = e.target.value + '%';
                    }
                };
                
                // –ó—É–º
                document.getElementById('zoomIn').onclick = () => this.zoomIn();
                document.getElementById('zoomOut').onclick = () => this.zoomOut();
                
                // –î–µ–π—Å—Ç–≤–∏—è
                document.getElementById('saveBtn').onclick = () => this.saveSVG();
                document.getElementById('clearBtn').onclick = () => this.clearVectors();
                
                // –°–æ–±—ã—Ç–∏—è –º—ã—à–∏ –Ω–∞ —Ö–æ–ª—Å—Ç–µ
                this.svg.onmousedown = (e) => this.onMouseDown(e);
                this.svg.onmousemove = (e) => {
                    this.onMouseMove(e);
                    this.updateCoordinates(e);
                };
                this.svg.onmouseup = () => this.onMouseUp();
                this.svg.onmouseleave = () => this.onMouseLeave();
                
                // –ó—É–º –∫–æ–ª–µ—Å–∏–∫–æ–º
                document.getElementById('canvasContainer').onwheel = (e) => {
                    if (e.ctrlKey) {
                        e.preventDefault();
                        const delta = e.deltaY > 0 ? 0.9 : 1.1;
                        const coords = this.getSVGCoordinates(e);
                        this.zoomToPoint(coords.x, coords.y, delta);
                    }
                };
				const snapPanel = document.createElement('div');

				// –í—Å—Ç–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ –ø–∞–Ω–µ–ª–∏ —Å–≤–æ–π—Å—Ç–≤
				const sidebar = document.querySelector('.sidebar');
				const propertiesPanel = document.querySelectorAll('.panel')[2];
				sidebar.insertBefore(snapPanel, propertiesPanel.nextSibling);
				
				// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è –Ω–æ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤
document.getElementById('continueVectorToggle').onchange = (e) => {
    this.snapSettings.continueVector = e.target.checked;
};
				
				document.getElementById('blackSnapToggle').onchange = (e) => {
					this.snapSettings.enabled = e.target.checked;
				};
				
				document.getElementById('snapDistanceSlider').oninput = (e) => {
					this.snapSettings.snapDistance = parseInt(e.target.value);
					document.getElementById('snapDistanceValue').textContent = e.target.value;
				};
				 // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—É—à-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
				document.getElementById('pushRadiusSlider').oninput = (e) => {
					this.state.pushRadius = parseInt(e.target.value);
					document.getElementById('pushRadiusValue').textContent = e.target.value;
				};
				
				document.getElementById('pushStrengthSlider').oninput = (e) => {
					// –ó–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0.01 –¥–æ 1.0
					this.state.pushStrength = parseInt(e.target.value) / 100;
					document.getElementById('pushStrengthValue').textContent = this.state.pushStrength.toFixed(1);
				};
				
				document.getElementById('pushSmoothToggle').onchange = (e) => {
					this.state.pushSmooth = e.target.checked;
				};
							
            }

setupCursorRestore() {
    // –ü—Ä–∏ –¥–≤–∏–∂–µ–Ω–∏–∏ –º—ã—à–∏ –ø–æ –≤—Å–µ–º—É –¥–æ–∫—É–º–µ–Ω—Ç—É
    document.addEventListener('mousemove', (e) => {
        // –ï—Å–ª–∏ –º—ã –≤–Ω–µ SVG –∏ –≤ —Ä–µ–∂–∏–º–µ push
        if (this.state.currentTool === 'push' && !e.target.closest('#svg-canvas')) {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –∫—É—Ä—Å–æ—Ä
            document.body.style.cursor = 'default';
            this.hidePushIndicator();
        }
    });
    
    // –ü—Ä–∏ –≤—Ö–æ–¥–µ –≤ SVG –≤ —Ä–µ–∂–∏–º–µ push
    this.svg.addEventListener('mouseenter', () => {
        if (this.state.currentTool === 'push') {
            this.updateCursor();
        }
    });
    
    // –ü—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–∑ SVG
    this.svg.addEventListener('mouseleave', () => {
        if (this.state.currentTool === 'push') {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –∫—É—Ä—Å–æ—Ä
            document.body.style.cursor = 'default';
            this.hidePushIndicator();
        }
    });
    
    // –ü—Ä–∏ –∫–ª–∏–∫–µ –≤–Ω–µ SVG –≤ —Ä–µ–∂–∏–º–µ push
    document.addEventListener('mousedown', (e) => {
        if (this.state.currentTool === 'push' && !e.target.closest('#svg-canvas')) {
            // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ—Ä–º–∞–ª—å–Ω—ã–π –∫—É—Ä—Å–æ—Ä
            document.body.style.cursor = 'default';
            this.hidePushIndicator();
        }
    });
}

loadSettingsFromUI() {
    // –¶–≤–µ—Ç –ª–∏–Ω–∏–∏
    const strokeColorInput = document.getElementById('strokeColor');
    if (strokeColorInput && strokeColorInput.value) {
        this.state.strokeColor = strokeColorInput.value;
    }
    
    // –¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏
    const widthSlider = document.getElementById('widthSlider');
    if (widthSlider && widthSlider.value) {
        this.state.strokeWidth = parseInt(widthSlider.value);
    }
    
    // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ –ø–µ—Ä–∞
    const smoothSlider = document.getElementById('smoothSlider');
    if (smoothSlider && smoothSlider.value) {
        this.state.smoothing = parseInt(smoothSlider.value);
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏—è –≤–µ–∫—Ç–æ—Ä–∞
    const continueVectorToggle = document.getElementById('continueVectorToggle');
    if (continueVectorToggle) {
        this.snapSettings.continueVector = continueVectorToggle.checked;
    }
	
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–∏–≤—è–∑–∫–∏
    const snapToggle = document.getElementById('snapToggle');
    if (snapToggle) {
        this.snapSettings.enabled = snapToggle.checked;
    }
    
    const blackSnapToggle = document.getElementById('blackSnapToggle');
    if (blackSnapToggle) {
        this.snapSettings.enabled = blackSnapToggle.checked;
    }
    
    const snapDistanceSlider = document.getElementById('snapDistanceSlider');
    if (snapDistanceSlider && snapDistanceSlider.value) {
        this.snapSettings.snapDistance = parseInt(snapDistanceSlider.value);
    }
    
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø—É—à
    const pushRadiusSlider = document.getElementById('pushRadiusSlider');
    if (pushRadiusSlider && pushRadiusSlider.value) {
        this.state.pushRadius = parseInt(pushRadiusSlider.value);
    }
    
    const pushStrengthSlider = document.getElementById('pushStrengthSlider');
    if (pushStrengthSlider && pushStrengthSlider.value) {
        this.state.pushStrength = parseInt(pushStrengthSlider.value) / 100;
    }
    
    const pushSmoothToggle = document.getElementById('pushSmoothToggle');
    if (pushSmoothToggle) {
        this.state.pushSmooth = pushSmoothToggle.checked;
    }
    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ª–∞—Å—Ç–∏–∫–∞
    const eraserSizeSlider = document.getElementById('eraserSizeSlider');
    if (eraserSizeSlider && eraserSizeSlider.value) {
        this.state.eraserSize = parseInt(eraserSizeSlider.value);
    }
    
    console.log('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ UI');
}

updateAllSliderTexts() {
    console.log('–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ —Å–ª–∞–π–¥–µ—Ä–æ–≤...');
    
    // –¢–æ–ª—â–∏–Ω–∞ –ª–∏–Ω–∏–∏
    const widthSlider = document.getElementById('widthSlider');
    const widthValue = document.getElementById('widthValue');
    if (widthSlider && widthValue) {
        widthValue.textContent = widthSlider.value;
        console.log('–¢–æ–ª—â–∏–Ω–∞:', widthSlider.value);
    }
    
    // –°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
    const smoothSlider = document.getElementById('smoothSlider');
    const smoothValue = document.getElementById('smoothValue');
    if (smoothSlider && smoothValue) {
        smoothValue.textContent = smoothSlider.value;
        console.log('–°–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ:', smoothSlider.value);
    }
    
    // –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å (–≤—Å–µ–≥–¥–∞ –æ–±–Ω–æ–≤–ª—è–µ–º, –¥–∞–∂–µ –µ—Å–ª–∏ –Ω–µ—Ç –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è)
    const opacitySlider = document.getElementById('opacitySlider');
    const opacityValue = document.getElementById('opacityValue');
    if (opacitySlider && opacityValue) {
        opacityValue.textContent = opacitySlider.value + '%';
        console.log('–ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å:', opacitySlider.value + '%');
    }
    
    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–≤—è–∑–∫–∏
    const snapDistanceSlider = document.getElementById('snapDistanceSlider');
    const snapDistanceValue = document.getElementById('snapDistanceValue');
    if (snapDistanceSlider && snapDistanceValue) {
        snapDistanceValue.textContent = snapDistanceSlider.value;
        console.log('–†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–≤—è–∑–∫–∏:', snapDistanceSlider.value);
    }
    
    // –†–∞–¥–∏—É—Å –ø—É—à-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    const pushRadiusSlider = document.getElementById('pushRadiusSlider');
    const pushRadiusValue = document.getElementById('pushRadiusValue');
    if (pushRadiusSlider && pushRadiusValue) {
        pushRadiusValue.textContent = pushRadiusSlider.value;
        console.log('–†–∞–¥–∏—É—Å –ø—É—à:', pushRadiusSlider.value);
    }
    
    // –°–∏–ª–∞ –ø—É—à-–∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    const pushStrengthSlider = document.getElementById('pushStrengthSlider');
    const pushStrengthValue = document.getElementById('pushStrengthValue');
    if (pushStrengthSlider && pushStrengthValue) {
        const strength = parseInt(pushStrengthSlider.value) / 100;
        pushStrengthValue.textContent = strength.toFixed(1);
    }
}

            // –ó–£–ú
            zoomIn() {
                this.setZoom(this.state.zoom * 1.2);
            }
            
            zoomOut() {
                this.setZoom(this.state.zoom / 1.2);
            }
            
            setZoom(zoomLevel) {
                this.state.zoom = Math.max(0.1, Math.min(10, zoomLevel));
                
                const centerX = this.state.viewBox.x + this.state.viewBox.width / 2;
                const centerY = this.state.viewBox.y + this.state.viewBox.height / 2;
                
                const newWidth = 1000 / this.state.zoom;
                const newHeight = 1000 / this.state.zoom;
                
                this.state.viewBox = {
                    x: centerX - newWidth / 2,
                    y: centerY - newHeight / 2,
                    width: newWidth,
                    height: newHeight
                };
                
                this.svg.setAttribute('viewBox', 
                    `${this.state.viewBox.x} ${this.state.viewBox.y} ${this.state.viewBox.width} ${this.state.viewBox.height}`
                );
                
                this.updateZoomDisplay();
            }
            
            zoomToPoint(x, y, factor) {
                const newWidth = this.state.viewBox.width * factor;
                const newHeight = this.state.viewBox.height * factor;
                
                const mouseXPercent = (x - this.state.viewBox.x) / this.state.viewBox.width;
                const mouseYPercent = (y - this.state.viewBox.y) / this.state.viewBox.height;
                
                this.state.viewBox = {
                    x: x - (mouseXPercent * newWidth),
                    y: y - (mouseYPercent * newHeight),
                    width: newWidth,
                    height: newHeight
                };
                
                this.svg.setAttribute('viewBox', 
                    `${this.state.viewBox.x} ${this.state.viewBox.y} ${this.state.viewBox.width} ${this.state.viewBox.height}`
                );
                
                this.state.zoom = 1000 / newWidth;
                this.updateZoomDisplay();
            }
            
            updateZoomDisplay() {
                document.getElementById('zoomLevel').textContent = 
                    Math.round(this.state.zoom * 100) + '%';
            }

startPanning(e) {
    this.state.isMoving = true;
    this.state.moveStart = {
        x: e.clientX,
        y: e.clientY,
        viewBoxX: this.state.viewBox.x,
        viewBoxY: this.state.viewBox.y
    };
    this.svg.style.cursor = 'grabbing';
}
    
doPanning(e) {
    if (!this.state.isMoving) return;
    
    // –ü—Ä–æ—Å—Ç–æ–π —Ä–∞—Å—á–µ—Ç —Å–º–µ—â–µ–Ω–∏—è
    const dx = e.clientX - this.state.moveStart.x;
    const dy = e.clientY - this.state.moveStart.y;
    
    // –ú–∞—Å—à—Ç–∞–±–∏—Ä—É–µ–º —Å–º–µ—â–µ–Ω–∏–µ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ —Ä–∞–∑–º–µ—Ä–∞ viewBox
    const scaleX = this.state.viewBox.width / this.svg.clientWidth;
    const scaleY = this.state.viewBox.height / this.svg.clientHeight;
    
    this.state.viewBox.x = this.state.moveStart.viewBoxX - dx * scaleX;
    this.state.viewBox.y = this.state.moveStart.viewBoxY - dy * scaleY;
    
    this.svg.setAttribute('viewBox', 
        `${this.state.viewBox.x} ${this.state.viewBox.y} ${this.state.viewBox.width} ${this.state.viewBox.height}`
    );
}
    
stopPanning() {
    this.state.isMoving = false;
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    if (this.state.currentTool === 'select') {
        this.svg.style.cursor = 'move';
    } else {
        this.svg.style.cursor = 'crosshair';
    }
}
    
            // –ò–ó–û–ë–†–ê–ñ–ï–ù–ò–ï

addWhiteBackgroundToPNG(img) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        canvas.width = img.width;
        canvas.height = img.height;
        const ctx = canvas.getContext('2d');
        
        // 1. –ó–∞–ª–∏–≤–∞–µ–º –±–µ–ª—ã–º —Ñ–æ–Ω–æ–º
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // 2. –†–∏—Å—É–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–æ–≤–µ—Ä—Ö (—Å–æ—Ö—Ä–∞–Ω—è—è –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å)
        ctx.drawImage(img, 0, 0);
        
        // 3. –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å –±–µ–ª—ã–º —Ñ–æ–Ω–æ–º
        const imgWithBackground = new Image();
        imgWithBackground.onload = () => {
            resolve(imgWithBackground);
        };
        imgWithBackground.src = canvas.toDataURL();
    });
}

loadImage(file) {
    const reader = new FileReader();
    reader.onload = async (e) => {
        const img = new Image();
        img.onload = async () => {
            this.state.image = img;
            this.state.imageUrl = e.target.result;
            
            let imageForDisplay = img;
            let imageForSnapping = img; // –î–ª—è –ø—Ä–∏–≤—è–∑–∫–∏ - —Ç–æ –∂–µ —Å–∞–º–æ–µ —á—Ç–æ –≤–∏–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
            
            // –ü–†–û–í–ï–†–Ø–ï–ú: –µ—Å–ª–∏ PNG
            if (file.type === 'image/png' || file.name.toLowerCase().endsWith('.png')) {
                try {
                    
                    imageForDisplay = await this.addWhiteBackgroundToPNG(img);

                    imageForSnapping = imageForDisplay;
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º URL –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                    this.state.imageUrl = imageForDisplay.src;
                    
                } catch (error) {
                    console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å PNG:', error);
                    imageForDisplay = img;
                    imageForSnapping = img;
                }
            }
            
            this.state.imageForDisplay = imageForDisplay; 

            // –û—Ç–æ–±—Ä–∞–∂–∞–µ–º –≤–µ—Ä—Å–∏—é —Å –±–µ–ª—ã–º —Ñ–æ–Ω–æ–º
            this.displayImage(imageForDisplay);
            document.getElementById('noImage').style.display = 'none';
            document.getElementById('imageControls').style.display = 'block';
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å –∏–∑ —Å–ª–∞–π–¥–µ—Ä–∞
            const opacitySlider = document.getElementById('opacitySlider');
            const imageElement = document.getElementById('background-image');
            if (opacitySlider && imageElement) {
                imageElement.style.opacity = opacitySlider.value / 100;
            }
            
            this.updateImageCache(imageForSnapping);
            
            this.fitImageToCanvas();
        };
        img.src = e.target.result;
    };
    reader.readAsDataURL(file);
}

updateImageCache(imageToCache) {
    // –û—á–∏—â–∞–µ–º —Å—Ç–∞—Ä—ã–π –∫—ç—à
    this.imageCanvasCache = null;
    this.imageDataCache = null;
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫—ç—à –∏–∑ –ø–µ—Ä–µ–¥–∞–Ω–Ω–æ–≥–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    this.imageCanvasCache = document.createElement('canvas');
    this.imageCanvasCache.width = imageToCache.width;
    this.imageCanvasCache.height = imageToCache.height;
    const ctx = this.imageCanvasCache.getContext('2d');
    ctx.drawImage(imageToCache, 0, 0);
    this.imageDataCache = ctx.getImageData(0, 0, imageToCache.width, imageToCache.height);
    
    console.log('–ö—ç—à –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω (—Ä–∞–∑–º–µ—Ä:', imageToCache.width, 'x', imageToCache.height, ')');
}
           
displayImage(img) {
    // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å
    const oldImage = document.getElementById('background-image');
    if (oldImage) oldImage.remove();
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    const imageElement = document.createElementNS('http://www.w3.org/2000/svg', 'image');
    imageElement.id = 'background-image';
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º imageForDisplay –µ—Å–ª–∏ –µ—Å—Ç—å, –∏–Ω–∞—á–µ –æ—Ä–∏–≥–∏–Ω–∞–ª
    const imageToShow = this.state.imageForDisplay || img;
    imageElement.setAttribute('href', imageToShow.src || this.state.imageUrl);
    
    imageElement.style.opacity = '0.5';
    imageElement.setAttribute('preserveAspectRatio', 'xMidYMid meet');
    
    // –û—Ç–∫–ª—é—á–∞–µ–º —Å–æ–±—ã—Ç–∏—è –º—ã—à–∏ –¥–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    imageElement.style.pointerEvents = 'none';
    
    // –î–æ–±–∞–≤–ª—è–µ–º –ø–µ—Ä–≤—ã–º —ç–ª–µ–º–µ–Ω—Ç–æ–º (—Ñ–æ–Ω)
    this.svg.insertBefore(imageElement, this.svg.firstChild);
    
    // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º
    this.centerImage();
}

centerImage() {
    if (!this.state.image) return;
    
    const img = this.state.image;
    const imageElement = document.getElementById('background-image');
    if (!imageElement) return;
    
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è viewBox 1000x1000
    const viewBoxSize = 1000;
    const scale = Math.min(viewBoxSize / img.width, viewBoxSize / img.height) * 0.9;
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∏ –ø–æ–∑–∏—Ü–∏—é
    imageElement.setAttribute('width', img.width * scale);
    imageElement.setAttribute('height', img.height * scale);
    
    const x = (viewBoxSize - img.width * scale) / 2;
    const y = (viewBoxSize - img.height * scale) / 2;
    
    imageElement.setAttribute('x', x);
    imageElement.setAttribute('y', y);
}

fitImageToCanvas() {
    if (!this.state.image) return;
    
    const img = this.state.image;
    const scale = Math.min(1000 / img.width, 1000 / img.height) * 0.9;

    const imageElement = document.getElementById('background-image');
    if (imageElement) {
        // –£–±–∏—Ä–∞–µ–º transform
        imageElement.removeAttribute('transform');
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ä–∞–∑–º–µ—Ä—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è —Å —É—á–µ—Ç–æ–º –º–∞—Å—à—Ç–∞–±–∞
        imageElement.setAttribute('width', img.width * scale);
        imageElement.setAttribute('height', img.height * scale);
        
        // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –≤—Ä—É—á–Ω—É—é
        const x = (1000 - img.width * scale) / 2;
        const y = (1000 - img.height * scale) / 2;
        imageElement.setAttribute('x', x);
        imageElement.setAttribute('y', y);
    }
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∑—É–º —á—Ç–æ–±—ã –≤–∏–¥–µ—Ç—å –≤—Å—ë –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
    this.setZoom(1);
}
            
removeImage() {
    const imageElement = document.getElementById('background-image');
    if (imageElement) imageElement.remove();
    
    this.state.image = null;
    this.state.imageUrl = null;
    this.state.imageForDisplay = null;
    
    this.imageCanvasCache = null;
    this.imageDataCache = null;
    
    document.getElementById('noImage').style.display = 'block';
    document.getElementById('imageControls').style.display = 'none';
    
    this.setZoom(1);
}
            
            // –ò–ù–°–¢–†–£–ú–ï–ù–¢–´
setTool(tool) {
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Å–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
    if (this.state.isDraggingPoint) {
        this.endPointDrag();
    }
    if (this.state.isDraggingBezierControl) {
        this.endBezierControlDrag();
    }
    
    // –í—Å–µ–≥–¥–∞ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º currentElement –ø—Ä–∏ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    this.state.currentElement = null;
    
    // –ï—Å–ª–∏ –í–´–•–û–î–ò–ú –∏–∑ —Ä–µ–∂–∏–º–∞ –ë–µ–∑—å–µ
    if (this.state.currentTool === 'bezier-points' && tool !== 'bezier-points') {
        this.deselectAllPoints();
        this.state.lastBezierDirection = null;
        this.state.lastBezierLength = null;
        
        // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        this.hideBezierHelpers();
        this.toggleBezierPoints(false);
    }
    
    // –ï—Å–ª–∏ –í–•–û–î–ò–ú –≤ —Ä–µ–∂–∏–º –ë–µ–∑—å–µ
    if (tool === 'bezier-points') {
        this.state.lastBezierDirection = null;
        this.state.lastBezierLength = null;
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
        this.showBezierHelpers();
        this.toggleBezierPoints(true);
        
        // –ï—Å–ª–∏ –µ—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ—ë
        if (this.state.bezierSelectedPoint !== null) {
            const point = this.state.bezierPoints[this.state.bezierSelectedPoint];
            if (point && point.element) {
                point.element.style.display = 'block';
                point.element.classList.add('selected');
            }
        }
    }
    
    this.state.currentTool = tool;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
    document.querySelectorAll('.tool-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    document.querySelector(`[data-tool="${tool}"]`).classList.add('active');

    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º/—Å–∫—Ä—ã–≤–∞–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    document.getElementById('penSettings').style.display = 
        tool === 'pen' ? 'block' : 'none';
    
    document.getElementById('pushSettings').style.display = 
        tool === 'push' ? 'block' : 'none';
    
    document.getElementById('eraserSettings').style.display = 
        tool === 'eraser' ? 'block' : 'none';
    
    // –û–ø—Ä–æ—Å–∏—Ç—å UI
    this.loadSettingsFromUI();
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫—É—Ä—Å–æ—Ä
    this.updateCursor();
    
    // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
    if (tool !== 'push') {
        this.hidePushIndicator();
    }
    if (tool !== 'eraser') {
        this.hideEraserIndicator();
    }
}

updateCursor() {
    if (!this.svg) return;
    
    if (this.state.currentTool === 'push') {
        this.svg.style.cursor = 'none';
    } else if (this.state.currentTool === 'eraser') {
        this.svg.style.cursor = 'crosshair'; // –ò–ª–∏ –º–æ–∂–Ω–æ —Å–≤–æ–π –∫—É—Ä—Å–æ—Ä –¥–ª—è –ª–∞—Å—Ç–∏–∫–∞
    } else if (this.state.currentTool === 'select') {
        this.svg.style.cursor = this.state.isMoving ? 'grabbing' : 'move';
    } else if (this.state.currentTool === 'bezier-points') {
            this.svg.style.cursor = 'crosshair';
    } else {
        this.svg.style.cursor = 'crosshair';
    }
}

showPushIndicator(x, y, radius) {
    let indicator = document.getElementById('push-indicator');
    
    if (!indicator) {
        indicator = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        indicator.id = 'push-indicator';
        indicator.setAttribute('stroke', '#ff6b6b');
        indicator.setAttribute('stroke-width', '1');
        indicator.setAttribute('fill', 'rgba(255, 107, 107, 0.1)');
        indicator.setAttribute('stroke-dasharray', '3,3');
        indicator.style.pointerEvents = 'none';
        this.svg.appendChild(indicator);
    }
    
    indicator.setAttribute('cx', x);
    indicator.setAttribute('cy', y);
    indicator.setAttribute('r', radius);
    indicator.style.display = 'block';
}

hidePushIndicator() {
    const indicator = document.getElementById('push-indicator');
    if (indicator) {
        indicator.style.display = 'none';
    }
}      

// –§—É–Ω–∫—Ü–∏—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ –ø—É—Ç—å
convertToPath(element) {
    let pathData = '';
    const stroke = element.getAttribute('stroke') || 'black';
    const strokeWidth = element.getAttribute('stroke-width') || '1';
    const fill = element.getAttribute('fill') || 'none';
    
    switch(element.tagName.toLowerCase()) {
        case 'line':
            const x1 = parseFloat(element.getAttribute('x1')) || 0;
            const y1 = parseFloat(element.getAttribute('y1')) || 0;
            const x2 = parseFloat(element.getAttribute('x2')) || 0;
            const y2 = parseFloat(element.getAttribute('y2')) || 0;
            
            pathData = `M ${x1} ${y1} L ${x2} ${y2}`;
            break;
            
        case 'rect':
            const rectX = parseFloat(element.getAttribute('x')) || 0;
            const rectY = parseFloat(element.getAttribute('y')) || 0;
            const width = parseFloat(element.getAttribute('width')) || 0;
            const height = parseFloat(element.getAttribute('height')) || 0;
            const rectRx = parseFloat(element.getAttribute('rx')) || 0;
            const rectRy = parseFloat(element.getAttribute('ry')) || 0;
            
            if (rectRx > 0 || rectRy > 0) {
                // –°–∫—Ä—É–≥–ª–µ–Ω–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫
                pathData = this.roundedRectToPath(rectX, rectY, width, height, rectRx, rectRy);
            } else {
                // –û–±—ã—á–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ - –¥–æ–±–∞–≤–ª—è–µ–º –±–æ–ª—å—à–µ —Ç–æ—á–µ–∫
                pathData = `M ${rectX} ${rectY} `;
                
                // –í–µ—Ä—Ö–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ - 4 —Å–µ–≥–º–µ–Ω—Ç–∞
                for (let i = 1; i <= 4; i++) {
                    pathData += `L ${rectX + (width * i / 4)} ${rectY} `;
                }
                
                // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ - 4 —Å–µ–≥–º–µ–Ω—Ç–∞
                for (let i = 1; i <= 4; i++) {
                    pathData += `L ${rectX + width} ${rectY + (height * i / 4)} `;
                }
                
                // –ù–∏–∂–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞ - 4 —Å–µ–≥–º–µ–Ω—Ç–∞
                for (let i = 1; i <= 4; i++) {
                    pathData += `L ${rectX + width - (width * i / 4)} ${rectY + height} `;
                }
                
                // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞ - 4 —Å–µ–≥–º–µ–Ω—Ç–∞
                for (let i = 1; i <= 4; i++) {
                    pathData += `L ${rectX} ${rectY + height - (height * i / 4)} `;
                }
                
                pathData += 'Z';
            }
            break;
            
        case 'circle':
            const cx = parseFloat(element.getAttribute('cx')) || 0;
            const cy = parseFloat(element.getAttribute('cy')) || 0;
            const radius = parseFloat(element.getAttribute('r')) || 0;
            
            // –ö—Ä—É–≥ -> –ø—É—Ç—å —Å –ë–û–õ–¨–®–ò–ú –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ–º —Ç–æ—á–µ–∫ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è
            const points = 32; // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å 16 –¥–æ 32 —Ç–æ—á–µ–∫
            pathData = `M ${cx + radius} ${cy}`;
            
            for (let i = 1; i <= points; i++) {
                const angle = (i / points) * Math.PI * 2;
                const px = cx + Math.cos(angle) * radius;
                const py = cy + Math.sin(angle) * radius;
                pathData += ` L ${px} ${py}`;
            }
            pathData += ' Z';
            break;
            
        case 'ellipse':
            const ellipseX = parseFloat(element.getAttribute('cx')) || 0;
            const ellipseY = parseFloat(element.getAttribute('cy')) || 0;
            const ellipseRx = parseFloat(element.getAttribute('rx')) || 0;
            const ellipseRy = parseFloat(element.getAttribute('ry')) || 0;
            
            // –≠–ª–ª–∏–ø—Å -> –ø—É—Ç—å —Å 32 —Ç–æ—á–∫–∞–º–∏
            const ellipsePoints = 32;
            pathData = `M ${ellipseX + ellipseRx} ${ellipseY}`;
            
            for (let i = 1; i <= ellipsePoints; i++) {
                const angle = (i / ellipsePoints) * Math.PI * 2;
                const px = ellipseX + Math.cos(angle) * ellipseRx;
                const py = ellipseY + Math.sin(angle) * ellipseRy;
                pathData += ` L ${px} ${py}`;
            }
            pathData += ' Z';
            break;
    }
    
    if (!pathData) return null;
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø—É—Ç—å
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', pathData);
    path.setAttribute('stroke', stroke);
    path.setAttribute('stroke-width', strokeWidth);
    path.setAttribute('fill', fill);
    path.setAttribute('stroke-linecap', element.getAttribute('stroke-linecap') || 'round');
    path.setAttribute('stroke-linejoin', element.getAttribute('stroke-linejoin') || 'round');
    
    return path;
}

roundedRectToPath(x, y, width, height, cornerRx, cornerRy) {
    // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–¥–∏—É—Å—ã
    cornerRx = Math.min(cornerRx, width / 2);
    cornerRy = Math.min(cornerRy, height / 2);
    
    let pathData = '';
    
    // –ù–∞—á–∏–Ω–∞–µ–º —Å –ø—Ä–∞–≤–æ–≥–æ –Ω–∏–∂–Ω–µ–≥–æ —É–≥–ª–∞ (—Å —É—á–µ—Ç–æ–º —Å–∫—Ä—É–≥–ª–µ–Ω–∏—è)
    pathData = `M ${x + width - cornerRx} ${y}`;
    
    // –í–µ—Ä—Ö–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞
    pathData += `H ${x + cornerRx}`;
    
    // –õ–µ–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
    if (cornerRx > 0 && cornerRy > 0) {
        pathData += `A ${cornerRx} ${cornerRy} 0 0 1 ${x} ${y + cornerRy}`;
    } else {
        pathData += `L ${x} ${y}`;
    }
    
    // –õ–µ–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
    pathData += `V ${y + height - cornerRy}`;
    
    // –õ–µ–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
    if (cornerRx > 0 && cornerRy > 0) {
        pathData += `A ${cornerRx} ${cornerRy} 0 0 1 ${x + cornerRx} ${y + height}`;
    } else {
        pathData += `L ${x} ${y + height}`;
    }
    
    // –ù–∏–∂–Ω—è—è —Å—Ç–æ—Ä–æ–Ω–∞
    pathData += `H ${x + width - cornerRx}`;
    
    // –ü—Ä–∞–≤—ã–π –Ω–∏–∂–Ω–∏–π —É–≥–æ–ª
    if (cornerRx > 0 && cornerRy > 0) {
        pathData += `A ${cornerRx} ${cornerRy} 0 0 1 ${x + width} ${y + height - cornerRy}`;
    } else {
        pathData += `L ${x + width} ${y + height}`;
    }
    
    // –ü—Ä–∞–≤–∞—è —Å—Ç–æ—Ä–æ–Ω–∞
    pathData += `V ${y + cornerRy}`;
    
    // –ü—Ä–∞–≤—ã–π –≤–µ—Ä—Ö–Ω–∏–π —É–≥–æ–ª
    if (cornerRx > 0 && cornerRy > 0) {
        pathData += `A ${cornerRx} ${cornerRy} 0 0 1 ${x + width - cornerRx} ${y}`;
    } else {
        pathData += `L ${x + width} ${y}`;
    }
    
    pathData += ' Z';
    return pathData;
}


// –ü–∞—Ä—Å–∏–Ω–≥ –ø—É—Ç–∏ –≤ —Ç–æ—á–∫–∏
parsePathToPoints(d) {
    if (!d || d.trim() === '') {
        return { points: [], isClosed: false };
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à (Map –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Å—Ç—Ä–æ–∫–∏ –∫–∞–∫ –∫–ª—é—á–∏)
    if (this.pathCache.has(d)) {
        return this.pathCache.get(d);
    }
    
    const isClosed = d.includes(' Z') || d.includes('z');
    
    try {
        const points = [];
        const numbers = d.match(/[+-]?\d*\.?\d+(?:[eE][+-]?\d+)?/g) || [];
        
        for (let i = 0; i < numbers.length; i += 2) {
            if (i + 1 < numbers.length) {
                points.push({
                    x: parseFloat(numbers[i]),
                    y: parseFloat(numbers[i + 1])
                });
            }
        }
        
        const result = { points, isClosed };
        
        // –ö—ç—à–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è —á–∞—Å—Ç–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –ø—É—Ç–µ–π
        if (d.length < 1000) {
            this.pathCache.set(d, result);
        }
        
        return result;
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –ø—É—Ç–∏:', error, d);
        return { points: [], isClosed: false };
    }
}

// –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ —Ç–æ—á–µ–∫ –≤ –ø—É—Ç—å
pointsToPath(points, wasOriginallyClosed = false) {
    if (points.length === 0) return '';
    
    let pathData = `M ${points[0].x} ${points[0].y}`;
    
    for (let i = 1; i < points.length; i++) {
        pathData += ` L ${points[i].x} ${points[i].y}`;
    }
    
    // –ó–∞–∫—Ä—ã–≤–∞–µ–º –ø—É—Ç—å –¢–û–õ–¨–ö–û –µ—Å–ª–∏ –æ–Ω –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –±—ã–ª –∑–∞–∫—Ä—ã—Ç
    if (wasOriginallyClosed && points.length > 2) {
        pathData += ' Z';
    }
    
    return pathData;
}

insertPointIntoPath(path, afterIndex, x, y) {
    const d = path.getAttribute('d');
    if (!d) return -1;
    
    const { points, isClosed } = this.parsePathToPoints(d);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–æ—á–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç —É–∂–µ
    const tolerance = 0.1;
    const exists = points.some(p => 
        Math.abs(p.x - x) < tolerance && Math.abs(p.y - y) < tolerance
    );
    
    if (exists) return -1;
    
    if (afterIndex >= 0 && afterIndex < points.length) {
        // –í—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É
        points.splice(afterIndex + 1, 0, {x: x, y: y});
        
        // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø—É—Ç—å
        const newPath = this.pointsToPath(points, isClosed);
        path.setAttribute('d', newPath);
        
        return afterIndex + 1;
    }
    
    return -1;
}



// –§—É–Ω–∫—Ü–∏—è —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ –æ—Ç—Ä–µ–∑–∫–∞
distanceToSegment(px, py, x1, y1, x2, y2) {
    const A = px - x1;
    const B = py - y1;
    const C = x2 - x1;
    const D = y2 - y1;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) param = dot / lenSq;

    let xx, yy;

    if (param < 0) {
        xx = x1;
        yy = y1;
    } else if (param > 1) {
        xx = x2;
        yy = y2;
    } else {
        xx = x1 + param * C;
        yy = y1 + param * D;
    }

    const dx = px - xx;
    const dy = py - yy;
    
    return Math.sqrt(dx * dx + dy * dy);
}

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
findVectorByControlPoint(controlType, belongsToPointIndex) {
    // –ù–∞—Ö–æ–¥–∏–º –í–°–ï –≤–µ–∫—Ç–æ—Ä—ã, –≥–¥–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ç–æ—á–∫–µ
    const results = [];
    
    for (let i = 0; i < this.state.bezierVectors.length; i++) {
        const vector = this.state.bezierVectors[i];
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –í–°–ï —Å–≤—è–∑–∏:
        
        // 1. –ï—Å–ª–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ 1 –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ç–æ—á–∫–µ
        if (controlType === 'control1' && vector.control1.belongsTo === belongsToPointIndex) {
            results.push({ vector, index: i, type: 'control1' });
        }
        
        // 2. –ï—Å–ª–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ 2 –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —É–∫–∞–∑–∞–Ω–Ω–æ–π —Ç–æ—á–∫–µ
        if (controlType === 'control2' && vector.control2.belongsTo === belongsToPointIndex) {
            results.push({ vector, index: i, type: 'control2' });
        }
        
        // 3. –¢–∞–∫–∂–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—Ä–∞—Ç–Ω—ã–µ —Å–≤—è–∑–∏
        // (—Ç–æ—á–∫–∞ –º–æ–∂–µ—Ç –±—ã—Ç—å –∫–æ–Ω—Ü–æ–º –≤–µ–∫—Ç–æ—Ä–∞ –∏ –∏–º–µ—Ç—å control2, –∫–æ—Ç–æ—Ä—ã–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏ connectedTo –¥—Ä—É–≥—É—é —Ç–æ—á–∫—É)
        if (controlType === 'control2' && vector.to === belongsToPointIndex) {
            results.push({ vector, index: i, type: 'control2' });
        }
        
        if (controlType === 'control1' && vector.from === belongsToPointIndex) {
            results.push({ vector, index: i, type: 'control1' });
        }
    }
    
    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –ø–µ—Ä–≤—ã–π –Ω–∞–π–¥–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
    return results.length > 0 ? results[0] : null;
}


            // –ú–´–®–¨
onMouseDown(e) {
        const coords = this.getSVGCoordinates(e);
        const target = e.target;
        
    // 1. –†–µ–∂–∏–º –ë–µ–∑—å–µ —Ç–æ—á–µ–∫
    if (this.state.currentTool === 'bezier-points') {
        e.preventDefault();
        e.stopPropagation();
        
        // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–π —Ç–æ—á–∫–µ - –æ–Ω–∞ —É–∂–µ –æ–±—Ä–∞–±–æ—Ç–∞–µ—Ç—Å—è –≤ —Å–≤–æ–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–µ
        if (target.classList.contains('bezier-point')) {
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞ —Å–∞–º–æ–π —Ç–æ—á–∫–µ —É–∂–µ —Å–¥–µ–ª–∞–µ—Ç –≤—Å—ë –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ–µ
            return;
        }
        
        // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ –ø—É—Å—Ç–æ–º—É –º–µ—Å—Ç—É
        if (target === this.svg || target.id === 'background-image') {
            // –ï—Å–ª–∏ –ï–°–¢–¨ –≤—ã–¥–µ–ª–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ - —Å–æ–∑–¥–∞–µ–º –≤–µ–∫—Ç–æ—Ä –æ—Ç –Ω–µ—ë
            if (this.state.bezierSelectedPoint !== null) {
                this.createNewBezierVector(coords.x, coords.y);
            } 
            // –ï—Å–ª–∏ –ù–ï–¢ –≤—ã–¥–µ–ª–µ–Ω–Ω–æ–π —Ç–æ—á–∫–∏ - —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
            else {
                this.createSingleBezierPoint(coords.x, coords.y);
            }
            return;
        }
        
        return;
    }
    
    if (this.state.currentTool === 'select') {
        e.preventDefault();
        this.startPanning(e);
        return;
    }
    
if (this.state.currentTool === 'push') {
    e.preventDefault();
    
    const radius = this.state.pushRadius / this.state.zoom;
    const allElements = Array.from(this.svg.children)
        .filter(el => {
            const tag = el.tagName.toLowerCase();
            
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø–æ ID
            if (el.id && (el.id.includes('background') || el.id.includes('indicator'))) {
                return false;
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∞—Å—Å —á–µ—Ä–µ–∑ getAttribute (–±–æ–ª–µ–µ –Ω–∞–¥–µ–∂–Ω–æ –¥–ª—è SVG)
            const classAttr = el.getAttribute('class') || '';
            
            // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ë–µ–∑—å–µ
            if (classAttr.includes('bezier-guide-line') || 
                classAttr.includes('bezier-control-point') || 
                classAttr.includes('bezier-point')) {
                return false;
            }
            
            // –û—Å–Ω–æ–≤–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã –ë–µ–∑—å–µ - –æ—Å—Ç–∞–≤–ª—è–µ–º
            if (tag === 'path' && classAttr.includes('bezier-vector')) {
                return true;
            }
            
            // –û–±—ã—á–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            return (tag === 'path' || tag === 'line' || tag === 'rect' || tag === 'circle');
        });
    
    const affectedPoints = [];
    
    allElements.forEach(element => {
        // –ü—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞—Ç—å –≤ path –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
        if (element.tagName !== 'PATH') {
            const path = this.convertToPath(element);
            if (path) {
                element.parentNode.replaceChild(path, element);
                element = path;
            }
        }
        
        const path = element;
        const d = path.getAttribute('d');
        if (!d) return;
        
        const { points: currentPoints, isClosed } = this.parsePathToPoints(d);
        
        // 1. –ù–∞–π—Ç–∏ –≤—Å–µ —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –£–ñ–ï –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞
        const existingPointsInCircle = [];
        for (let i = 0; i < currentPoints.length; i++) {
            const point = currentPoints[i];
            const distance = Math.sqrt(
                Math.pow(coords.x - point.x, 2) + 
                Math.pow(coords.y - point.y, 2)
            );
            
            if (distance <= radius) {
                existingPointsInCircle.push({
                    pointIndex: i,
                    point: point,
                    distance: distance
                });
            }
        }
        
        // 2. –ï—Å–ª–∏ —Ç–æ—á–µ–∫ –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞ –ú–ê–õ–û (<5)
        if (existingPointsInCircle.length < 5) {
            // –ù–∞–π—Ç–∏ –ë–õ–ò–ñ–ê–ô–®–ò–ô –æ—Ç—Ä–µ–∑–æ–∫ –∫ —Ü–µ–Ω—Ç—Ä—É –∫—Ä—É–≥–∞
            let closestSegment = null;
            let minDistance = Infinity;
            let segmentIndex = -1;
            
            for (let i = 0; i < currentPoints.length; i++) {
                const p1 = currentPoints[i];
                const p2 = currentPoints[(i + 1) % currentPoints.length];
                
                if (!isClosed && i === currentPoints.length - 1) break;
                
                const segmentDistance = this.distanceToSegment(coords.x, coords.y, p1.x, p1.y, p2.x, p2.y);
                if (segmentDistance < minDistance && segmentDistance <= radius) {
                    minDistance = segmentDistance;
                    closestSegment = { p1, p2 };
                    segmentIndex = i;
                }
            }
            
            if (closestSegment && segmentIndex !== -1) {
                // 3. –ù–∞–π—Ç–∏ –≥–¥–µ –æ—Ç—Ä–µ–∑–æ–∫ –≤—Ö–æ–¥–∏—Ç –∏ –≤—ã—Ö–æ–¥–∏—Ç –∏–∑ –∫—Ä—É–≥–∞
                const intersections = this.circleSegmentIntersections(
                    coords.x, coords.y, radius, 
                    closestSegment.p1.x, closestSegment.p1.y, 
                    closestSegment.p2.x, closestSegment.p2.y
                );
                
                let tStart = 0;
                let tEnd = 1;
                
                if (intersections.length >= 2) {
                    tStart = Math.max(0, intersections[0].t - 0.1);
                    tEnd = Math.min(1, intersections[1].t + 0.1);
                } else if (intersections.length === 1) {
                    // –ï—Å–ª–∏ –æ–¥–Ω–∞ —Ç–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                    const d1 = Math.sqrt(Math.pow(coords.x - closestSegment.p1.x, 2) + Math.pow(coords.y - closestSegment.p1.y, 2));
                    const d2 = Math.sqrt(Math.pow(coords.x - closestSegment.p2.x, 2) + Math.pow(coords.y - closestSegment.p2.y, 2));
                    
                    if (d1 <= radius) {
                        tStart = 0;
                        tEnd = Math.min(1, intersections[0].t + 0.1);
                    } else if (d2 <= radius) {
                        tStart = Math.max(0, intersections[0].t - 0.1);
                        tEnd = 1;
                    }
                }
                
                // 4. –ü–û–î–ì–û–¢–û–í–ò–¢–¨ –≤—Å–µ —Ç–æ—á–∫–∏ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏
                const pointsToInsert = [];
                
                // –¢–æ—á–∫–∏ –î–û –∫—Ä—É–≥–∞ (–∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ)
                pointsToInsert.push({
                    t: tStart - 0.2,
                    type: 'anchor-before'
                });
                pointsToInsert.push({
                    t: tStart - 0.1,
                    type: 'anchor-before'
                });
                
                // –¢–æ—á–∫–∏ –í–ù–£–¢–†–ò –∫—Ä—É–≥–∞ (5 —Ç–æ—á–µ–∫ —Ä–∞–≤–Ω–æ–º–µ—Ä–Ω–æ)
                const numPointsInside = 5;
                for (let i = 1; i <= numPointsInside; i++) {
                    const t = tStart + (tEnd - tStart) * (i / (numPointsInside + 1));
                    pointsToInsert.push({
                        t: t,
                        type: 'inside'
                    });
                }
                
                // –¢–æ—á–∫–∏ –ü–û–°–õ–ï –∫—Ä—É–≥–∞ (–∑–∞–∫—Ä–µ–ø–ª–µ–Ω–Ω—ã–µ)
                pointsToInsert.push({
                    t: tEnd + 0.1,
                    type: 'anchor-after'
                });
                pointsToInsert.push({
                    t: tEnd + 0.2,
                    type: 'anchor-after'
                });
                
                // 5. –í–°–¢–ê–í–ò–¢–¨ –≤—Å–µ —Ç–æ—á–∫–∏ –û–î–ù–ò–ú –ø—Ä–æ—Ö–æ–¥–æ–º (–æ—Ç –∫–æ–Ω—Ü–∞ –∫ –Ω–∞—á–∞–ª—É)
                // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ—á–∫–∏ –ø–æ t (–æ—Ç –±–æ–ª—å—à–µ–≥–æ –∫ –º–µ–Ω—å—à–µ–º—É)
                pointsToInsert.sort((a, b) => b.t - a.t);
                
                // –ù–∞—á–∏–Ω–∞–µ–º –≤—Å—Ç–∞–≤–ª—è—Ç—å —Å –ö–û–ù–¶–ê, —á—Ç–æ–±—ã –∏–Ω–¥–µ–∫—Å—ã –Ω–µ —Å–±–∏–≤–∞–ª–∏—Å—å
                pointsToInsert.forEach(pointToInsert => {
                    if (pointToInsert.t >= 0 && pointToInsert.t <= 1) {
                        const x = closestSegment.p1.x + (closestSegment.p2.x - closestSegment.p1.x) * pointToInsert.t;
                        const y = closestSegment.p1.y + (closestSegment.p2.y - closestSegment.p1.y) * pointToInsert.t;
                        
                        // –í—Å—Ç–∞–≤–ª—è–µ–º –ü–û–°–õ–ï segmentIndex
                        this.insertPointIntoPath(path, segmentIndex, x, y);
                    }
                });
            }
        }
        
        // 6. –ü–æ—Å–ª–µ –≤—Å–µ—Ö –≤—Å—Ç–∞–≤–æ–∫, –Ω–∞–π—Ç–∏ –í–°–ï —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞
        const finalD = path.getAttribute('d');
        const { points: finalPoints } = this.parsePathToPoints(finalD);
        
        for (let i = 0; i < finalPoints.length; i++) {
            const point = finalPoints[i];
            const distance = Math.sqrt(
                Math.pow(coords.x - point.x, 2) + 
                Math.pow(coords.y - point.y, 2)
            );
            
            if (distance <= radius) {
                affectedPoints.push({
                    path: path,
                    pointIndex: i,
                    x: point.x,
                    y: point.y,
                    originalX: point.x,
                    originalY: point.y,
                    distance: distance
                });
            }
        }
    });
    
    if (affectedPoints.length > 0) {
        this.state.isDrawing = true;
        this.pushData = {
            points: affectedPoints,
            mouseStartX: coords.x,
            mouseStartY: coords.y,
            radius: radius
        };
        
        this.showPushIndicator(coords.x, coords.y, radius);
    }
    
    return;
}

    // –ù–û–í–û–ï: –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –ª–∞—Å—Ç–∏–∫
if (this.state.currentTool === 'eraser') {
    e.preventDefault();
    this.state.isDrawing = true;
    this.state.lastErasePoint = {x: coords.x, y: coords.y}; // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Ç–æ—á–∫—É
    
    // –°—Ä–∞–∑—É —É–¥–∞–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä—ã –ø–æ–¥ –∫—É—Ä—Å–æ—Ä–æ–º
    this.eraseVectorsAt(coords.x, coords.y);
    return;
}
	
    this.state.isDrawing = true;
    
    // –î–õ–Ø –ö–ê–†–ê–ù–î–ê–®–ê: 
if (this.state.currentTool === 'pen') {
    // –ï—Å–ª–∏ –í–´–ö–õ–Æ–ß–ï–ù–û –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ - –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –ø—É—Ç—å
    if (!this.snapSettings.continueVector) {
        this.state.currentElement = null;
    }
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å currentElement –∏ –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –í–ö–õ–Æ–ß–ï–ù–û
        if (this.snapSettings.continueVector && this.state.currentElement) {
            // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É —Ç–µ–∫—É—â–µ–≥–æ –ø—É—Ç–∏
            const d = this.state.currentElement.getAttribute('d');
            if (d) {
                const points = d.match(/[\d.-]+/g);
                if (points && points.length >= 2) {
                    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                    const lastX = parseFloat(points[points.length - 2]);
                    const lastY = parseFloat(points[points.length - 1]);
                    
                    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é —Ç–æ—á–∫—É –∫–∞–∫ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É –ø—É—Ç–∏
                    this.state.startPoint = {x: lastX, y: lastY};
                    
                    // –ù–∞—á–∏–Ω–∞–µ–º —Ä–∏—Å–æ–≤–∞—Ç—å —Å —ç—Ç–æ–π —Ç–æ—á–∫–∏
                    this.state.penPoints = [{x: lastX, y: lastY}];
                    return;
                }
            }
        }
    
    // –ù–û–í–´–ô –ö–û–î: –ù–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π –ø—É—Ç—å –∫–∞—Ä–∞–Ω–¥–∞—à–∞ –∏ –µ–≥–æ —Ä–µ–∞–ª—å–Ω—É—é –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É
    if (this.snapSettings.continueVector) {
        // –ò—â–µ–º –≤—Å–µ –ø—É—Ç–∏ –∫–∞—Ä–∞–Ω–¥–∞—à–∞ (–æ–±—ã—á–Ω–æ —ç—Ç–æ –ø—É—Ç–∏ –±–µ–∑ fill)
        const allPaths = Array.from(this.svg.querySelectorAll('path'))
            .filter(path => {
                const fill = path.getAttribute('fill');
                const stroke = path.getAttribute('stroke');
                // –≠—Ç–æ –ø—É—Ç—å –∫–∞—Ä–∞–Ω–¥–∞—à–∞ –µ—Å–ª–∏: –Ω–µ—Ç fill –∏–ª–∏ fill='none', –∏ –µ—Å—Ç—å stroke
                return (!fill || fill === 'none') && stroke && 
                       !path.id?.includes('indicator') && 
                       !path.id?.includes('background');
            });
        
        if (allPaths.length > 0) {
            // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π –¥–æ–±–∞–≤–ª–µ–Ω–Ω—ã–π –ø—É—Ç—å (–ø—Ä–µ–¥–ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π –Ω–∞—Ä–∏—Å–æ–≤–∞–Ω–Ω—ã–π)
            const lastPath = allPaths[allPaths.length - 1];
            
            // –ü–æ–ª—É—á–∞–µ–º –µ–≥–æ —Ç–æ—á–∫–∏
            const d = lastPath.getAttribute('d');
            if (d) {
                // –ü–∞—Ä—Å–∏–º –ø—É—Ç—å —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ –ø–æ—Å–ª–µ–¥–Ω—é—é —Ç–æ—á–∫—É
                const { points } = this.parsePathToPoints(d);
                
                if (points.length > 0) {
                    // –ë–µ—Ä–µ–º –ü–û–°–õ–ï–î–ù–Æ–Æ —Ç–æ—á–∫—É –ø—É—Ç–∏
                    const lastPoint = points[points.length - 1];
                    
                    // –ù–∞—á–∏–Ω–∞–µ–º —Å —ç—Ç–æ–π —Ç–æ—á–∫–∏
                    this.state.currentElement = lastPath;
                    this.state.startPoint = {x: lastPoint.x, y: lastPoint.y};
                    this.state.penPoints = [{x: lastPoint.x, y: lastPoint.y}];
                    return;
                }
            }
        }
    }
    
    // –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–∏ - –Ω–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—ã–π –ø—É—Ç—å
    this.state.startPoint = {x: coords.x, y: coords.y};
    this.startPen(coords.x, coords.y);
    return;
}
    // –ù–ê–ß–ò–ù–ê–ï–ú –ù–û–í–´–ô –ü–£–¢–¨ (–µ—Å–ª–∏ –Ω–µ –ø—Ä–æ–¥–æ–ª–∂–∏–ª–∏ —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π)
    this.state.startPoint = {x: coords.x, y: coords.y};
    
    switch(this.state.currentTool) {
        case 'pen':
            this.startPen(coords.x, coords.y);
            break;
        case 'line':
            this.startLine(coords.x, coords.y);
            break;
        case 'rect':
            this.startRect(coords.x, coords.y);
            break;
        case 'circle':
            this.startCircle(coords.x, coords.y);
            break;
    }
}
 
onMouseMove(e) {
    this.updateCoordinates(e);
    const coords = this.getSVGCoordinates(e);
    
    if (this.state.isMoving) {
        e.preventDefault();
        this.doPanning(e);
        return;
    }
    if (this.state.currentTool === 'bezier-points') {
        if (this.state.isDraggingPoint) {
            this.updatePointDrag(coords.x, coords.y);
            return;
        }
        
        if (this.state.isDraggingBezierControl) {
            this.updateBezierControlDrag(coords.x, coords.y);
            return;
        }
    }
    // –î–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ø—É—à: –æ–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏
	if (this.state.currentTool === 'push') {
		const radius = this.state.pushRadius / this.state.zoom;
		
		if (!this.state.isDrawing) {
			this.showPushIndicator(coords.x, coords.y, radius);
		} else if (this.state.isDrawing && this.pushData) {
			const dx = coords.x - this.pushData.mouseStartX;
			const dy = coords.y - this.pushData.mouseStartY;
			
			// –î–≤–∏–≥–∞–µ–º –í–°–ï —Ç–æ—á–∫–∏, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞ –ø—Ä–∏ –Ω–∞–∂–∞—Ç–∏–∏
			this.pushData.points.forEach(pointData => {
				const force = Math.max(0, 1 - (pointData.distance / this.pushData.radius));
				
				if (force > 0.05) {
					const newX = pointData.originalX + dx * force * this.state.pushStrength;
					const newY = pointData.originalY + dy * force * this.state.pushStrength;
					
					this.updatePathPointFast(pointData.path, pointData.pointIndex, newX, newY);
					
					pointData.x = newX;
					pointData.y = newY;
				}
			});
			
			this.showPushIndicator(coords.x, coords.y, this.pushData.radius);
		}
	}

	
    //–î–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞ –ª–∞—Å—Ç–∏–∫
	if (this.state.currentTool === 'eraser') {
		const radius = this.state.eraserSize / this.state.zoom;
		
		// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä (—ç—Ç–æ –ª–µ–≥–∫–∞—è –æ–ø–µ—Ä–∞—Ü–∏—è, –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å)
		this.showEraserIndicator(coords.x, coords.y, radius);
		
		// –ï—Å–ª–∏ –Ω–∞–∂–∞—Ç–∞ –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏ –ò –ø—Ä–æ—à–ª–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –≤—Ä–µ–º–µ–Ω–∏ —Å –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å—Ç–∏—Ä–∞–Ω–∏—è
		if (this.state.isDrawing) {
			// –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ —Å—Ç–∏—Ä–∞–Ω–∏—è
			if (this.state.lastErasePoint) {
				const distance = Math.sqrt(
					Math.pow(coords.x - this.state.lastErasePoint.x, 2) + 
					Math.pow(coords.y - this.state.lastErasePoint.y, 2)
				);
				
				// –°—Ç–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç—ä–µ—Ö–∞–ª–∏ –Ω–∞ –∑–Ω–∞—á–∏—Ç–µ–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ
				// –≠—Ç–æ —É–º–µ–Ω—å—à–∏—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤—ã–∑–æ–≤–æ–≤
				if (distance > radius / 2) {
					this.eraseVectorsAt(coords.x, coords.y);
					this.state.lastErasePoint = {x: coords.x, y: coords.y};
				}
			} else {
				this.eraseVectorsAt(coords.x, coords.y);
				this.state.lastErasePoint = {x: coords.x, y: coords.y};
			}
		}
	}

    // –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∏—Å–æ–≤–∞–Ω–∏–µ (–µ—Å–ª–∏ —Ä–∏—Å—É–µ–º)
    if (this.state.isDrawing) {
        switch(this.state.currentTool) {
        case 'pen':
            this.drawPen(coords.x, coords.y);
            break;
        case 'line':
            this.updateLine(coords.x, coords.y);
            break;
        case 'rect':
            this.updateRect(coords.x, coords.y);
            break;
        case 'circle':
            this.updateCircle(coords.x, coords.y);
            break;
        }
    }
}

updatePathPointFast(path, pointIndex, newX, newY) {
    // –ï—Å–ª–∏ —ç—Ç–æ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ (–¥—Ä–æ–±–Ω—ã–π –∏–Ω–¥–µ–∫—Å) - –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç—å
    // –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç —Ç–æ–ª—å–∫–æ –¥–ª—è –¥–≤–∏–∂–µ–Ω–∏—è, –Ω–æ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è
    if (pointIndex % 1 !== 0) {
        return; // –í–∏—Ä—Ç—É–∞–ª—å–Ω–∞—è —Ç–æ—á–∫–∞ - –Ω–µ –æ–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç—å
    }
    
    const d = path.getAttribute('d');
    if (!d) return;
    
    const parts = d.split(/(?=[ML])/);
    let currentIdx = 0;
    
    for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const coords = part.substring(1).trim().split(/\s+/);
        
        for (let j = 0; j < coords.length; j += 2) {
            if (currentIdx === Math.floor(pointIndex)) {
                coords[j] = newX;
                coords[j + 1] = newY;
                parts[i] = part.charAt(0) + ' ' + coords.join(' ');
                path.setAttribute('d', parts.join(''));
                return;
            }
            currentIdx++;
        }
    }
}

// –§—É–Ω–∫—Ü–∏—è —Ä–∞–∑—Ä–µ–∑–∞–Ω–∏—è –ø—É—Ç–∏ –≤ –º–µ—Å—Ç–∞—Ö –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å –∫—Ä—É–≥–æ–º –ª–∞—Å—Ç–∏–∫–∞
cutPathAtIntersections(path, x, y, radius) {
    const d = path.getAttribute('d');
    if (!d) return null;
    
    const { points, isClosed } = this.parsePathToPoints(d);
    if (points.length < 2) return null;
    
    const intersections = [];
    
    // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–æ–≤ –ø—É—Ç–∏ —Å –∫—Ä—É–≥–æ–º –ª–∞—Å—Ç–∏–∫–∞
    for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        
        // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω–∏–π –æ—Ç—Ä–µ–∑–æ–∫ –≤ –Ω–µ–∑–∞–º–∫–Ω—É—Ç–æ–º –ø—É—Ç–∏
        if (!isClosed && i === points.length - 1) break;
        
        const intersection = this.lineCircleIntersection(p1, p2, {x, y}, radius);
        if (intersection.length > 0) {
            // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ç–æ–º, —Å –∫–∞–∫–æ–π —Å—Ç–æ—Ä–æ–Ω—ã –æ—Ç—Ä–µ–∑–∫–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –∫—Ä—É–≥
            intersection.forEach(inter => {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ª–∏ –∫–∞–∫–∞—è-—Ç–æ –∏–∑ –∫–æ–Ω—Ü–µ–≤—ã—Ö —Ç–æ—á–µ–∫ –≤–Ω—É—Ç—Ä–∏ —Ä–∞–¥–∏—É—Å–∞
                const p1InRadius = this.pointDistance(p1, {x, y}) <= radius;
                const p2InRadius = this.pointDistance(p2, {x, y}) <= radius;
                
                intersections.push({
                    point: inter,
                    segmentIndex: i,
                    p1: p1,
                    p2: p2,
                    p1InRadius: p1InRadius,
                    p2InRadius: p2InRadius
                });
            });
        } else {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞—Ö–æ–¥—è—Ç—Å—è –ª–∏ –∫–æ–Ω—Ü–µ–≤—ã–µ —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ —Ä–∞–¥–∏—É—Å–∞
            const p1InRadius = this.pointDistance(p1, {x, y}) <= radius;
            const p2InRadius = this.pointDistance(p2, {x, y}) <= radius;
            
            if (p1InRadius || p2InRadius) {
                intersections.push({
                    point: p1InRadius ? p1 : p2,
                    segmentIndex: i,
                    p1: p1,
                    p2: p2,
                    p1InRadius: p1InRadius,
                    p2InRadius: p2InRadius,
                    isEndpoint: true
                });
            }
        }
    }
    
    // –ï—Å–ª–∏ –Ω–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π - –ø—Ä–æ–≤–µ—Ä—è–µ–º, –ø–æ–ª–Ω–æ—Å—Ç—å—é –ª–∏ –ø—É—Ç—å –≤–Ω—É—Ç—Ä–∏ —Ä–∞–¥–∏—É—Å–∞
    if (intersections.length === 0) {
        const allPointsInRadius = points.every(point => 
            this.pointDistance(point, {x, y}) <= radius
        );
        
        if (allPointsInRadius) {
            return 'delete';
        }
        return null;
    }
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –≤–¥–æ–ª—å –ø—É—Ç–∏
    const allIntersectionPoints = [];
    intersections.forEach(item => {
        // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏—é –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ (0-1)
        let t = 0;
        if (!item.isEndpoint) {
            t = this.pointOnSegmentParameter(item.p1, item.p2, item.point);
        } else {
            t = item.p1InRadius ? 0 : 1;
        }
        
        allIntersectionPoints.push({
            point: item.point,
            segmentIndex: item.segmentIndex,
            t: t,
            isEndpoint: item.isEndpoint || false,
            p1InRadius: item.p1InRadius,
            p2InRadius: item.p2InRadius
        });
    });
    
    // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–æ –∏–Ω–¥–µ–∫—Å—É —Å–µ–≥–º–µ–Ω—Ç–∞ –∏ –ø–æ–∑–∏—Ü–∏–∏ –Ω–∞ –Ω–µ–º
    allIntersectionPoints.sort((a, b) => {
        if (a.segmentIndex !== b.segmentIndex) {
            return a.segmentIndex - b.segmentIndex;
        }
        return a.t - b.t;
    });
    
    // –†–∞–∑—Ä–µ–∑–∞–µ–º –ø—É—Ç—å –Ω–∞ —á–∞—Å—Ç–∏
    const pathParts = this.splitPathAtIntersections(points, allIntersectionPoints, isClosed);
    
    // –§–∏–ª—å—Ç—Ä—É–µ–º —á–∞—Å—Ç–∏: —É–¥–∞–ª—è–µ–º —Ç–µ, —á—Ç–æ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ —Ä–∞–¥–∏—É—Å–∞, –æ—Å—Ç–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–µ
    const filteredParts = pathParts.filter(part => {
        if (part.points.length === 0) return false;
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Ç–æ—á–µ–∫ –≤–¥–æ–ª—å —á–∞—Å—Ç–∏ –ø—É—Ç–∏
        const checkPoints = [
            part.points[0],
            part.points[Math.floor(part.points.length / 2)],
            part.points[part.points.length - 1]
        ];
        
        // –ï—Å–ª–∏ –≤—Å–µ –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã–µ —Ç–æ—á–∫–∏ –≤–Ω—É—Ç—Ä–∏ —Ä–∞–¥–∏—É—Å–∞ - —É–¥–∞–ª—è–µ–º —á–∞—Å—Ç—å
        const allInside = checkPoints.every(point => 
            this.pointDistance(point, {x, y}) <= radius
        );
        
        return !allInside;
    });
    
    // –ï—Å–ª–∏ –≤—Å–µ —á–∞—Å—Ç–∏ —É–¥–∞–ª–µ–Ω—ã - —É–¥–∞–ª—è–µ–º –≤–µ—Å—å –ø—É—Ç—å
    if (filteredParts.length === 0) {
        return 'delete';
    }
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø—É—Ç–∏ –∏–∑ –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —á–∞—Å—Ç–µ–π
    const newPaths = [];
    filteredParts.forEach(part => {
        if (part.points.length >= 2) {
            newPaths.push(this.pointsToPath(part.points, false));
        }
    });
    
    return newPaths;
}

// –ü–æ–∏—Å–∫ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –ª–∏–Ω–∏–∏ —Å –∫—Ä—É–≥–æ–º
lineCircleIntersection(p1, p2, center, radius) {
    const intersections = [];
    
    // –í–µ–∫—Ç–æ—Ä –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ç—Ä–µ–∑–∫–∞
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    
    // –ö–≤–∞–¥—Ä–∞—Ç–∏—á–Ω–æ–µ —É—Ä–∞–≤–Ω–µ–Ω–∏–µ –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
    const A = dx * dx + dy * dy;
    const B = 2 * (dx * (p1.x - center.x) + dy * (p1.y - center.y));
    const C = (p1.x - center.x) * (p1.x - center.x) + 
              (p1.y - center.y) * (p1.y - center.y) - 
              radius * radius;
    
    const discriminant = B * B - 4 * A * C;
    
    if (discriminant < 0) {
        // –ù–µ—Ç –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–π
        return intersections;
    }
    
    const t1 = (-B - Math.sqrt(discriminant)) / (2 * A);
    const t2 = (-B + Math.sqrt(discriminant)) / (2 * A);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ (0 <= t <= 1)
    if (t1 >= 0 && t1 <= 1) {
        intersections.push({
            x: p1.x + t1 * dx,
            y: p1.y + t1 * dy
        });
    }
    
    if (t2 >= 0 && t2 <= 1 && Math.abs(t1 - t2) > 0.001) {
        intersections.push({
            x: p1.x + t2 * dx,
            y: p1.y + t2 * dy
        });
    }
    
    return intersections;
}

// –ü–∞—Ä–∞–º–µ—Ç—Ä —Ç–æ—á–∫–∏ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ (0-1)
pointOnSegmentParameter(p1, p2, point) {
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    
    if (Math.abs(dx) > Math.abs(dy)) {
        return (point.x - p1.x) / dx;
    } else {
        return (point.y - p1.y) / dy;
    }
}

// –†–∞–∑–¥–µ–ª–µ–Ω–∏–µ –ø—É—Ç–∏ –Ω–∞ —á–∞—Å—Ç–∏ –ø–æ —Ç–æ—á–∫–∞–º –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
splitPathAtIntersections(originalPoints, intersections, isClosed) {
    const parts = [];
    let currentPart = { points: [] };
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤—Å–µ —Ç–æ—á–∫–∏ –¥–æ –ø–µ—Ä–≤–æ–≥–æ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
    for (let i = 0; i < originalPoints.length; i++) {
        currentPart.points.push(originalPoints[i]);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Ä–∞–∑—Ä–µ–∑–∞—Ç—å –ø–æ—Å–ª–µ —ç—Ç–æ–π —Ç–æ—á–∫–∏
        const nextPointIndex = (i + 1) % originalPoints.length;
        const segmentIntersections = intersections.filter(
            inter => inter.segmentIndex === i
        ).sort((a, b) => a.t - b.t);
        
        if (segmentIntersections.length > 0) {
            // –î–æ–±–∞–≤–ª—è–µ–º —Ç–æ—á–∫—É –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            segmentIntersections.forEach(inter => {
                currentPart.points.push(inter.point);
                // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ç–µ–∫—É—â—É—é —á–∞—Å—Ç—å
                if (currentPart.points.length >= 2) {
                    parts.push({...currentPart});
                }
                // –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é —á–∞—Å—Ç—å —Å —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
                currentPart = { points: [inter.point] };
            });
        }
        
        // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞ –≤ –Ω–µ–∑–∞–º–∫–Ω—É—Ç–æ–º –ø—É—Ç–∏
        if (!isClosed && i === originalPoints.length - 1) {
            if (currentPart.points.length >= 2) {
                parts.push({...currentPart});
            }
        }
    }
    
    // –î–ª—è –∑–∞–º–∫–Ω—É—Ç–æ–≥–æ –ø—É—Ç–∏ - —Å–æ–µ–¥–∏–Ω—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —á–∞—Å—Ç—å —Å –ø–µ—Ä–≤–æ–π
    if (isClosed && parts.length > 0 && currentPart.points.length > 0) {
        // –î–æ–±–∞–≤–ª—è–µ–º –æ—Å—Ç–∞–≤—à–∏–µ—Å—è —Ç–æ—á–∫–∏ –∫ –ø–µ—Ä–≤–æ–π —á–∞—Å—Ç–∏
        parts[0].points = [...currentPart.points, ...parts[0].points.slice(1)];
    } else if (currentPart.points.length >= 2) {
        parts.push({...currentPart});
    }
    
    return parts;
}

eraseVectorsAt(x, y) {
    const now = Date.now();
    if (this.lastEraseTime && (now - this.lastEraseTime) < 16) { // ~60fps
        return; // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Å–ª–∏—à–∫–æ–º —á–∞—Å—Ç—ã–µ –≤—ã–∑–æ–≤—ã
    }
    this.lastEraseTime = now;
    const radius = this.state.eraserSize / this.state.zoom;
    
    // –°–∫—Ä—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø–µ—Ä–µ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π
    this.hideEraserIndicator();
    
    // 1. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ü–£–¢–ï–ô (paths)
    const allPaths = Array.from(this.svg.querySelectorAll('path'))
        .filter(path => !path.id || !path.id.includes('background') && 
                       !path.id.includes('eraser-indicator') && 
                       !path.id.includes('push-indicator'));
    
    allPaths.forEach(path => {
        const result = this.cutPathAtIntersections(path, x, y, radius);
        
        if (result === 'delete') {
            // –£–¥–∞–ª—è–µ–º –≤–µ—Å—å –ø—É—Ç—å
            if (path.parentNode) {
                path.parentNode.removeChild(path);
            }
        } else if (result && result.length > 0) {
            // –£–¥–∞–ª—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π –ø—É—Ç—å
            const parent = path.parentNode;
            if (parent) {
                const stroke = path.getAttribute('stroke');
                const strokeWidth = path.getAttribute('stroke-width');
                const fill = path.getAttribute('fill');
                const linecap = path.getAttribute('stroke-linecap');
                const linejoin = path.getAttribute('stroke-linejoin');
                
                parent.removeChild(path);
                
                // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ –ø—É—Ç–∏ –∏–∑ —á–∞—Å—Ç–µ–π
                result.forEach((pathData) => {
                    const points = this.parsePathToPoints(pathData).points;
                    if (points.length >= 2) {
                        const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        newPath.setAttribute('d', pathData);
                        newPath.setAttribute('stroke', stroke || 'black');
                        newPath.setAttribute('stroke-width', strokeWidth || '1');
                        newPath.setAttribute('fill', fill || 'none');
                        newPath.setAttribute('stroke-linecap', linecap || 'round');
                        newPath.setAttribute('stroke-linejoin', linejoin || 'round');
                        parent.appendChild(newPath);
                    }
                });
            }
        }
    });
    
    // 2. –û–±—Ä–∞–±–æ—Ç–∫–∞ –õ–ò–ù–ò–ô (lines) - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏—Ö –≤ –ø—É—Ç–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è
    const lines = Array.from(this.svg.querySelectorAll('line'))
        .filter(el => !el.id || !el.id.includes('background'));
    
    lines.forEach(line => {
        const path = this.convertToPath(line);
        if (path) {
            const parent = line.parentNode;
            if (parent) {
                parent.removeChild(line);
                parent.appendChild(path);
                
                // –¢–µ–ø–µ—Ä—å –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∫ –ø—É—Ç—å
                const result = this.cutPathAtIntersections(path, x, y, radius);
                if (result === 'delete') {
                    parent.removeChild(path);
                } else if (result && result.length > 0) {
                    parent.removeChild(path);
                    result.forEach(pathData => {
                        const points = this.parsePathToPoints(pathData).points;
                        if (points.length >= 2) {
                            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            newPath.setAttribute('d', pathData);
                            newPath.setAttribute('stroke', line.getAttribute('stroke') || 'black');
                            newPath.setAttribute('stroke-width', line.getAttribute('stroke-width') || '1');
                            newPath.setAttribute('fill', 'none');
                            parent.appendChild(newPath);
                        }
                    });
                }
            }
        }
    });
    
    // 3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ü–†–Ø–ú–û–£–ì–û–õ–¨–ù–ò–ö–û–í (rects)
    const rects = Array.from(this.svg.querySelectorAll('rect'))
        .filter(el => !el.id || !el.id.includes('background'));
    
    rects.forEach(rect => {
        const rectX = parseFloat(rect.getAttribute('x'));
        const rectY = parseFloat(rect.getAttribute('y'));
        const rectWidth = parseFloat(rect.getAttribute('width'));
        const rectHeight = parseFloat(rect.getAttribute('height'));
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –ª–∞—Å—Ç–∏–∫–∞ –¥–æ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞
        const distance = this.pointToRectDistance(x, y, 
            {x: rectX, y: rectY, width: rectWidth, height: rectHeight});
        
        // –ï—Å–ª–∏ –ª–∞—Å—Ç–∏–∫ –∫–∞—Å–∞–µ—Ç—Å—è –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ - –∫–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –∏ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º
        if (distance <= radius) {
            const path = this.convertToPath(rect);
            if (path) {
                const parent = rect.parentNode;
                if (parent) {
                    parent.removeChild(rect);
                    parent.appendChild(path);
                    
                    const result = this.cutPathAtIntersections(path, x, y, radius);
                    if (result === 'delete') {
                        parent.removeChild(path);
                    } else if (result && result.length > 0) {
                        parent.removeChild(path);
                        result.forEach(pathData => {
                            const points = this.parsePathToPoints(pathData).points;
                            if (points.length >= 2) {
                                const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                newPath.setAttribute('d', pathData);
                                newPath.setAttribute('stroke', rect.getAttribute('stroke') || 'black');
                                newPath.setAttribute('stroke-width', rect.getAttribute('stroke-width') || '1');
                                newPath.setAttribute('fill', 'none');
                                parent.appendChild(newPath);
                            }
                        });
                    }
                }
            }
        }
    });
    
    // 4. –û–±—Ä–∞–±–æ—Ç–∫–∞ –ö–†–£–ì–û–í (circles)
    const circles = Array.from(this.svg.querySelectorAll('circle'))
        .filter(el => !el.id || !el.id.includes('background'));
    
    circles.forEach(circle => {
        const cx = parseFloat(circle.getAttribute('cx'));
        const cy = parseFloat(circle.getAttribute('cy'));
        const r = parseFloat(circle.getAttribute('r'));
        
        // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —Ü–µ–Ω—Ç—Ä–∞ –ª–∞—Å—Ç–∏–∫–∞ –¥–æ —Ü–µ–Ω—Ç—Ä–∞ –∫—Ä—É–≥–∞
        const distance = Math.sqrt((x - cx)**2 + (y - cy)**2);
        
        // –ï—Å–ª–∏ –ª–∞—Å—Ç–∏–∫ –ø–µ—Ä–µ—Å–µ–∫–∞–µ—Ç –∏–ª–∏ –∫–∞—Å–∞–µ—Ç—Å—è –∫—Ä—É–≥–∞
        if (distance <= radius + r && distance >= Math.abs(radius - r)) {
            const path = this.convertToPath(circle);
            if (path) {
                const parent = circle.parentNode;
                if (parent) {
                    parent.removeChild(circle);
                    parent.appendChild(path);
                    
                    const result = this.cutPathAtIntersections(path, x, y, radius);
                    if (result === 'delete') {
                        parent.removeChild(path);
                    } else if (result && result.length > 0) {
                        parent.removeChild(path);
                        result.forEach(pathData => {
                            const points = this.parsePathToPoints(pathData).points;
                            if (points.length >= 2) {
                                const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                newPath.setAttribute('d', pathData);
                                newPath.setAttribute('stroke', circle.getAttribute('stroke') || 'black');
                                newPath.setAttribute('stroke-width', circle.getAttribute('stroke-width') || '1');
                                newPath.setAttribute('fill', 'none');
                                parent.appendChild(newPath);
                            }
                        });
                    }
                }
            }
        } else if (distance < Math.abs(radius - r)) {
            // –õ–∞—Å—Ç–∏–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞ –∏–ª–∏ –∫—Ä—É–≥ –≤–Ω—É—Ç—Ä–∏ –ª–∞—Å—Ç–∏–∫–∞
            if (radius >= r) {
                // –õ–∞—Å—Ç–∏–∫ –±–æ–ª—å—à–µ –∫—Ä—É–≥–∞ - —É–¥–∞–ª—è–µ–º –∫—Ä—É–≥ –ø–æ–ª–Ω–æ—Å—Ç—å—é
                if (circle.parentNode) {
                    circle.parentNode.removeChild(circle);
                }
            } else {
                // –ö—Ä—É–≥ –±–æ–ª—å—à–µ –ª–∞—Å—Ç–∏–∫–∞ - –Ω—É–∂–Ω–æ –≤—ã—Ä–µ–∑–∞—Ç—å –æ—Ç–≤–µ—Ä—Å—Ç–∏–µ
                const path = this.convertToPath(circle);
                if (path) {
                    const parent = circle.parentNode;
                    if (parent) {
                        parent.removeChild(circle);
                        parent.appendChild(path);
                        
                        // –î–ª—è –±–æ–ª—å—à–∏—Ö –∫—Ä—É–≥–æ–≤ –ª—É—á—à–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –¥—Ä—É–≥–æ–π –ø–æ–¥—Ö–æ–¥
                        const result = this.cutPathAtIntersections(path, x, y, radius);
                        if (result === 'delete') {
                            parent.removeChild(path);
                        } else if (result && result.length > 0) {
                            parent.removeChild(path);
                            result.forEach(pathData => {
                                const points = this.parsePathToPoints(pathData).points;
                                if (points.length >= 2) {
                                    const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                                    newPath.setAttribute('d', pathData);
                                    newPath.setAttribute('stroke', circle.getAttribute('stroke') || 'black');
                                    newPath.setAttribute('stroke-width', circle.getAttribute('stroke-width') || '1');
                                    newPath.setAttribute('fill', 'none');
                                    parent.appendChild(newPath);
                                }
                            });
                        }
                    }
                }
            }
        }
    });
    
    // 5. –û–±—Ä–∞–±–æ—Ç–∫–∞ –≠–õ–õ–ò–ü–°–û–í (ellipses)
    const ellipses = Array.from(this.svg.querySelectorAll('ellipse'))
        .filter(el => !el.id || !el.id.includes('background'));
    
    ellipses.forEach(ellipse => {
        const path = this.convertToPath(ellipse);
        if (path) {
            const parent = ellipse.parentNode;
            if (parent) {
                parent.removeChild(ellipse);
                parent.appendChild(path);
                
                const result = this.cutPathAtIntersections(path, x, y, radius);
                if (result === 'delete') {
                    parent.removeChild(path);
                } else if (result && result.length > 0) {
                    parent.removeChild(path);
                    result.forEach(pathData => {
                        const points = this.parsePathToPoints(pathData).points;
                        if (points.length >= 2) {
                            const newPath = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            newPath.setAttribute('d', pathData);
                            newPath.setAttribute('stroke', ellipse.getAttribute('stroke') || 'black');
                            newPath.setAttribute('stroke-width', ellipse.getAttribute('stroke-width') || '1');
                            newPath.setAttribute('fill', 'none');
                            parent.appendChild(newPath);
                        }
                    });
                }
            }
        }
    });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –æ–±—Ä–∞—Ç–Ω–æ
    this.showEraserIndicator(x, y, radius);
}

pointToRectDistance(px, py, rect) {
    // –ù–∞—Ö–æ–¥–∏–º –±–ª–∏–∂–∞–π—à—É—é —Ç–æ—á–∫—É –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –∫ –∑–∞–¥–∞–Ω–Ω–æ–π —Ç–æ—á–∫–µ
    const closestX = Math.max(rect.x, Math.min(px, rect.x + rect.width));
    const closestY = Math.max(rect.y, Math.min(py, rect.y + rect.height));
    
    // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –±–ª–∏–∂–∞–π—à–µ–π —Ç–æ—á–∫–∏
    const dx = px - closestX;
    const dy = py - closestY;
    
    return Math.sqrt(dx * dx + dy * dy);
}

// –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –¥–≤—É–º—è —Ç–æ—á–∫–∞–º–∏
pointDistance(p1, p2) {
    return Math.sqrt((p2.x - p1.x)**2 + (p2.y - p1.y)**2);
}

onMouseUp() {
    if (this.state.isMoving) {
        this.stopPanning();
    }

    if (this.state.isDrawing && this.state.currentTool === 'eraser') {
        this.state.isDrawing = false;
        this.state.lastErasePoint = null;
        this.lastEraseTime = null;
    } 
    
    if (this.state.isDrawing) {
        // –ï—Å–ª–∏ —Ä–∏—Å—É–µ–º –∫–∞—Ä–∞–Ω–¥–∞—à–æ–º
        if (this.state.currentTool === 'pen') {
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –ø—Ä–∏–≤—è–∑–∫—É –∫ —á–µ—Ä–Ω–æ–π –ª–∏–Ω–∏–∏ –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
            if (this.state.image && this.snapSettings.enabled) {
                this.snapPathToBlackLine(this.state.currentElement);
            }
            
            // –ï—Å–ª–∏ –í–´–ö–õ–Æ–ß–ï–ù–û –ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ –≤–µ–∫—Ç–æ—Ä–∞ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º currentElement
            if (!this.snapSettings.continueVector) {
                this.state.currentElement = null;
            }
            
            // –¢–æ–ª—å–∫–æ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º —Ñ–ª–∞–≥–∏ —Ä–∏—Å–æ–≤–∞–Ω–∏—è
            this.state.isDrawing = false;
            this.state.penPoints = [];
            
        } else {
            // –î–ª—è –¥—Ä—É–≥–∏—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ - —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –∫–∞–∫ –æ–±—ã—á–Ω–æ
            this.state.currentElement = null;
            this.state.isDrawing = false;
        }
        
        this.hidePushIndicator();
    }
    
    if (this.state.currentTool === 'push') {
        this.state.isDrawing = false;
        this.pushData = null; // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ç–æ—á–∫–∏
    }
    
    this.hideEraserIndicator();
}

onMouseLeave() {
    if (this.state.isMoving) {
        this.stopPanning();
    }
    
    if (this.state.isDrawing) {
        this.state.isDrawing = false;
        this.state.pushData = null;
        this.hidePushIndicator();
        this.hideEraserIndicator();
    }
    document.body.style.cursor = 'default';
}

// –ù–æ–≤–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏–µ –∫—Ä—É–≥–∞ —Å –æ—Ç—Ä–µ–∑–∫–æ–º
circleSegmentIntersections(cx, cy, radius, x1, y1, x2, y2) {
    const intersections = [];
    
    const dx = x2 - x1;
    const dy = y2 - y1;
    
    const A = dx * dx + dy * dy;
    const B = 2 * (dx * (x1 - cx) + dy * (y1 - cy));
    const C = (x1 - cx) * (x1 - cx) + (y1 - cy) * (y1 - cy) - radius * radius;
    
    const discriminant = B * B - 4 * A * C;
    
    if (discriminant < 0) {
        return intersections;
    }
    
    const sqrtDiscriminant = Math.sqrt(discriminant);
    const t1 = (-B - sqrtDiscriminant) / (2 * A);
    const t2 = (-B + sqrtDiscriminant) / (2 * A);
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–æ—á–∫–∞ –Ω–∞ –æ—Ç—Ä–µ–∑–∫–µ (0 <= t <= 1)
    if (t1 >= 0 && t1 <= 1) {
        intersections.push({
            x: x1 + t1 * dx,
            y: y1 + t1 * dy,
            t: t1
        });
    }
    
    if (t2 >= 0 && t2 <= 1 && Math.abs(t1 - t2) > 0.001) {
        intersections.push({
            x: x1 + t2 * dx,
            y: y1 + t2 * dy,
            t: t2
        });
    }
    
    // –ï—Å–ª–∏ –æ—Ç—Ä–µ–∑–æ–∫ –ø–æ–ª–Ω–æ—Å—Ç—å—é –≤–Ω—É—Ç—Ä–∏ –∫—Ä—É–≥–∞ - –¥–æ–±–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü
    if (intersections.length === 0) {
        const d1 = Math.sqrt(Math.pow(x1 - cx, 2) + Math.pow(y1 - cy, 2));
        const d2 = Math.sqrt(Math.pow(x2 - cx, 2) + Math.pow(y2 - cy, 2));
        
        if (d1 <= radius && d2 <= radius) {
            intersections.push({x: x1, y: y1, t: 0});
            intersections.push({x: x2, y: y2, t: 1});
        }
    }
    
    return intersections;
}

            // –†–ò–°–û–í–ê–ù–ò–ï
startPen(x, y) {
    this.state.penPoints = [{x, y}];
    
    this.state.currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    this.state.currentElement.setAttribute('d', `M ${x} ${y}`);
    this.state.currentElement.setAttribute('stroke', this.state.strokeColor);
    this.state.currentElement.setAttribute('stroke-width', this.state.strokeWidth);
    this.state.currentElement.setAttribute('fill', 'none');
    this.state.currentElement.setAttribute('stroke-linecap', 'round');
    this.state.currentElement.setAttribute('stroke-linejoin', 'round');
    
    this.svg.appendChild(this.state.currentElement);
}
            
drawPen(x, y) {
    // 1. –°–ù–ê–ß–ê–õ–ê –ø—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É –≤–µ–∫—Ç–æ—Ä—É
    const snapVectorResult = this.findNearestVectorEndpoint(x, y);
    
    // 2. –ï–°–õ–ò –Ω–µ—Ç –±–ª–∏–∑–∫–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏—Ç—è–≥–∏–≤–∞–Ω–∏–µ –∫ —á–µ—Ä–Ω–æ–π –ª–∏–Ω–∏–∏ –Ω–∞ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
    let snappedPoint = null;
    
    if (snapVectorResult.point) {
        snappedPoint = snapVectorResult.point;
    } else if (this.state.image && this.snapSettings.enabled) {
        snappedPoint = this.snapToBlackLine(x, y);
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—É—é —Ç–æ—á–∫—É –∏–ª–∏ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—É—é
    const finalPoint = snappedPoint || {x, y};
    
    // –°–æ–±–∏—Ä–∞–µ–º —Ç–æ—á–∫–∏ –¥–ª—è —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏—è (–∏—Å–ø–æ–ª—å–∑—É–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
    this.state.penPoints.push(finalPoint);
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–≥–ª–∞–∂–∏–≤–∞–Ω–∏–µ
    const smoothing = this.state.smoothing;
    const pointsToAverage = Math.min(smoothing, this.state.penPoints.length);
    const startIdx = this.state.penPoints.length - pointsToAverage;
    
    let avgX = 0;
    let avgY = 0;
    
    for (let i = startIdx; i < this.state.penPoints.length; i++) {
        avgX += this.state.penPoints[i].x;
        avgY += this.state.penPoints[i].y;
    }
    
    avgX /= pointsToAverage;
    avgY /= pointsToAverage;
    
    // –î–æ–±–∞–≤–ª—è–µ–º —Å–≥–ª–∞–∂–µ–Ω–Ω—É—é —Ç–æ—á–∫—É –∫ –ø—É—Ç–∏
    const currentPath = this.state.currentElement.getAttribute('d');
    this.state.currentElement.setAttribute('d', currentPath + ` L ${avgX} ${avgY}`);
    
    // –£–ë–†–ê–ù–û: –≤–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å –¥–ª—è –ø—Ä–∏—Ç—è–≥–∏–≤–∞–Ω–∏—è
}
 
    findNearestVectorEndpoint(x, y) {
        const snapDistance = this.snapSettings.vectorSnapDistance / this.state.zoom;
        
        // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ –ø—É—Ç–∏ –∏ –ª–∏–Ω–∏–∏ (–∫—Ä–æ–º–µ —Ç–µ–∫—É—â–µ–≥–æ)
        const allVectors = Array.from(this.svg.querySelectorAll('path, line'))
            .filter(el => el !== this.state.currentElement);
        
        let nearestPoint = null;
        let minDistance = snapDistance;
        let nearestElement = null;
        
        allVectors.forEach(vector => {
            let endpoints = [];
            
            if (vector.tagName === 'LINE') {
                // –î–ª—è –ª–∏–Ω–∏–∏: –Ω–∞—á–∞–ª–æ –∏ –∫–æ–Ω–µ—Ü
                endpoints = [
                    {x: parseFloat(vector.getAttribute('x1')), 
                     y: parseFloat(vector.getAttribute('y1'))},
                    {x: parseFloat(vector.getAttribute('x2')), 
                     y: parseFloat(vector.getAttribute('y2'))}
                ];
            } 
            else if (vector.tagName === 'PATH') {
                // –î–ª—è –ø—É—Ç–∏: –ø–µ—Ä–≤–∞—è –∏ –ø–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞
                const d = vector.getAttribute('d');
                const commands = d.split(/(?=[ML])/); // –†–∞–∑–¥–µ–ª—è–µ–º –ø–æ –∫–æ–º–∞–Ω–¥–∞–º
                
                if (commands.length > 0) {
                    // –ü–µ—Ä–≤–∞—è —Ç–æ—á–∫–∞
                    const firstCmd = commands[0];
                    const firstMatch = firstCmd.match(/[\d.-]+/g);
                    if (firstMatch && firstMatch.length >= 2) {
                        endpoints.push({
                            x: parseFloat(firstMatch[0]),
                            y: parseFloat(firstMatch[1])
                        });
                    }
                    
                    // –ü–æ—Å–ª–µ–¥–Ω—è—è —Ç–æ—á–∫–∞
                    const lastCmd = commands[commands.length - 1];
                    const lastMatch = lastCmd.match(/[\d.-]+/g);
                    if (lastMatch && lastMatch.length >= 2) {
                        endpoints.push({
                            x: parseFloat(lastMatch[lastMatch.length - 2]),
                            y: parseFloat(lastMatch[lastMatch.length - 1])
                        });
                    }
                }
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ –∫–æ–Ω—Ü–µ–≤—ã–µ —Ç–æ—á–∫–∏
            endpoints.forEach(point => {
                if (point.x === undefined || point.y === undefined) return;
                
                const dist = Math.sqrt(Math.pow(x - point.x, 2) + Math.pow(y - point.y, 2));
                if (dist < minDistance) {
                    minDistance = dist;
                    nearestPoint = point;
                    nearestElement = vector;
                }
            });
        });
        
        return {point: nearestPoint, element: nearestElement, distance: minDistance};
    }
   
snapPathToBlackLine(pathElement) {
    if (!pathElement || pathElement.tagName !== 'PATH' || !this.state.image) return;
    
    // –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∑–∞–∫—Ä—ã—Ç–æ—Å—Ç–∏
    const d = pathElement.getAttribute('d');
    if (!d) return;
    
    const { points, isClosed } = this.parsePathToPoints(d);
    
    // –ü—Ä–∏–≤—è–∑—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é —Ç–æ—á–∫—É –∫ —á–µ—Ä–Ω–æ–π –ª–∏–Ω–∏–∏
    const snappedPoints = points.map(point => {
        const snapped = this.snapToBlackLine(point.x, point.y);
        return snapped || point;
    });
    
    // –ü–µ—Ä–µ—Å—Ç—Ä–∞–∏–≤–∞–µ–º –ø—É—Ç—å —Å –ø—Ä–∏–≤—è–∑–∞–Ω–Ω—ã–º–∏ —Ç–æ—á–∫–∞–º–∏
    let newPath = `M ${snappedPoints[0].x} ${snappedPoints[0].y}`;
    for (let i = 1; i < snappedPoints.length; i++) {
        newPath += ` L ${snappedPoints[i].x} ${snappedPoints[i].y}`;
    }
    
    // –î–æ–±–∞–≤–ª—è–µ–º Z –µ—Å–ª–∏ –ø—É—Ç—å –±—ã–ª –∑–∞–∫—Ä—ã—Ç
    if (isClosed && snappedPoints.length > 2) {
        newPath += ' Z';
    }
    
    pathElement.setAttribute('d', newPath);
}
// –±–µ–∑—å–µ
    // ============================================
    // –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–õ–ò–ö–û–í
    // ============================================

    // ============================================
    // –°–û–ó–î–ê–ù–ò–ï –¢–û–ß–ï–ö –ò –í–ï–ö–¢–û–†–û–í
    // ============================================
    
    createSingleBezierPoint(x, y) {
        const point = {
            x: x,
            y: y,
            element: null,
            index: this.state.bezierPoints.length
        };
        
        // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç —Ç–æ—á–∫–∏
        point.element = this.createBezierPointElement(point);
        this.svg.appendChild(point.element);
        
        // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤
        this.state.bezierPoints.push(point);
        
        // –í—ã–¥–µ–ª—è–µ–º —ç—Ç—É —Ç–æ—á–∫—É
        this.selectBezierPoint(point.index);
    }
  
createNewBezierVector(x, y) {
    const fromPoint = this.state.bezierPoints[this.state.bezierSelectedPoint];
    if (!fromPoint) return;
    
    // –ò—â–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π –≤–µ–∫—Ç–æ—Ä, –≥–¥–µ fromPoint —è–≤–ª—è–µ—Ç—Å—è –∫–æ–Ω—Ü–æ–º
    const previousVector = this.state.bezierVectors.find(v => 
        v.to === fromPoint.index
    );
    
    // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
    const toPoint = {
        x: x,
        y: y,
        element: null,
        index: this.state.bezierPoints.length
    };
    
    // –°–æ–∑–¥–∞–µ–º —ç–ª–µ–º–µ–Ω—Ç —Ç–æ—á–∫–∏
    toPoint.element = this.createBezierPointElement(toPoint);
    this.svg.appendChild(toPoint.element);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ –º–∞—Å—Å–∏–≤
    this.state.bezierPoints.push(toPoint);
    
    // –°–æ–∑–¥–∞–µ–º –≤–µ–∫—Ç–æ—Ä –ë–µ–∑—å–µ
    const newVector = this.createBezierVector(fromPoint, toPoint, previousVector);
    
    // –ï—Å–ª–∏ –µ—Å—Ç—å –ø—Ä–µ–¥—ã–¥—É—â–∏–π –≤–µ–∫—Ç–æ—Ä - –≤—ã—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ
    if (previousVector) {
        this.alignTangentsForSmoothConnection(newVector, previousVector);
    }
    
    // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–æ —Å—Ç–∞—Ä–æ–π —Ç–æ—á–∫–∏
    if (fromPoint.element) {
        fromPoint.element.classList.remove('selected');
    }
    
    // –í—ã–¥–µ–ª—è–µ–º –Ω–æ–≤—É—é —Ç–æ—á–∫—É
    this.selectBezierPoint(toPoint.index);
    
    return newVector;
}
  
    // –°–û–ó–î–ê–ù–ò–ï –í–ï–ö–¢–û–†–ê –ë–ï–ó–¨–ï –ú–ï–ñ–î–£ –î–í–£–ú–Ø –¢–û–ß–ö–ê–ú–ò
createBezierVector(fromPoint, toPoint, previousVector = null) {
    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
    const controlPoints = this.calculateBezierControlPoints(fromPoint, toPoint, previousVector);
    
    // –°–æ–∑–¥–∞–µ–º –æ–±—ä–µ–∫—Ç –≤–µ–∫—Ç–æ—Ä–∞
    const vector = {
        from: fromPoint.index,
        to: toPoint.index,
        control1: {
            x: controlPoints.cp1.x,
            y: controlPoints.cp1.y,
            belongsTo: fromPoint.index
        },
        control2: {
            x: controlPoints.cp2.x,
            y: controlPoints.cp2.y,
            belongsTo: toPoint.index
        },
        path: null,
        guideElements: {}
    };
    
    // –°–æ–∑–¥–∞–µ–º SVG –ø—É—Ç—å
    vector.path = this.createBezierPath(
        fromPoint.x, fromPoint.y,
        vector.control1.x, vector.control1.y,
        vector.control2.x, vector.control2.y,
        toPoint.x, toPoint.y
    );
    
    this.svg.appendChild(vector.path);
    
    // –°–æ–∑–¥–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ —ç–ª–µ–º–µ–Ω—Ç—ã
    this.createVectorGuides(vector, fromPoint, toPoint);
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–µ–∫—Ç–æ—Ä
    this.state.bezierVectors.push(vector);
    
    return vector;
}
 
    createBezierPath(x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        const d = `M ${x1} ${y1} C ${cx1} ${cy1} ${cx2} ${cy2} ${x2} ${y2}`;
        
        path.setAttribute('d', d);
        path.setAttribute('stroke', this.state.strokeColor);
        path.setAttribute('stroke-width', this.state.strokeWidth);
        path.setAttribute('fill', 'none');
        path.setAttribute('stroke-linecap', 'round');
        path.classList.add('bezier-vector');
        
        return path;
    }
    
createVectorGuides(vector, fromPoint, toPoint) {
    const vectorIndex = this.state.bezierVectors.length - 1;
    
    // –õ–ò–ù–ò–Ø 1: –æ—Ç —Ç–æ—á–∫–∏ "from" –∫ –ï–Å –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ (control1)
    vector.guideElements.line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    vector.guideElements.line1.setAttribute('class', 'bezier-guide-line');
    vector.guideElements.line1.setAttribute('x1', fromPoint.x);
    vector.guideElements.line1.setAttribute('y1', fromPoint.y);
    vector.guideElements.line1.setAttribute('x2', vector.control1.x);
    vector.guideElements.line1.setAttribute('y2', vector.control1.y);
    vector.guideElements.line1.setAttribute('data-vector-index', vectorIndex);
    vector.guideElements.line1.setAttribute('data-belongs-to', fromPoint.index);
    vector.guideElements.line1.setAttribute('data-control-type', 'control1');
    
    // –ö–û–ù–¢–†–û–õ–¨–ù–ê–Ø –¢–û–ß–ö–ê 1: –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ç–æ—á–∫–µ "from"
    vector.guideElements.control1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    vector.guideElements.control1.setAttribute('class', 'bezier-control-point');
    vector.guideElements.control1.setAttribute('cx', vector.control1.x);
    vector.guideElements.control1.setAttribute('cy', vector.control1.y);
    vector.guideElements.control1.setAttribute('r', '4');
    vector.guideElements.control1.setAttribute('data-vector-index', vectorIndex);
    vector.guideElements.control1.setAttribute('data-control-type', 'control1');
    vector.guideElements.control1.setAttribute('data-belongs-to', fromPoint.index);
    
    // –õ–ò–ù–ò–Ø 2: –æ—Ç —Ç–æ—á–∫–∏ "to" –∫ –ï–Å –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–µ (control2)
    vector.guideElements.line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    vector.guideElements.line2.setAttribute('class', 'bezier-guide-line');
    vector.guideElements.line2.setAttribute('x1', toPoint.x);
    vector.guideElements.line2.setAttribute('y1', toPoint.y);
    vector.guideElements.line2.setAttribute('x2', vector.control2.x);
    vector.guideElements.line2.setAttribute('y2', vector.control2.y);
    vector.guideElements.line2.setAttribute('data-vector-index', vectorIndex);
    vector.guideElements.line2.setAttribute('data-belongs-to', toPoint.index);
    vector.guideElements.line2.setAttribute('data-control-type', 'control2');
    
    // –ö–û–ù–¢–†–û–õ–¨–ù–ê–Ø –¢–û–ß–ö–ê 2: –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç —Ç–æ—á–∫–µ "to"
    vector.guideElements.control2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    vector.guideElements.control2.setAttribute('class', 'bezier-control-point');
    vector.guideElements.control2.setAttribute('cx', vector.control2.x);
    vector.guideElements.control2.setAttribute('cy', vector.control2.y);
    vector.guideElements.control2.setAttribute('r', '4');
    vector.guideElements.control2.setAttribute('data-vector-index', vectorIndex);
    vector.guideElements.control2.setAttribute('data-control-type', 'control2');
    vector.guideElements.control2.setAttribute('data-belongs-to', toPoint.index);
    
    // –ù–û–í–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò - –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–¥–∏–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é startBezierControlDrag
    vector.guideElements.control1.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.startBezierControlDrag(e);
    });
    
    vector.guideElements.control2.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.startBezierControlDrag(e);
    });
    
    // –î–æ–±–∞–≤–ª—è–µ–º –≤ SVG
    this.svg.appendChild(vector.guideElements.line1);
    this.svg.appendChild(vector.guideElements.control1);
    this.svg.appendChild(vector.guideElements.line2);
    this.svg.appendChild(vector.guideElements.control2);
}
  
	
    // ============================================
    // –†–ê–°–ß–ï–¢ –ö–û–ù–¢–†–û–õ–¨–ù–´–• –¢–û–ß–ï–ö –ë–ï–ó–¨–ï
    // ============================================
 
calculateBezierControlPoints(pointA, pointB, previousVector = null) {
    const dx = pointB.x - pointA.x;
    const dy = pointB.y - pointA.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance === 0) {
        return {
            cp1: { x: pointA.x, y: pointA.y },
            cp2: { x: pointB.x, y: pointB.y }
        };
    }
    
    // –ü—Ä–æ—Å—Ç—ã–µ –≤—Å—Ç—Ä–µ—á–Ω—ã–µ –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ –¥–ª–∏–Ω–æ–π 0.39
    const dirX = dx / distance;
    const dirY = dy / distance;
    const tangentLength = distance * 0.39;
    
    // –í—Å–µ–≥–¥–∞ —Å–æ–∑–¥–∞–µ–º –≤—Å—Ç—Ä–µ—á–Ω—ã–µ –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ
    const cp1 = {
        x: pointA.x + dirX * tangentLength,
        y: pointA.y + dirY * tangentLength
    };
    
    const cp2 = {
        x: pointB.x - dirX * tangentLength,
        y: pointB.y - dirY * tangentLength
    };
    
    return { cp1, cp2 };
}

alignTangentsForSmoothConnection(newVector, previousVector) {
    if (!previousVector || !newVector) return;
    
    // –û–±—â–∞—è —Ç–æ—á–∫–∞ - –≥–¥–µ —Å–æ–µ–¥–∏–Ω—è—é—Ç—Å—è –≤–µ–∫—Ç–æ—Ä—ã
    const commonPointIndex = newVector.from; // –≠—Ç–æ —Ç–æ—á–∫–∞ 2 –≤ 1-2-3
    const commonPoint = this.state.bezierPoints[commonPointIndex];
    
    // –¢–æ—á–∫–∞ 1 (–Ω–∞—á–∞–ª–æ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞)
    const point1 = this.state.bezierPoints[previousVector.from];
    // –¢–æ—á–∫–∞ 3 (–∫–æ–Ω–µ—Ü –Ω–æ–≤–æ–≥–æ –≤–µ–∫—Ç–æ—Ä–∞)
    const point3 = this.state.bezierPoints[newVector.to];
    
    // –í–µ–∫—Ç–æ—Ä 1->2 (–æ—Ç —Ç–æ—á–∫–∏ 1 –∫ –æ–±—â–µ–π —Ç–æ—á–∫–µ 2)
    const vec1to2 = {
        x: commonPoint.x - point1.x,
        y: commonPoint.y - point1.y
    };
    
    // –í–µ–∫—Ç–æ—Ä 2->3 (–æ—Ç –æ–±—â–µ–π —Ç–æ—á–∫–∏ 2 –∫ —Ç–æ—á–∫–µ 3)
    const vec2to3 = {
        x: point3.x - commonPoint.x,
        y: point3.y - commonPoint.y
    };
    
    // –í—ã—á–∏—Å–ª—è–µ–º –¥–ª–∏–Ω—ã
    const length1to2 = Math.sqrt(vec1to2.x * vec1to2.x + vec1to2.y * vec1to2.y);
    const length2to3 = Math.sqrt(vec2to3.x * vec2to3.x + vec2to3.y * vec2to3.y);
    
    if (length1to2 === 0 || length2to3 === 0) return;
    
    // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –≤–µ–∫—Ç–æ—Ä—ã
    const dir1to2 = { x: vec1to2.x / length1to2, y: vec1to2.y / length1to2 };
    const dir2to3 = { x: vec2to3.x / length2to3, y: vec2to3.y / length2to3 };
    
    // –í—ã—á–∏—Å–ª—è–µ–º –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å—É —É–≥–ª–∞ –í–ù–£–¢–†–ò —É–≥–ª–∞ 1-2-3
    // –î–ª—è —ç—Ç–æ–≥–æ –Ω—É–∂–Ω–æ —É—Å—Ä–µ–¥–Ω–∏—Ç—å –ù–ê–ü–†–ê–í–õ–ï–ù–ò–Ø 1->2 –∏ 2->3
    // –ù–æ —Å–Ω–∞—á–∞–ª–∞ –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ 1->2, –ø–æ—Ç–æ–º—É —á—Ç–æ —Å–º–æ—Ç—Ä–∏–º –ò–ó —Ç–æ—á–∫–∏ 2
    const dirFrom2to1 = { x: -dir1to2.x, y: -dir1to2.y }; // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç 2 –∫ 1
    const dirFrom2to3 = dir2to3; // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –æ—Ç 2 –∫ 3
    
    // –ë–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–∞ —É–≥–ª–∞ –≤ —Ç–æ—á–∫–µ 2 –º–µ–∂–¥—É –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è–º–∏ –∫ 1 –∏ –∫ 3
    const bisector = {
        x: dirFrom2to1.x + dirFrom2to3.x,
        y: dirFrom2to1.y + dirFrom2to3.y
    };
    
    const bisectorLength = Math.sqrt(bisector.x * bisector.x + bisector.y * bisector.y);
    
    let tangentDir;
    
    if (bisectorLength === 0) {
        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ç–∏–≤–æ–ø–æ–ª–æ–∂–Ω—ã (180¬∞) - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ª—é–±–æ–π –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä
        tangentDir = { x: -dirFrom2to1.y, y: dirFrom2to1.x };
    } else {
        // –ù–æ—Ä–º–∞–ª–∏–∑—É–µ–º –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å—É
        const normalizedBisector = {
            x: bisector.x / bisectorLength,
            y: bisector.y / bisectorLength
        };
        
        // –ö–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è –ø–µ—Ä–ø–µ–Ω–¥–∏–∫—É–ª—è—Ä–Ω–∞ –±–∏—Å—Å–µ–∫—Ç—Ä–∏—Å–µ
        tangentDir = {
            x: -normalizedBisector.y,
            y: normalizedBisector.x
        };
    }
    
    // –¢–µ–ø–µ—Ä—å –û–ß–ï–ù–¨ –í–ê–ñ–ù–û: –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω—ã:
    // - –î–ª—è –≤–µ–∫—Ç–æ—Ä–∞ 1-2 (previousVector): control2 –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –û–¢ —Ç–æ—á–∫–∏ 2 –ö —Ç–æ—á–∫–µ 1
    // - –î–ª—è –≤–µ–∫—Ç–æ—Ä–∞ 2-3 (newVector): control1 –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –û–¢ —Ç–æ—á–∫–∏ 2 –ö —Ç–æ—á–∫–µ 3
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –ø—Ä–∞–≤–∏–ª—å–Ω–æ –ª–∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –∫–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è –¥–ª—è –≤–µ–∫—Ç–æ—Ä–∞ 2->3
    // –û–Ω–∞ –¥–æ–ª–∂–Ω–∞ –∏–º–µ—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—É—é –ø—Ä–æ–µ–∫—Ü–∏—é –Ω–∞ dirFrom2to3
    const dotProductWith2to3 = tangentDir.x * dirFrom2to3.x + tangentDir.y * dirFrom2to3.y;
    
    if (dotProductWith2to3 < 0) {
        // –ï—Å–ª–∏ –∫–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∞ –Ω–µ —Ç—É–¥–∞ - –∏–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –µ—ë
        tangentDir.x = -tangentDir.x;
        tangentDir.y = -tangentDir.y;
    }
    
    // –î–ª–∏–Ω—ã –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã—Ö (0.39 –æ—Ç –¥–ª–∏–Ω—ã –≤–µ–∫—Ç–æ—Ä–∞)
    const tangentLength1to2 = length1to2 * 0.39;
    const tangentLength2to3 = length2to3 * 0.39;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏:
    
    // 1. –î–ª—è –≤–µ–∫—Ç–æ—Ä–∞ 1-2: control2 (–≤ —Ç–æ—á–∫–µ 2) –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –ö —Ç–æ—á–∫–µ 1
    // –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω –ü–†–û–¢–ò–í–û–ü–û–õ–û–ñ–ù–û tangentDir
    previousVector.control2.x = commonPoint.x - tangentDir.x * tangentLength1to2;
    previousVector.control2.y = commonPoint.y - tangentDir.y * tangentLength1to2;
    
    // 2. –î–ª—è –≤–µ–∫—Ç–æ—Ä–∞ 2-3: control1 (–≤ —Ç–æ—á–∫–µ 2) –¥–æ–ª–∂–µ–Ω —É–∫–∞–∑—ã–≤–∞—Ç—å –ö —Ç–æ—á–∫–µ 3
    // –≠—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç, —á—Ç–æ –æ–Ω –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω –í–î–û–õ–¨ tangentDir
    newVector.control1.x = commonPoint.x + tangentDir.x * tangentLength2to3;
    newVector.control1.y = commonPoint.y + tangentDir.y * tangentLength2to3;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
    if (previousVector.guideElements.control2) {
        previousVector.guideElements.control2.setAttribute('cx', previousVector.control2.x);
        previousVector.guideElements.control2.setAttribute('cy', previousVector.control2.y);
        if (previousVector.guideElements.line2) {
            previousVector.guideElements.line2.setAttribute('x2', previousVector.control2.x);
            previousVector.guideElements.line2.setAttribute('y2', previousVector.control2.y);
        }
    }
    
    if (newVector.guideElements.control1) {
        newVector.guideElements.control1.setAttribute('cx', newVector.control1.x);
        newVector.guideElements.control1.setAttribute('cy', newVector.control1.y);
        if (newVector.guideElements.line1) {
            newVector.guideElements.line1.setAttribute('x2', newVector.control1.x);
            newVector.guideElements.line1.setAttribute('y2', newVector.control1.y);
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç–∏
    this.updateBezierVectorPath(previousVector);
    this.updateBezierVectorPath(newVector);
    
    console.log('–í—ã—Ä–æ–≤–Ω–µ–Ω—ã –∫–∞—Å–∞—Ç–µ–ª—å–Ω—ã–µ:');
    console.log('–ö–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è 2->1:', previousVector.control2.x, previousVector.control2.y);
    console.log('–ö–∞—Å–∞—Ç–µ–ª—å–Ω–∞—è 2->3:', newVector.control1.x, newVector.control1.y);
    console.log('–û–±—â–∞—è —Ç–æ—á–∫–∞:', commonPoint.x, commonPoint.y);
}


    // ============================================
    // –°–û–ó–î–ê–ù–ò–ï –í–ò–ó–£–ê–õ–¨–ù–´–• –≠–õ–ï–ú–ï–ù–¢–û–í
    // ============================================
    
    // –°–û–ó–î–ê–ù–ò–ï –≠–õ–ï–ú–ï–ù–¢–ê –¢–û–ß–ö–ò
createBezierPointElement(point) {
    const element = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    element.setAttribute('class', 'bezier-point');
    element.setAttribute('cx', point.x);
    element.setAttribute('cy', point.y);
    element.setAttribute('r', '6');
    element.setAttribute('data-index', point.index);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –Ω–∞—á–∞–ª–∞ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
    element.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const coords = this.getSVGCoordinates(e);
        const pointIndex = parseInt(element.getAttribute('data-index'));
        this.selectBezierPoint(pointIndex);
        this.startPointDrag(pointIndex, coords.x, coords.y);
    });
    
    // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è
    element.addEventListener('dblclick', (e) => {
        e.stopPropagation();
        this.deleteBezierPoint(point.index);
    });
    
    return element;
}
       
  
    // ============================================
    // –í–´–î–ï–õ–ï–ù–ò–ï –ò –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–ï
    // ============================================
    
selectBezierPoint(pointIndex) {
    // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å–æ –≤—Å–µ—Ö —Ç–æ—á–µ–∫
    this.state.bezierPoints.forEach(point => {
        if (point.element) {
            point.element.classList.remove('selected');
        }
    });
    
    // –í—ã–¥–µ–ª—è–µ–º —É–∫–∞–∑–∞–Ω–Ω—É—é —Ç–æ—á–∫—É
    const point = this.state.bezierPoints[pointIndex];
    if (point && point.element) {
        point.element.classList.add('selected');
        this.state.bezierSelectedPoint = pointIndex;
    }
}
    
    deselectAllPoints() {
        this.state.bezierPoints.forEach(point => {
            if (point.element) {
                point.element.classList.remove('selected');
            }
        });
        this.state.bezierSelectedPoint = null;
    }

    // –§–£–ù–ö–¶–ò–Ø –ù–ê–ß–ê–õ–ê –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø –ö–û–ù–¢–†–û–õ–¨–ù–û–ô –¢–û–ß–ö–ò –ë–ï–ó–¨–ï
startBezierControlDrag(e) {
    e.preventDefault();
    e.stopPropagation();
    
    const target = e.target;
    if (!target.classList.contains('bezier-control-point')) return;
    
    const coords = this.getSVGCoordinates(e);
    const controlType = target.getAttribute('data-control-type');
    const belongsTo = parseInt(target.getAttribute('data-belongs-to'));
    
    // –ò—â–µ–º –≤–µ–∫—Ç–æ—Ä –ø–æ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
    const vectorInfo = this.findVectorByControlPoint(controlType, belongsTo);
    
    if (!vectorInfo) {
        console.warn('–í–µ–∫—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏:', controlType, belongsTo);
        return;
    }
    
    const { vector, index: vectorIndex, type } = vectorInfo;
    
    // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    this.state.isDraggingBezierControl = true;
    this.state.draggingBezierControlVectorIndex = vectorIndex;
    this.state.draggingBezierControlType = type;
    this.state.draggingBezierControlStartX = coords.x;
    this.state.draggingBezierControlStartY = coords.y;
    
    // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
    if (type === 'control1') {
        this.state.draggingBezierControlOriginalX = vector.control1.x;
        this.state.draggingBezierControlOriginalY = vector.control1.y;
    } else {
        this.state.draggingBezierControlOriginalX = vector.control2.x;
        this.state.draggingBezierControlOriginalY = vector.control2.y;
    }
    
    console.log('–ù–∞—á–∞—Ç–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏', type, '–≤–µ–∫—Ç–æ—Ä–∞', vectorIndex);
}
   
    // –û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø –ö–û–ù–¢–†–û–õ–¨–ù–û–ô –¢–û–ß–ö–ò –ë–ï–ó–¨–ï
updateBezierControlDrag(x, y) {
    if (!this.state.isDraggingBezierControl) return;
    
    const vectorIndex = this.state.draggingBezierControlVectorIndex;
    const vector = this.state.bezierVectors[vectorIndex];
    if (!vector) {
        console.warn('–í–µ–∫—Ç–æ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –ø–æ –∏–Ω–¥–µ–∫—Å—É:', vectorIndex);
        return;
    }
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
    const dx = x - this.state.draggingBezierControlStartX;
    const dy = y - this.state.draggingBezierControlStartY;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏
    if (this.state.draggingBezierControlType === 'control1') {
        vector.control1.x = this.state.draggingBezierControlOriginalX + dx;
        vector.control1.y = this.state.draggingBezierControlOriginalY + dy;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
        if (vector.guideElements.control1) {
            vector.guideElements.control1.setAttribute('cx', vector.control1.x);
            vector.guideElements.control1.setAttribute('cy', vector.control1.y);
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–Ω–∏—é
        if (vector.guideElements.line1) {
            vector.guideElements.line1.setAttribute('x2', vector.control1.x);
            vector.guideElements.line1.setAttribute('y2', vector.control1.y);
        }
    } else {
        vector.control2.x = this.state.draggingBezierControlOriginalX + dx;
        vector.control2.y = this.state.draggingBezierControlOriginalY + dy;
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
        if (vector.guideElements.control2) {
            vector.guideElements.control2.setAttribute('cx', vector.control2.x);
            vector.guideElements.control2.setAttribute('cy', vector.control2.y);
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ª–∏–Ω–∏—é
        if (vector.guideElements.line2) {
            vector.guideElements.line2.setAttribute('x2', vector.control2.x);
            vector.guideElements.line2.setAttribute('y2', vector.control2.y);
        }
    }
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—É—Ç—å –ë–µ–∑—å–µ
    this.updateBezierVectorPath(vector);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—ã–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –¥–ª—è –ø–ª–∞–≤–Ω–æ—Å—Ç–∏
    this.state.draggingBezierControlStartX = x;
    this.state.draggingBezierControlStartY = y;
    this.state.draggingBezierControlOriginalX = 
        this.state.draggingBezierControlType === 'control1' ? vector.control1.x : vector.control2.x;
    this.state.draggingBezierControlOriginalY = 
        this.state.draggingBezierControlType === 'control1' ? vector.control1.y : vector.control2.y;
}
   
    // –ó–ê–í–ï–†–®–ï–ù–ò–ï –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–Ø –ö–û–ù–¢–†–û–õ–¨–ù–û–ô –¢–û–ß–ö–ò –ë–ï–ó–¨–ï
    endBezierControlDrag() {
        this.state.isDraggingBezierControl = false;
        this.state.draggingBezierControlVectorIndex = null;
        this.state.draggingBezierControlType = null;
        console.log('–ó–∞–≤–µ—Ä—à–µ–Ω–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏');
    }
        
    // –û–ë–ù–û–í–õ–ï–ù–ò–ï –ü–£–¢–ò –ë–ï–ó–¨–ï (–ø–æ—Å–ª–µ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω–æ–π —Ç–æ—á–∫–∏)
    updateBezierVectorPath(vector) {
        const startPoint = this.state.bezierPoints[vector.from];
        const endPoint = this.state.bezierPoints[vector.to];
        
        if (!startPoint || !endPoint || !vector.path) return;
        
        const d = `M ${startPoint.x} ${startPoint.y} 
                   C ${vector.control1.x} ${vector.control1.y} 
                     ${vector.control2.x} ${vector.control2.y} 
                     ${endPoint.x} ${endPoint.y}`;
        
        vector.path.setAttribute('d', d);
    }
    // ============================================
    // –ü–ï–†–ï–¢–ê–°–ö–ò–í–ê–ù–ò–ï –¢–û–ß–ï–ö
    // ============================================
    
startPointDrag(pointIndex, x, y) {
    const point = this.state.bezierPoints[pointIndex];
    if (!point) return;
    
    // –í—ã–¥–µ–ª—è–µ–º —Ç–æ—á–∫—É
    this.selectBezierPoint(pointIndex);
    
    // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ñ–ª–∞–≥–∏ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏—è
    this.state.isDraggingPoint = true;
    this.state.draggingPointIndex = pointIndex;
    this.state.draggingPointStartX = x;
    this.state.draggingPointStartY = y;
    this.state.draggingPointOriginalX = point.x;
    this.state.draggingPointOriginalY = point.y;
}
    
updatePointDrag(x, y) {
    if (!this.state.isDraggingPoint) return;
    
    const pointIndex = this.state.draggingPointIndex;
    const point = this.state.bezierPoints[pointIndex];
    if (!point) return;
    
    // –í—ã—á–∏—Å–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ
    const dx = x - this.state.draggingPointStartX;
    const dy = y - this.state.draggingPointStartY;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ç–æ—á–∫–∏ –≤ –æ–±—ä–µ–∫—Ç–µ
    point.x = this.state.draggingPointOriginalX + dx;
    point.y = this.state.draggingPointOriginalY + dy;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
    if (point.element) {
        point.element.setAttribute('cx', point.x);
        point.element.setAttribute('cy', point.y);
    }
    
    // –û–ë–ù–û–í–õ–Ø–ï–ú –í–°–ï –°–í–Ø–ó–ê–ù–ù–´–ï –ö–û–ù–¢–†–û–õ–¨–ù–´–ï –¢–û–ß–ö–ò
    this.updateControlPointsForMovedPoint(pointIndex, dx, dy);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ä—Ç–æ–≤—É—é –ø–æ–∑–∏—Ü–∏—é –¥–ª—è –ø–ª–∞–≤–Ω–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
    this.state.draggingPointStartX = x;
    this.state.draggingPointStartY = y;
    this.state.draggingPointOriginalX = point.x;
    this.state.draggingPointOriginalY = point.y;
}

updateControlPointsForMovedPoint(movedPointIndex, dx, dy) {
    const movedPoint = this.state.bezierPoints[movedPointIndex];
    if (!movedPoint) return;
    
    // –ü—Ä–æ—Å—Ç–æ –¥–≤–∏–≥–∞–µ–º –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
    this.state.bezierVectors.forEach(vector => {
        if (vector.from === movedPointIndex) {
            vector.control1.x += dx;
            vector.control1.y += dy;
            
            if (vector.guideElements.control1) {
                vector.guideElements.control1.setAttribute('cx', vector.control1.x);
                vector.guideElements.control1.setAttribute('cy', vector.control1.y);
                vector.guideElements.line1.setAttribute('x2', vector.control1.x);
                vector.guideElements.line1.setAttribute('y2', vector.control1.y);
            }
        }
        
        if (vector.to === movedPointIndex) {
            vector.control2.x += dx;
            vector.control2.y += dy;
            
            if (vector.guideElements.control2) {
                vector.guideElements.control2.setAttribute('cx', vector.control2.x);
                vector.guideElements.control2.setAttribute('cy', vector.control2.y);
                vector.guideElements.line2.setAttribute('x2', vector.control2.x);
                vector.guideElements.line2.setAttribute('y2', vector.control2.y);
            }
        }
        
        this.updateBezierVectorPath(vector);
    });
}

    endPointDrag() {
        this.state.isDraggingPoint = false;
        this.state.draggingPointIndex = null;
    }
   
    // ============================================
    // –£–î–ê–õ–ï–ù–ò–ï –≠–õ–ï–ú–ï–ù–¢–û–í
    // ============================================
    
    // –£–î–ê–õ–ï–ù–ò–ï –¢–û–ß–ö–ò
    deleteBezierPoint(pointIndex) {
        const point = this.state.bezierPoints[pointIndex];
        if (!point) return;
        
        // –£–¥–∞–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç
        if (point.element && point.element.parentNode) {
            point.element.parentNode.removeChild(point.element);
        }
        
        // –£–¥–∞–ª—è–µ–º –≤–µ–∫—Ç–æ—Ä—ã, —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å —ç—Ç–æ–π —Ç–æ—á–∫–æ–π
        this.deleteVectorsForPoint(pointIndex);
        
        // –£–¥–∞–ª—è–µ–º —Ç–æ—á–∫—É –∏–∑ –º–∞—Å—Å–∏–≤–∞
        this.state.bezierPoints.splice(pointIndex, 1);
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã
        this.updatePointIndices();
        
        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ –µ—Å–ª–∏ —É–¥–∞–ª–∏–ª–∏ –≤—ã–¥–µ–ª–µ–Ω–Ω—É—é —Ç–æ—á–∫—É
        if (this.state.bezierSelectedPoint === pointIndex) {
            this.deselectAllPoints();
        }
    }
    
    deleteVectorsForPoint(pointIndex) {
        // –£–¥–∞–ª—è–µ–º —Å –∫–æ–Ω—Ü–∞ —á—Ç–æ–±—ã –∏–Ω–¥–µ–∫—Å—ã –Ω–µ —Å–±–∏–≤–∞–ª–∏—Å—å
        for (let i = this.state.bezierVectors.length - 1; i >= 0; i--) {
            const vector = this.state.bezierVectors[i];
            
            if (vector.from === pointIndex || vector.to === pointIndex) {
                // –£–¥–∞–ª—è–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
                if (vector.path && vector.path.parentNode) {
                    vector.path.parentNode.removeChild(vector.path);
                }
                
                if (vector.guideElements) {
                    if (vector.guideElements.line1) vector.guideElements.line1.remove();
                    if (vector.guideElements.control1) vector.guideElements.control1.remove();
                    if (vector.guideElements.line2) vector.guideElements.line2.remove();
                    if (vector.guideElements.control2) vector.guideElements.control2.remove();
                }
                
                // –£–¥–∞–ª—è–µ–º –∏–∑ –º–∞—Å—Å–∏–≤–∞
                this.state.bezierVectors.splice(i, 1);
            }
        }
    }
    
    updatePointIndices() {
        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã —Ç–æ—á–µ–∫
        this.state.bezierPoints.forEach((point, index) => {
            point.index = index;
            if (point.element) {
                point.element.setAttribute('data-index', index);
            }
        });
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å—ã –≤ –≤–µ–∫—Ç–æ—Ä–∞—Ö
        this.state.bezierVectors.forEach(vector => {
            // –£–º–µ–Ω—å—à–∞–µ–º –∏–Ω–¥–µ–∫—Å –µ—Å–ª–∏ –æ–Ω –±–æ–ª—å—à–µ —É–¥–∞–ª–µ–Ω–Ω–æ–≥–æ
            if (vector.from > this.state.bezierSelectedPoint) vector.from--;
            if (vector.to > this.state.bezierSelectedPoint) vector.to--;
        });
    }
    

    // ============================================
    // –£–¢–ò–õ–ò–¢–´
    // ============================================
    
    // –ü–û–õ–£–ß–ï–ù–ò–ï –ö–û–û–†–î–ò–ù–ê–¢ –í SVG
    getSVGCoordinates(e) {
        const pt = this.svg.createSVGPoint();
        pt.x = e.clientX;
        pt.y = e.clientY;
        return pt.matrixTransform(this.svg.getScreenCTM().inverse());
    }
      
// –∫–æ–Ω–µ—Ü –±–µ–∑—å–µ
// –£–ü–†–û–©–ï–ù–ù–ê–Ø —Ñ—É–Ω–∫—Ü–∏—è –ø—Ä–∏–≤—è–∑–∫–∏ (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è)
snapToBlackLine(x, y) {
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –¢–û –ñ–ï –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —á—Ç–æ –≤–∏–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å
    const imageForAnalysis = this.state.imageForDisplay || this.state.image;
    
    if (!imageForAnalysis || !this.state.imageUrl) return null;
    
    const imageElement = document.getElementById('background-image');
    if (!imageElement) return null;
    
    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const imgX = parseFloat(imageElement.getAttribute('x')) || 0;
    const imgY = parseFloat(imageElement.getAttribute('y')) || 0;
    const imgWidth = parseFloat(imageElement.getAttribute('width'));
    const imgHeight = parseFloat(imageElement.getAttribute('height'));
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã SVG –≤ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
    const imgCoordX = Math.round(((x - imgX) / imgWidth) * imageForAnalysis.width);
    const imgCoordY = Math.round(((y - imgY) / imgHeight) * imageForAnalysis.height);
    
    if (imgCoordX < 0 || imgCoordX >= imageForAnalysis.width || 
        imgCoordY < 0 || imgCoordY >= imageForAnalysis.height) {
        return null;
    }
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã–π canvas –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞
    if (!this.imageCanvasCache) {
        this.imageCanvasCache = document.createElement('canvas');
        this.imageCanvasCache.width = imageForAnalysis.width;
        this.imageCanvasCache.height = imageForAnalysis.height;
        const ctx = this.imageCanvasCache.getContext('2d');
        ctx.drawImage(imageForAnalysis, 0, 0);
        this.imageDataCache = ctx.getImageData(0, 0, imageForAnalysis.width, imageForAnalysis.height);
    }
    
    // –ò—â–µ–º –¢–Å–ú–ù–´–ï (—á–µ—Ä–Ω—ã–µ) –ø–∏–∫—Å–µ–ª–∏ –Ω–∞ –æ–±—ã—á–Ω–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏
    const radius = 8;
    let darkestPoint = null;
    let darkestValue = 256;
    
    const data = this.imageDataCache.data;
    const width = imageForAnalysis.width;
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ—á–∫–∏ –ø–æ –∫—Ä—É–≥—É
    for (let angle = 0; angle < 360; angle += 45) {
        const rad = angle * Math.PI / 180;
        const px = Math.round(imgCoordX + radius * Math.cos(rad));
        const py = Math.round(imgCoordY + radius * Math.sin(rad));
        
        if (px >= 0 && px < width && py >= 0 && py < imageForAnalysis.height) {
            const idx = (py * width + px) * 4;
            const brightness = (data[idx] + data[idx + 1] + data[idx + 2]) / 3;
            
            // –ò—â–µ–º –¢–Å–ú–ù–´–ï –ø–∏–∫—Å–µ–ª–∏ (—á–µ—Ä–Ω—ã–µ –ª–∏–Ω–∏–∏) - —á–µ–º –º–µ–Ω—å—à–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —Ç–µ–º —Ç–µ–º–Ω–µ–µ
            if (brightness < this.snapSettings.blackThreshold && brightness < darkestValue) {
                darkestValue = brightness;
                darkestPoint = {x: px, y: py};
            }
        }
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—É—é —Ç–æ—á–∫—É
    const centerIdx = (imgCoordY * width + imgCoordX) * 4;
    const centerBrightness = (data[centerIdx] + data[centerIdx + 1] + data[centerIdx + 2]) / 3;
    
    if (centerBrightness < this.snapSettings.blackThreshold && centerBrightness < darkestValue) {
        darkestValue = centerBrightness;
        darkestPoint = {x: imgCoordX, y: imgCoordY};
    }
    
    if (darkestPoint) {
        const snapX = (darkestPoint.x / imageForAnalysis.width) * imgWidth + imgX;
        const snapY = (darkestPoint.y / imageForAnalysis.height) * imgHeight + imgY;
        
        const dist = Math.sqrt((x - snapX) ** 2 + (y - snapY) ** 2);
        if (dist <= this.snapSettings.snapDistance / this.state.zoom) {
            return {x: snapX, y: snapY};
        }
    }
    
    return null;
}

			 startLine(x, y) {
                this.state.currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                this.state.currentElement.setAttribute('x1', x);
                this.state.currentElement.setAttribute('y1', y);
                this.state.currentElement.setAttribute('x2', x);
                this.state.currentElement.setAttribute('y2', y);
                this.state.currentElement.setAttribute('stroke', this.state.strokeColor);
				this.state.currentElement.setAttribute('stroke-width', this.state.strokeWidth);
                this.state.currentElement.setAttribute('fill', 'none');
                
                this.svg.appendChild(this.state.currentElement);
            }
            
            updateLine(x, y) {
                this.state.currentElement.setAttribute('x2', x);
                this.state.currentElement.setAttribute('y2', y);
            }
            
            startRect(x, y) {
                this.state.currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                this.state.currentElement.setAttribute('x', x);
                this.state.currentElement.setAttribute('y', y);
                this.state.currentElement.setAttribute('width', '0');
                this.state.currentElement.setAttribute('height', '0');
                this.state.currentElement.setAttribute('stroke', this.state.strokeColor);
                this.state.currentElement.setAttribute('stroke-width', this.state.strokeWidth);
                this.state.currentElement.setAttribute('fill', 'none');
                
                this.svg.appendChild(this.state.currentElement);
            }
            
            updateRect(x, y) {
                const width = x - this.state.startPoint.x;
                const height = y - this.state.startPoint.y;
                
                this.state.currentElement.setAttribute('x', width >= 0 ? this.state.startPoint.x : x);
                this.state.currentElement.setAttribute('y', height >= 0 ? this.state.startPoint.y : y);
                this.state.currentElement.setAttribute('width', Math.abs(width));
                this.state.currentElement.setAttribute('height', Math.abs(height));
            }
            
            startCircle(x, y) {
                this.state.currentElement = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.state.currentElement.setAttribute('cx', x);
                this.state.currentElement.setAttribute('cy', y);
                this.state.currentElement.setAttribute('r', '0');
                this.state.currentElement.setAttribute('stroke', this.state.strokeColor);
                this.state.currentElement.setAttribute('stroke-width', this.state.strokeWidth);
                this.state.currentElement.setAttribute('fill', 'none');
                
                this.svg.appendChild(this.state.currentElement);
            }
            
            updateCircle(x, y) {
                const dx = x - this.state.startPoint.x;
                const dy = y - this.state.startPoint.y;
                const radius = Math.sqrt(dx * dx + dy * dy);
                
                this.state.currentElement.setAttribute('r', radius);
            }

            updateCoordinates(e) {
                const coords = this.getSVGCoordinates(e);
                document.getElementById('coordinates').textContent = 
                    `X: ${Math.round(coords.x)}, Y: ${Math.round(coords.y)}`;
            }
// –°–ö–†–´–¢–¨ –í–°–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –≠–õ–ï–ú–ï–ù–¢–´ –ë–ï–ó–¨–ï
hideBezierHelpers() {
    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
    document.querySelectorAll('.bezier-guide-line').forEach(line => {
        line.style.display = 'none';
    });
    
    // –°–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
    document.querySelectorAll('.bezier-control-point').forEach(point => {
        point.style.display = 'none';
    });
    
    // –°–Ω–∏–º–∞–µ–º –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å —Ç–æ—á–µ–∫
    this.deselectAllPoints();
}

// –ü–û–ö–ê–ó–ê–¢–¨ –í–°–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –≠–õ–ï–ú–ï–ù–¢–´ –ë–ï–ó–¨–ï
showBezierHelpers() {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –ª–∏–Ω–∏–∏
    document.querySelectorAll('.bezier-guide-line').forEach(line => {
        line.style.display = 'block';
    });
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –∫–æ–Ω—Ç—Ä–æ–ª—å–Ω—ã–µ —Ç–æ—á–∫–∏
    document.querySelectorAll('.bezier-control-point').forEach(point => {
        point.style.display = 'block';
    });
}

// –°–ö–†–´–¢–¨/–ü–û–ö–ê–ó–ê–¢–¨ –û–°–ù–û–í–ù–´–ï –¢–û–ß–ö–ò –ë–ï–ó–¨–ï
toggleBezierPoints(show) {
    document.querySelectorAll('.bezier-point').forEach(point => {
        point.style.display = show ? 'block' : 'none';
    });
}
       
clearVectors() {
    if (!confirm('–£–¥–∞–ª–∏—Ç—å –≤—Å–µ –≤–µ–∫—Ç–æ—Ä—ã?')) return;
    
    // –£–¥–∞–ª—è–µ–º –≤—Å–µ –≤–µ–∫—Ç–æ—Ä—ã –ë–µ–∑—å–µ (–∏ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã)
    document.querySelectorAll('.bezier-vector, .bezier-guide-line, .bezier-control-point, .bezier-point').forEach(el => {
        el.remove();
    });
    
    // –¢–∞–∫–∂–µ —É–¥–∞–ª—è–µ–º –æ–±—ã—á–Ω—ã–µ –≤–µ–∫—Ç–æ—Ä—ã
    const vectorElements = this.svg.querySelectorAll('path:not([id*="indicator"]):not([id*="background"]), line, rect, circle');
    vectorElements.forEach(el => {
        if (!el.classList.contains('bezier-vector') && 
            !el.classList.contains('bezier-guide-line') && 
            !el.classList.contains('bezier-control-point') && 
            !el.classList.contains('bezier-point')) {
            el.remove();
        }
    });
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    this.state.currentElement = null;
    this.state.isDrawing = false;
    this.state.penPoints = [];
    this.pushData = null;
    this.state.bezierPoints = [];
    this.state.bezierVectors = [];
    this.state.bezierSelectedPoint = null;
    this.state.lastBezierDirection = null;
    this.state.lastBezierLength = null;
}
          
saveSVG() {
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–∏–∞–ª–æ–≥–æ–≤–æ–µ –æ–∫–Ω–æ —Å –≤—ã–±–æ—Ä–æ–º
    const saveWithBackground = confirm('–°–æ—Ö—Ä–∞–Ω–∏—Ç—å SVG —Å –ø–æ–¥–ª–æ–∂–∫–æ–π? –ù–∞–∂–º–∏—Ç–µ OK –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å –ø–æ–¥–ª–æ–∂–∫–æ–π, –û—Ç–º–µ–Ω–∞ - –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ–ª—å–∫–æ –≤–µ–∫—Ç–æ—Ä–æ–≤.');
    
    // –ö–ª–æ–Ω–∏—Ä—É–µ–º SVG
    const clone = this.svg.cloneNode(true);
    
    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –≤—ã–±—Ä–∞–ª —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –ë–ï–ó –ø–æ–¥–ª–æ–∂–∫–∏
    if (!saveWithBackground) {
        // –£–¥–∞–ª—è–µ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –∏–∑ –∫–ª–æ–Ω–∞
        const backgroundImage = clone.querySelector('#background-image');
        if (backgroundImage) {
            backgroundImage.remove();
        }
        
        // –£–¥–∞–ª—è–µ–º –≤—Å–µ –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã –ë–µ–∑—å–µ (—à–∞—Ä—ã-—Ç–æ—á–∫–∏ –∏ –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ)
        const bezierHelpers = clone.querySelectorAll(
            '.bezier-guide-line, .bezier-control-point, .bezier-point'
        );
        bezierHelpers.forEach(el => el.remove());
        
        // –£–¥–∞–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
        const indicators = clone.querySelectorAll('[id*="indicator"]');
        indicators.forEach(el => el.remove());
    } else {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å –ø–æ–¥–ª–æ–∂–∫–æ–π - —É–¥–∞–ª—è–µ–º —Ç–æ–ª—å–∫–æ –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã
        const indicators = clone.querySelectorAll('[id*="indicator"]');
        indicators.forEach(el => el.remove());
        
        // –¢–∞–∫–∂–µ —É–¥–∞–ª—è–µ–º —Ç–æ—á–∫–∏ –ë–µ–∑—å–µ (—à–∞—Ä–∏–∫–∏), –Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º —Å–∞–º–∏ –∫—Ä–∏–≤—ã–µ
        const bezierPoints = clone.querySelectorAll('.bezier-point, .bezier-control-point');
        bezierPoints.forEach(el => el.remove());
    }
    
    // –í –õ–Æ–ë–û–ú –°–õ–£–ß–ê–ï —É–¥–∞–ª—è–µ–º —à–∞—Ä—ã-—Ç–æ—á–∫–∏ –ë–µ–∑—å–µ –∏–∑ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ SVG
    // (–æ–Ω–∏ –Ω—É–∂–Ω—ã —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –∞ –Ω–µ –¥–ª—è —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞)
    const allBezierPoints = clone.querySelectorAll('.bezier-point, .bezier-control-point');
    allBezierPoints.forEach(el => el.remove());
    
    // –£–¥–∞–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª—è—é—â–∏–µ –ª–∏–Ω–∏–∏ (–Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º —Å–∞–º–∏ –∫—Ä–∏–≤—ã–µ –ë–µ–∑—å–µ)
    const guideLines = clone.querySelectorAll('.bezier-guide-line');
    guideLines.forEach(el => el.remove());
    
    // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É SVG
    const serializer = new XMLSerializer();
    let svgString = serializer.serializeToString(clone);
    
    // –î–æ–±–∞–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫
    svgString = '<?xml version="1.0" encoding="UTF-8"?>\n' + svgString;
    
    // –°–æ–∑–¥–∞–µ–º —Ñ–∞–π–ª –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è
    const blob = new Blob([svgString], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = saveWithBackground ? '—Ä–∏—Å—É–Ω–æ–∫_—Å_–ø–æ–¥–ª–æ–∂–∫–æ–π.svg' : '—Ä–∏—Å—É–Ω–æ–∫_–≤–µ–∫—Ç–æ—Ä—ã.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏
    alert(`SVG —É—Å–ø–µ—à–Ω–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω –∫–∞–∫ "${a.download}"`);
}

       }
        
        // –ó–∞–ø—É—Å–∫ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        document.addEventListener('DOMContentLoaded', () => {
            window.editor = new VectorEditor();
        });
    </script>
</body>
</html>
