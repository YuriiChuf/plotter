
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Font Editor</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #1e1e2e;
            color: #cdd6f4;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            background: linear-gradient(135deg, #585b70 0%, #313244 100%);
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #45475a;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .logo i {
            font-size: 28px;
            color: #89b4fa;
        }

        .logo h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .controls {
            display: flex;
            gap: 15px;
        }

        button {
            background-color: #89b4fa;
            color: #1e1e2e;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all 0.3s ease;
        }

        button:hover {
            background-color: #74c7ec;
            transform: translateY(-2px);
        }

        button.secondary {
            background-color: #45475a;
            color: #cdd6f4;
        }

        button.secondary:hover {
            background-color: #585b70;
        }

        button.active {
            background-color: #cba6f7;
            color: #1e1e2e;
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 320px;
            background-color: #181825;
            border-right: 1px solid #45475a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .panel {
            padding: 20px;
            border-bottom: 1px solid #313244;
        }

        .panel h3 {
            margin-bottom: 15px;
            color: #89b4fa;
            font-size: 18px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel h3 i {
            font-size: 20px;
        }

        .glyph-list {
            max-height: 300px;
            overflow-y: auto;
        }
/* Стиль для пустых глифов (без векторов) */
.glyph-item.empty-glyph {
    opacity: 0.6;
    background-color: #2a2a3a; /* Более темный фон */
    border-left: 4px solid #585b70; /* Серый бордер вместо синего */
}

.glyph-item.empty-glyph:hover {
    background-color: #353547;
}

.glyph-item.empty-glyph.active {
    background-color: #3a3a4d;
    border-left: 4px solid #9C9C2C;
}

/* Индикатор статуса глифа */
.glyph-status {
    font-size: 10px;
    color: #a6adc8;
    font-style: italic;
    margin-top: 2px;
}

/* Делаем символ пустого глифа бледнее */
.glyph-item.empty-glyph .glyph-char {
    opacity: 0.7;
}

.glyph-item.empty-glyph .glyph-name {
    color: #8a8fa3;
}

.glyph-item:not(.empty-glyph) .glyph-char {
    color: #89b4fa; /* Синий для глифов с векторами */
}

.glyph-item.empty-glyph .glyph-char {
    color: #a6adc8; /* Серый для пустых глифов */
}

.glyph-item.active:not(.empty-glyph) .glyph-char {
    color: #cba6f7; /* Фиолетовый для активного глифа с векторами */
}

.glyph-item.active.empty-glyph .glyph-char {
    color: #f9e2af; /* Желтый для активного пустого глифа */
}
        .glyph-item {
            padding: 12px;
            background-color: #313244;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }

        .glyph-item:hover {
            background-color: #45475a;
        }

        .glyph-item.active {
            background-color: #585b70;
            border-left: 4px solid #89b4fa;
        }

        .glyph-info {
            display: flex;
            flex-direction: column;
        }

        .glyph-char {
            font-size: 20px;
            font-weight: bold;
        }

        .glyph-name {
            font-size: 12px;
            color: #a6adc8;
        }

        .glyph-actions {
            display: flex;
            gap: 5px;
        }

        .glyph-actions button {
            padding: 5px;
            background: transparent;
            color: #cdd6f4;
        }

        .glyph-actions button:hover {
            background-color: #45475a;
        }

        .properties {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
        }

        .property {
            display: flex;
            flex-direction: column;
        }

        label {
            font-size: 14px;
            margin-bottom: 5px;
            color: #a6adc8;
        }

        input, select {
            padding: 10px;
            background-color: #313244;
            border: 1px solid #45475a;
            border-radius: 6px;
            color: #cdd6f4;
            width: 100%;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #89b4fa;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }

        .checkbox-container input {
            width: 18px;
            height: 18px;
        }

        .main-area {
			height: 2000px;
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
            overflow: hidden;
        }

        .editor-container {
            flex: 1;
            background-color: #181825;
            border-radius: 12px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border: 1px solid #45475a;
        }

        .editor-header {
            padding: 15px 20px;
            background-color: #313244;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor-header h3 {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tools {
            display: flex;
            gap: 1px;
        }

        .tools button {
            padding: 10px 2px;
            font-size: 12px;
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
            height: 90vh;
        }

        #svg-canvas {
            background-color: #1e1e2e;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            min-height: 1600px;
            min-width: 1000px;
        }

        .underlay-svg {
            fill: rgba(136, 136, 136, 0.15);
            font-family: Arial, sans-serif;
            pointer-events: none;
            user-select: none;
        }

        .no-glyph {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #a6adc8;
        }

        .no-glyph i {
            font-size: 60px;
            margin-bottom: 20px;
            color: #45475a;
        }

        .no-glyph h3 {
            font-size: 22px;
            margin-bottom: 10px;
        }

        .no-glyph p {
            max-width: 400px;
            line-height: 1.5;
        }

        footer {
            padding: 15px;
            background-color: #181825;
            border-top: 1px solid #313244;
            text-align: center;
            font-size: 14px;
            color: #a6adc8;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #1e1e2e;
            padding: 30px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            border: 1px solid #45475a;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h3 {
            color: #89b4fa;
        }

        .close-modal {
            background: none;
            border: none;
            color: #cdd6f4;
            font-size: 24px;
            cursor: pointer;
            padding: 0;
        }

        .font-list {
            max-height: 300px;
            overflow-y: auto;
            margin: 20px 0;
        }

        .font-item {
            padding: 12px;
            background-color: #313244;
            margin-bottom: 8px;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .font-item:hover {
            background-color: #45475a;
        }

        .font-item.active {
            background-color: #585b70;
            border-left: 4px solid #89b4fa;
        }

		.point[data-point-type="end"] {
			fill: #fab387; /* ОРАНЖЕВЫЙ - крайние И одиночные */
		}

		.point[data-point-type="isolated"] {
			fill: #fab387; /* ТОЖЕ ОРАНЖЕВЫЙ - одиночные как крайние */
		}

		.point[data-point-type="middle"] {
			fill: #89b4fa; /* СИНИЙ - промежуточные */
		}

		.point.selected {
					stroke: #f9e2af;
					filter: drop-shadow(0 0 2px rgba(249, 226, 175, 0.9));

		}
		.point {
			fill: #f38ba8;
			cursor: pointer;
			stroke: #1e1e2e;
			stroke-width: 2;
			r: 5px;
		}

		.point[data-point-type="end"],
		.point[data-point-type="isolated"] {
			r: 6px; /* Оранжевые точки чуть больше */
		}

        .point:hover {
            filter: drop-shadow(0 0 2px rgba(243, 139, 168, 0.5));
        }

        .path {
            fill: none;
            stroke: #89b4fa;
            stroke-width: 3;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .control-line {
            stroke: #f38ba8;
            stroke-width: 1;
            stroke-dasharray: 5,5;
        }

        .control-point {
            fill: #fab387;
            cursor: move;
            stroke: #1e1e2e;
            stroke-width: 2;
        }

        .control-point.selected {
            fill: #f9e2af;
            stroke: #f9e2af;
        }

        .instructions {
            padding: 20px;
            background-color: #313244;
            border-radius: 8px;
            margin-top: 20px;
        }

        .instructions h4 {
            margin-bottom: 10px;
            color: #89b4fa;
        }

        .instructions ul {
            padding-left: 20px;
            line-height: 1.6;
        }

        .instructions li {
            margin-bottom: 8px;
        }

        .font-info {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .font-info-item {
            background-color: #313244;
            padding: 15px;
            border-radius: 8px;
            flex: 1;
            min-width: 200px;
        }

        .font-info-item h4 {
            color: #89b4fa;
            margin-bottom: 5px;
            font-size: 14px;
        }

        .font-info-value {
            font-size: 18px;
            font-weight: bold;
        }

        .guideline {
            stroke-width: 1;
        }

        .guideline.horizontal {
            stroke: #a6e3a1;
            stroke-dasharray: 10,5;
        }

        .guideline.vertical {
            stroke: #f9e2af;
            stroke-dasharray: 10,5;
        }

        .guideline.draggable {
            pointer-events: all;
            cursor: ew-resize;
			stroke-width: 2;
        }

        .guideline.draggable.horizontal {
            cursor: ns-resize;
        }

        .guideline-toolbar {
            display: flex;
			width: 100%;
            gap: 8px;
            margin-top: 10px;
        }
        .guideline-toolbar button {
            padding: 6px 10px;
            font-size: 12px;
            flex: 1;
        }
        .delete-vector-line {
            pointer-events: none;
            stroke: #ff0000 !important;
            stroke-width: 2 !important;
            stroke-dasharray: 5,3 !important;
            opacity: 0.8;
        }

        .mirror-controls {
			display: grid;
			grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .mirror-controls button {
            flex: 1;
            padding: 8px;
			
        }
		
		.mirror-controls button:disabled {
			opacity: 0.5;
			cursor: not-allowed !important;
			background-color: #45475a !important;
			color: #6c7086 !important;
			border-color: #585b70 !important;
		}

		.mirror-controls button.active {
			background-color: rgba(203, 166, 247, 0.9);
			color: #1e1e2e;
			border-color: #cba6f7;
		}

        .guideline-info {
            margin-top: 10px;
            font-size: 12px;
            color: #a6adc8;
        }

        .guideline-list {
            max-height: 150px;
            overflow-y: auto;
            margin-top: 10px;
            background-color: #313244;
            border-radius: 6px;
            padding: 10px;
        }

        .guideline-item {
            padding: 8px;
            margin-bottom: 5px;
            background-color: #45475a;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .guideline-item button {
            padding: 4px 8px;
            font-size: 10px;
        }
		.segment-highlight {
			stroke: #ECF35C !important;
			stroke-width: 4 !important;
			opacity: 0.3;
			pointer-events: none;
			fill: none;
		}
		.floating-tools {
			position: fixed;
			left: 20px;
			bottom: 20px;
			display: flex;
			gap: 10px;
			z-index: 1000;
			background-color: rgba(24, 24, 37, 0.95);
			border: 1px solid #45475a;
			border-radius: 12px;
			padding: 15px;
			box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
			backdrop-filter: blur(10px);
		}

		.floating-tools button {
			padding: 10px 20px;
			background-color: rgba(69, 71, 90, 0.7);
			color: #cdd6f4;
			border: 1px solid #585b70;
			border-radius: 8px;
			cursor: pointer;
			font-weight: 600;
			display: flex;
			align-items: center;
			gap: 8px;
			transition: all 0.3s ease;
			white-space: nowrap;
		}
		

		.floating-tools button:hover {
			background-color: rgba(89, 91, 112, 0.9);
			transform: translateY(-2px);
		}

		.floating-tools button.active {
			background-color: rgba(203, 166, 247, 0.9);
			color: #1e1e2e;
			border-color: #cba6f7;
		}

		.floating-tools button.secondary {
			background-color: rgba(56, 58, 75, 0.7);
		}

		.floating-tools button.secondary:hover {
			background-color: rgba(76, 78, 95, 0.9);
		}
		
		.direction-arrow {
			pointer-events: none;
		}

		.direction-arrow circle {
			cursor: pointer;
			pointer-events: all;
		}

		.direction-arrow circle:hover {
			fill: #fab387;
			r: 4;
		}

@keyframes slideIn {
    from { transform: translateX(100%); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

@keyframes slideOut {
    from { transform: translateX(0); opacity: 1; }
    to { transform: translateX(100%); opacity: 0; }
}

#debug-text {
    font-family: monospace;
    letter-spacing: 2px;
}

#svg-font-preview, #underlay-preview {
    overflow: hidden;
    position: relative;
}

#svg-font-preview::before, #underlay-preview::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    background: rgba(243, 139, 168, 0.3);
    transform: translateY(-50%);
}

#underlay-preview::before {
    background: rgba(166, 227, 161, 0.3);
}
		
    </style>
</head>
<body>
    <header>
        <div class="logo">
            <i class="fas fa-font"></i>
            <h1>SVG Font Editor</h1>
        </div>
        <div class="controls">
            <button id="new-font"><i class="fas fa-plus"></i> Новый шрифт</button>
            <button id="load-font" class="secondary"><i class="fas fa-upload"></i> Загрузить SVG шрифт</button>
            <button id="save-font"><i class="fas fa-save"></i> Сохранить шрифт</button>
        </div>
    </header>

    <div class="container">
        <div class="sidebar">
            <div class="panel">
                <h3><i class="fas fa-info-circle"></i> Информация о шрифте</h3>
                <div class="font-info">
                    <div class="font-info-item">
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px;">
        <h4 style="margin: 0;">Название шрифта</h4>
        <button id="rename-font-btn" class="secondary" 
                style="padding: 4px 8px; background: transparent; color: #cdd6f4; border: none; cursor: pointer; margin: 0;" 
                title="Переименовать шрифт">
            <i class="fas fa-pen" style="font-size: 12px;"></i>
        </button>
    </div>
    <div class="font-info-value" id="font-name">
        CircleC
    </div>
</div>
                    <div class="font-info-item">
                        <h4>Глифов</h4>
                        <div class="font-info-value" id="glyph-count">94</div>
                    </div>
                    <div class="font-info-item">
                        <h4>Units per Em</h4>
                        <div class="font-info-value" id="units-per-em">1000</div>
                    </div>
                </div>
            </div>
            
            <div class="panel">
                <h3><i class="fas fa-shapes"></i> Глифы</h3>
                <div class="glyph-list" id="glyph-list">
                    <!-- Глифы будут добавлены динамически -->
                </div>
                <div style="margin-top: 15px;">
                    <button id="add-glyph" class="secondary" style="width: 100%;"><i class="fas fa-plus"></i> Добавить глиф</button>
                </div>
            </div>
            
            <div class="panel">
                <h3><i class="fas fa-sliders-h"></i> Свойства глифа</h3>
                <div class="properties">
                    <div class="property">
                        <label for="glyph-char">Символ</label>
                        <input type="text" id="glyph-char" maxlength="1" placeholder="A">
                    </div>
                    <div class="property">
                        <label for="glyph-name">Имя глифа</label>
                        <input type="text" id="glyph-name" placeholder="A">
                    </div>
                    <div class="property">
                        <label for="horiz-adv">Horiz Advance</label>
                        <input type="number" id="horiz-adv" value="500">
                    </div>
                    <div class="property">
                        <label for="unicode">Unicode</label>
                        <input type="text" id="unicode" placeholder="U+0041">
                    </div>
                </div>
                <div class="mirror-controls">
                    <button id="mirror-horizontal" class="secondary"><i class="fas fa-arrows-alt-h"></i> Отразить по X</button>
                    <button id="mirror-vertical" class="secondary"><i class="fas fa-arrows-alt-v"></i> Отразить по Y</button>
					<button id="toggle-direction" class="secondary">
						<i class="fas fa-project-diagram"></i> Направление
					</button>
					<button id="reverse-contour" class="secondary">
						<i class="fas fa-retweet"></i> Развернуть контур
					</button>
					<button id="debug-tool">
					<i class="fas fa-bug"></i> Наладка
				</button>
                </div>
				<div class="properties">
				<div class="property">
					<label for="zoom-scale">Масштаб (%)</label>
					<input type="number" id="zoom-scale" value="100" min="10" max="300" step="5">
				</div>

				</div>
            </div>
            
            <div class="panel">
                <h3><i class="fas fa-ruler"></i> Направляющие</h3>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-guidelines" checked>
                    <label for="show-guidelines">Показать направляющие</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-underlay">
                    <label for="show-underlay">Показать подложку</label>
                </div>
                <div class="checkbox-container">
                    <input type="checkbox" id="show-controls">
                    <label for="show-controls">Показать контрольные точки</label>
                </div>
                
                <div class="guideline-toolbar">
                    <button id="guideline-tool" class="secondary"><i class="fas fa-ruler"></i>+</button>
                    <button id="add-h-guideline" class="secondary"><i class="fas fa-minus"></i> Горизонт.</button>
                    <button id="add-v-guideline" class="secondary"><i class="fas fa-grip-lines-vertical"></i> Вертик.</button>
                    <button id="clear-guidelines" class="secondary"><i class="fas fa-trash"></i> Все</button>
                </div>
                
                <div class="guideline-info">
					<div>Базовые направляющие:</div>
					<div>• Верх: 
						<input type="number" id="top-guide" value="200" style="width: 60px; padding: 3px; font-size: 12px;">
						
					</div>
					<div>• Низ :
						<input type="number" id="bottom-guide" value="1200" style="width: 60px; padding: 3px; font-size: 12px;">
						
					</div>
					<div>• Лево: <input type="number" id="left-guide" value="0" style="width: 60px; padding: 3px; font-size: 12px;"></div>
					<div>• Право: <input type="number" id="right-guide" value="500" style="width: 60px; padding: 3px; font-size: 12px;"></div>
				</div>
                
                <div class="guideline-list" id="custom-guidelines">
                    <!-- Пользовательские направляющие -->
                </div>
            </div>
            
            <div class="properties">

            </div>
            
            <div class="instructions">
                <h4>Инструкция по редактированию:</h4>
                        <li><strong>Горячие клавиши:</strong>
            <ul style="margin-left: 20px; margin-top: 5px;">
                <li><strong>M</strong> - Инструмент "Изменить" (Select tool)</li>
                <li><strong>A</strong> - Инструмент "Добавить" (Add point tool)</li>
                <li><strong>D</strong> - Инструмент "Удалить" (Delete tool)</li>
                <li><strong>Alt + клик</strong> - Соединить две выделенные точки</li>
                <li><strong>Delete</strong> - Удалить выделенную точку или сегмент</li>
				<li><strong>Backspace</strong> - Отменить последнее действие</li>
                <li><strong>Ctrl + Z</strong> - Отменить последнее действие</li>
                <li><strong>Escape</strong> - Снять все выделения</li>
                <li><strong>Ctrl + стрелки</strong> - Переключение между глифами</li>
                <li><strong>Двойной клик</strong> на точке - Изменить тип сегмента (линия ↔ кривая)</li>
                <li><strong>Двойной клик</strong> на векторе - Изменить тип вектора (линия ↔ кривая)</li>
            </ul>
        </li>
            </div>
        </div>
        
        <div class="main-area">
            <div class="editor-container">
                <div class="editor-header">
                    <h3><i class="fas fa-edit"></i> Редактор глифа: <span id="current-glyph-name">Выберите глиф</span></h3>
                    <div class="tools">
                        <button id="import-underlay" class="secondary"><i class="fas fa-font"></i> Загрузить подложку</button>
                        <button id="reset-view"><i class="fas fa-sync-alt"></i> Сбросить вид</button>
                    </div>
                </div>
                
                <div class="canvas-container">
                    <div id="no-glyph" class="no-glyph" style="display: block;">
                        <i class="fas fa-font"></i>
                        <h3>SVG Font Editor</h3>
                        <p>Выберите глиф из списка слева для редактирования или создайте новый шрифт.</p>
                        <p>Загрузите обычный шрифт как подложку для помощи в создании векторных глифов.</p>
                    </div>
                    
                    <svg id="svg-canvas" width="800" height="600" style="display: none;"></svg>
                </div>
            </div>
        </div>
    </div>
    
    <footer>
        <p>SVG Font Editor &copy; 2023 | Загрузите SVG шрифт для редактирования или создайте новый</p>
    </footer>
    
    <!-- Модальное окно загрузки шрифта -->
    <div id="font-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3><i class="fas fa-upload"></i> Загрузить шрифт как подложку</h3>
                <button class="close-modal">&times;</button>
            </div>
            <p>Выберите шрифт для использования в качестве подложки при создании SVG глифов:</p>
            <div class="font-list" id="system-fonts">
                <!-- Системные шрифты -->
            </div>
            <div style="margin-top: 20px;">
                <label for="custom-font">Или введите название шрифта:</label>
                <input type="text" id="custom-font" placeholder="Arial, Times New Roman, etc." style="width: 100%; margin-top: 5px;">
            </div>
            <div style="margin-top: 20px; display: flex; gap: 10px;">
                <button id="load-underlay" style="flex: 1;"><i class="fas fa-check"></i> Загрузить</button>
				    <button id="load-from-file" style="flex: 1;" class="secondary"><i class="fas fa-folder-open"></i> Загрузить из файла</button>

                <button class="secondary close-modal" style="flex: 1;">Отмена</button>
            </div>
        </div>
    </div>
    
<div class="floating-tools">
    <!-- Основные инструменты -->
    <button id="select-tool" class="active">
        <i class="fas fa-arrows-alt"></i> Изменить
    </button>
    <button id="add-point-tool">
        <i class="fas fa-plus-circle"></i> Добавить
    </button>
    <button id="add-vector-tool">
        <i class="fas fa-cut"></i> Удалить
    </button>
    
</div>

<!-- Модальное окно для наладки -->
<div id="debug-modal" class="modal" style="display:none;">
    <div class="modal-content" style="max-width:500px;">
        <div class="modal-header">
            <h3><i class="fas fa-bug"></i> Наладка подложки</h3>
            <button class="close-modal">&times;</button>
        </div>
        <div style="padding:20px;">
            <div class="property" style="margin-bottom:15px;">
                <label for="debug-text">Текст для сравнения</label>
                <input type="text" id="debug-text" value="A" 
                       style="width:100%; font-size:16px; padding:8px;">
            </div>
            
            <!-- ПРОСТОЙ БЛОК С ТЕКСТОМ -->
            <div style="
                height:200px; 
                background:#1e1e2e; 
                border:1px solid #45475a; 
                border-radius:8px;
                padding:20px;
                position:relative;
                display:flex;
                align-items:center;
                justify-content:center;
                margin-top:10px;
            ">
                <div id="text-overlay" style="position:relative;">
                    <!-- Здесь будет наложенный текст -->
                </div>
            </div>
            
            <div style="margin-top:10px; display:flex; gap:15px; justify-content:center; font-size:12px;">
                <div style="display:flex; align-items:center; gap:5px;">
                    <div style="width:12px; height:12px; background:#a6e3a1;"></div>
                    <span style="color:#a6adc8;">Подложка</span>
                </div>
                <div style="display:flex; align-items:center; gap:5px;">
                    <div style="width:12px; height:12px; background:#89b4fa;"></div>
                    <span style="color:#a6adc8;">SVG шрифт</span>
                </div>
            </div>
            
            <div style="margin-top:20px; display:flex; gap:10px;">
                <button id="update-debug" style="flex:1;">
                    <i class="fas fa-sync-alt"></i> Обновить
                </button>
                <button class="secondary close-modal" style="flex:1;">
                    Закрыть
                </button>
            </div>
        </div>
    </div>
</div>

<input type="file" id="svg-font-input" accept=".svg,.xml" style="display:none;">
<input type="file" id="underlay-font-input" accept=".ttf,.otf,.woff,.woff2,.ttc" style="display:none;">
    <script>
        // ========================
        // КОНСТАНТЫ И НАСТРОЙКИ

        const TOOLS = {
            SELECT: 'select',
            ADD_POINT: 'add-point',
            DELETE: 'delete',
            GUIDELINE: 'guideline'
        };

        // =======================
        // МОДЕЛЬ ДАННЫХ

        class FontEditor {
            constructor() {
                // Основные данные шрифта
                this.fontData = {
                    name: "CircleC",
                    horizAdvX: 500,
                    unitsPerEm: 1000,
                    ascent: 800,
                    descent: -200,
                    capHeight: 500,
                    xHeight: 300,
                    glyphs: []
                };
				this.history = {
					actions: [],
					maxHistory: 10, // Максимальное количество шагов в истории
					currentIndex: -1
				};
                // Текущий глиф
                this.currentGlyph = null;
                
                // Состояние редактора
                this.state = {
                    currentTool: TOOLS.SELECT,
                    selectedPoint: null,
                    draggingPoint: null,
                    draggingGuideline: null,
                    deleteVectorStart: null,
                    deleteVectorTempLine: null,
                    guidelineCreationStart: null,
                    underlayFont: null,
					selectedSegment: null,
					isCreatingTemplate: false, // Флаг создания шаблона
					fileDialogOpen: false // Флаг открытого диалога
                };
                
                // Топология пути
                this.pathTopology = {
                    contours: [] // Массив контуров
                };
                
                // Направляющие
                this.guidelines = {
                    top: 200,       // unitsPerEm - ascent
                    bottom: 1200,   // unitsPerEm - descent
                    left: 0,
                    right: 500,
                    baseline: 1000, // unitsPerEm
                    custom: []      // Пользовательские направляющие
                };
                
                // Инициализация
                this.init();
            }
            
            // ===================
            // ИНИЦИАЛИЗАЦИЯ

            init() {
                this.loadExampleFont();
                this.initSVGCanvas();
                this.initEventListeners();
                this.populateSystemFonts();
                this.updateFontInfo();
                this.updateGuidelineControls();
            }
            
            // Загрузка примера шрифта
            loadExampleFont() {
                this.fontData = {
                    name: "CircleC",
                    horizAdvX: 500,
                    unitsPerEm: 1000,
                    ascent: 800,
                    descent: -200,
                    capHeight: 500,
                    xHeight: 300,
                    glyphs: [
                        {unicode: " ", name: "space", d: "", horizAdvX: 221},
                        {unicode: "!", name: "!", d: "M 108.61 37.89 C 108.61 19.54 93.74 4.67 75.39 4.67 C 57.04 4.67 42.17 19.54 42.17 37.89 C 42.17 56.24 57.04 71.11 75.39 71.11 C 93.74 71.11 108.61 56.24 108.61 37.89 Z M 75.78 611.72 L 75.78 126.56", horizAdvX: 146},
                        {unicode: "A", name: "A", d: "M 467.5 247.81 L 467.5 9.16 M 544.84 248.36 C 544.84 180.82 518.07 116.05 470.42 68.29 C 422.76 20.54 358.13 -6.29 290.74 -6.29 C 150.41 -6.29 36.65 107.72 36.65 248.36 C 36.65 389 150.41 503.01 290.74 503.01 C 358.13 503.01 422.76 476.18 470.42 428.43 C 518.07 380.67 544.84 315.9 544.84 248.36 Z", horizAdvX: 605},
                        {unicode: "B", name: "B", d: "M 114.74 659.92 L 114.74 247.81 M 545.6 248.36 C 545.6 107.73 431.84 -6.28 291.51 -6.28 C 151.18 -6.28 37.42 107.73 37.42 248.36 C 37.42 389 151.18 503 291.51 503 C 431.84 503 545.6 389 545.6 248.36 Z", horizAdvX: 582},
                        {unicode: "C", name: "C", d: "M 450.61 75.16 C 404.59 25.06 338.81 -6.3 265.77 -6.3 C 126.65 -6.3 13.88 107.47 13.88 247.81 C 13.88 388.14 126.65 501.91 265.77 501.91 C 337.12 501.92 401.54 471.99 447.37 423.91", horizAdvX: 457}
                    ]
                };
                
                // Преобразуем координаты Y
                this.fontData.glyphs.forEach(glyph => {
                    if (glyph.d) {
                        glyph.d = this.flipYCoordinates(glyph.d, this.fontData.unitsPerEm);
                    }
                });
                
                // Устанавливаем направляющие
                this.guidelines.top = this.fontData.unitsPerEm - this.fontData.ascent;
                this.guidelines.bottom = this.fontData.unitsPerEm - this.fontData.descent;
                this.guidelines.left = 0;
                this.guidelines.right = this.fontData.horizAdvX;
                this.guidelines.baseline = this.fontData.unitsPerEm;
                this.guidelines.custom = [];
                
                // Обновляем UI
                document.getElementById('top-guide').textContent = this.guidelines.top;
                document.getElementById('bottom-guide').textContent = this.guidelines.bottom;
                document.getElementById('left-guide').value = this.guidelines.left;
                document.getElementById('right-guide').value = this.guidelines.right;
                
                this.updateFontInfo();
                this.updateGlyphList();
            }
            
            // Инициализация SVG канваса
            initSVGCanvas() {
    // Создаем обе кнопки один раз
    const toggleCloseBtn = document.createElement('button');
    toggleCloseBtn.id = 'toggle-close';
    toggleCloseBtn.className = 'secondary';
    toggleCloseBtn.innerHTML = '<i class="fas fa-link"></i> Замкнуть';
    toggleCloseBtn.title = 'Замкнуть или разомкнуть текущий контур';
    toggleCloseBtn.style.display = 'none';
    
    const deleteSegmentBtn = document.createElement('button');
    deleteSegmentBtn.id = 'delete-segment-btn';
    deleteSegmentBtn.className = 'secondary';
    deleteSegmentBtn.innerHTML = '<i class="fas fa-trash"></i> Удалить вектор';
    deleteSegmentBtn.title = 'Удалить выделенный вектор';
    deleteSegmentBtn.style.display = 'none';
    
    const toolsDiv = document.querySelector('.floating-tools');
    toolsDiv.appendChild(toggleCloseBtn);
    toolsDiv.appendChild(deleteSegmentBtn);

    // Обработчики для кнопок
    deleteSegmentBtn.addEventListener('click', () => {
        if (this.state.selectedSegment) {
            this.deleteSelectedSegment();
        }
    });
toggleCloseBtn.addEventListener('click', () => {
    // Проверяем ВЫДЕЛЕНА ЛИ ТОЧКА ИЛИ ВЕКТОР (сегмент)
    if (this.state.selectedPoint || this.state.selectedSegment) {
        // Получаем индекс контура
        const contourIndex = this.state.selectedPoint ? 
            this.state.selectedPoint.contourIndex : 
            this.state.selectedSegment.contourIndex;
        
        const contour = this.pathTopology.contours[contourIndex];
        
        if (contour) {
            // Сохраняем состояние перед изменением
            const previousState = {
                fontData: JSON.parse(JSON.stringify(this.fontData)),
                pathTopology: JSON.parse(JSON.stringify(this.pathTopology)),
                currentGlyphUnicode: this.currentGlyph.unicode
            };
            
            // Переключаем флаг
            contour.isClosed = !contour.isClosed;
            
            // Сохраняем в историю
            setTimeout(() => {
                const action = contour.isClosed ? 'close_contour' : 'open_contour';
                const description = contour.isClosed ? 'Замыкание контура' : 'Размыкание контура';
                this.saveToHistoryWithPreviousState(action, description, previousState);
            }, 10);
            
            // Обновляем кнопку
            toggleCloseBtn.innerHTML = contour.isClosed ? 
                '<i class="fas fa-unlink"></i> Разомкнуть' : 
                '<i class="fas fa-link"></i> Замкнуть';
            
            // Обновляем путь (Z добавится/удалится)
            this.updatePathFromTopology();
        }
    }
});

                const svgCanvas = document.getElementById('svg-canvas');
                svgCanvas.innerHTML = '';
                
                // Группы для разных элементов
                const groups = ['guideline-group', 'path-group', 'control-group'];
                groups.forEach(groupId => {
                    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                    group.id = groupId;
                    svgCanvas.appendChild(group);
                });
                
                // Обработчики событий
                svgCanvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                svgCanvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                svgCanvas.addEventListener('mouseup', (e) => this.handleCanvasMouseUp(e));
                svgCanvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                svgCanvas.addEventListener('dragstart', (e) => e.preventDefault());
            }
            
            // Инициализация обработчиков событий
            initEventListeners() {
                // Кнопки управления
                document.getElementById('new-font').addEventListener('click', () => this.createNewFont());
                document.getElementById('load-font').addEventListener('click', () => this.loadSVGFont());
                document.getElementById('save-font').addEventListener('click', () => this.saveFont());
                document.getElementById('add-glyph').addEventListener('click', () => this.addNewGlyph());
                document.getElementById('import-underlay').addEventListener('click', () => this.showFontModal());
                document.getElementById('reset-view').addEventListener('click', () => this.resetView());
                document.getElementById('guideline-tool').addEventListener('click', () => this.setTool(TOOLS.GUIDELINE));
 document.getElementById('zoom-scale').addEventListener('input', () => this.setupViewport());
 document.getElementById('debug-tool').addEventListener('click', () => {
    this.showDebugModal();
});
 
				// Инструменты в плавающей панели
				document.getElementById('select-tool').addEventListener('click', () => this.setTool(TOOLS.SELECT));
				document.getElementById('add-point-tool').addEventListener('click', () => this.setTool(TOOLS.ADD_POINT));
				document.getElementById('add-vector-tool').addEventListener('click', () => this.setTool(TOOLS.DELETE));
				
				document.getElementById('rename-font-btn').addEventListener('click', () => this.renameFont());
				document.getElementById('toggle-direction').addEventListener('click', () => this.toggleDirectionDisplay());
				document.getElementById('reverse-contour').addEventListener('click', () => this.reverseContour());
				setTimeout(() => {
					const reverseBtn = document.getElementById('reverse-contour');
					if (reverseBtn && !this.state.showDirection) {
						reverseBtn.disabled = true;
					}
				}, 100);

				// Кнопка "Удалить вектор"
				const deleteSegmentBtn = document.getElementById('delete-segment-btn');
				if (deleteSegmentBtn) {
					deleteSegmentBtn.addEventListener('click', () => {
						if (this.state.selectedSegment) {
							this.deleteSelectedSegment();
						}
					});
				}
                // Свойства глифа
                document.getElementById('glyph-char').addEventListener('input', () => this.updateGlyphFromProperties());
                document.getElementById('glyph-name').addEventListener('input', () => this.updateGlyphFromProperties());
                document.getElementById('horiz-adv').addEventListener('input', () => this.updateGlyphFromProperties());
                document.getElementById('unicode').addEventListener('input', () => this.updateGlyphFromProperties());
                
                // Отражение
                document.getElementById('mirror-horizontal').addEventListener('click', () => this.mirrorHorizontal());
                document.getElementById('mirror-vertical').addEventListener('click', () => this.mirrorVertical());
                
                // Настройки отображения
                document.getElementById('show-underlay').addEventListener('change', () => this.toggleUnderlay());
                document.getElementById('show-controls').addEventListener('change', () => this.toggleControlPoints());
                document.getElementById('show-guidelines').addEventListener('change', () => this.toggleGuidelines());
                
                // Направляющие
                document.getElementById('add-h-guideline').addEventListener('click', () => this.addHorizontalGuideline());
                document.getElementById('add-v-guideline').addEventListener('click', () => this.addVerticalGuideline());
                document.getElementById('clear-guidelines').addEventListener('click', () => this.clearCustomGuidelines());
                
				// Обработчики для верхней направляющей
				document.getElementById('top-guide').addEventListener('change', (e) => {
					const topValue = parseFloat(e.target.value) || 200;

					this.guidelines.top = topValue;
					this.renderGuidelines();
				});

				// Обработчики для нижней направляющей
				document.getElementById('bottom-guide').addEventListener('change', (e) => {
					const bottomValue = parseFloat(e.target.value) || 1200;
					this.guidelines.bottom = bottomValue;
					this.renderGuidelines();
				});

				
                // Базовые направляющие
                document.getElementById('left-guide').addEventListener('change', (e) => {
                    this.guidelines.left = parseFloat(e.target.value) || 0;
                    this.renderGuidelines();
                });
                
                document.getElementById('right-guide').addEventListener('change', (e) => {
                    this.guidelines.right = parseFloat(e.target.value) || 500;
                    this.renderGuidelines();
                });
                
                // Модальное окно
                document.querySelectorAll('.close-modal').forEach(btn => {
                    btn.addEventListener('click', () => {
						this.state.isCreatingTemplate = false;
                        document.getElementById('font-modal').style.display = 'none';
                    });
                });
                
                document.getElementById('load-underlay').addEventListener('click', () => this.loadUnderlayFont());
                document.getElementById('load-from-file').addEventListener('click', () => this.loadUnderlayFromFile());
                // Закрытие модального окна
                document.getElementById('font-modal').addEventListener('click', (e) => {
                    if (e.target === e.currentTarget) {
						this.state.isCreatingTemplate = false;
                        document.getElementById('font-modal').style.display = 'none';
                    }
                });
                
                // Горячие клавиши
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
				
    // SVG шрифт
    document.getElementById('svg-font-input').addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                this.parseSVGFont(event.target.result);
                this.showNotification(`Шрифт "${this.fontData.name}" загружен успешно!`, 'success');
            } catch (error) {
                alert('Ошибка загрузки шрифта: ' + error.message);
            }
        };
        reader.readAsText(file);
    });
				
document.getElementById('underlay-font-input').addEventListener('change', async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const fontName = file.name.replace(/\.[^/.]+$/, "");
    
    // Читаем метрики из файла
    const metrics = await this.readFontMetrics(file);
    
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const fontDataUrl = event.target.result;
            const fontFace = new FontFace(fontName, `url(${fontDataUrl})`);
            
			fontFace.load().then(loadedFont => {
				document.fonts.add(loadedFont);
				this.state.underlayFont = fontName;
				
				// ПОКАЗЫВАЕМ ТОТ ЖЕ ДИАЛОГ ДЛЯ ФАЙЛА
				if (this.state.underlayMetrics) {
					this.showMetricsDialog(this.state.underlayMetrics, fontName);
				} else {
					document.getElementById('font-modal').style.display = 'none';
					this.updateUnderlay();
				}
				
				this.showNotification(
					`Шрифт "${fontName}" загружен из файла`,
					'success'
				);
			}).catch(error => {
                console.error('Ошибка загрузки шрифта:', error);
                alert('Не удалось загрузить шрифт из файла.');
            });
        } catch (error) {
            console.error('Ошибка обработки файла:', error);
            alert('Ошибка при чтении файла шрифта.');
        }
    };
    
    reader.readAsDataURL(file);
});
           }
            
            // ===========================
    // НОВЫЙ МЕТОД: Сохранение состояния в историю
saveToHistory(action, description) {
    // Если мы не в конце истории, удаляем все после текущего индекса
    if (this.history.currentIndex < this.history.actions.length - 1) {
        this.history.actions = this.history.actions.slice(0, this.history.currentIndex + 1);
    }
    
    // Сохраняем полное состояние шрифта И топологии путей
    const state = {
        action,
        description,
        timestamp: Date.now(),
        fontData: JSON.parse(JSON.stringify(this.fontData)),
        pathTopology: JSON.parse(JSON.stringify(this.pathTopology)),
        currentGlyphUnicode: this.currentGlyph ? this.currentGlyph.unicode : null,
        guidelines: JSON.parse(JSON.stringify(this.guidelines))
    };
    
    // Сохраняем информацию о контрольных точках Безье
    if (this.state.draggingPoint && this.state.draggingPoint.isControlPoint) {
        state.controlPointInfo = {
            contourIndex: this.state.draggingPoint.contourIndex,
            segmentIndex: this.state.draggingPoint.segmentIndex,
            isControl1: this.state.draggingPoint.isControl1,
            oldPosition: this.oldControlPosition
        };
    }
    
    // Добавляем в историю
    this.history.actions.push(state);
    
    // Ограничиваем размер истории
    if (this.history.actions.length > this.history.maxHistory) {
        this.history.actions.shift();
    }
    
    // Обновляем индекс
    this.history.currentIndex = this.history.actions.length - 1;
    
    console.log(`Сохранено в историю: ${description} (всего: ${this.history.actions.length})`);
}
   
    // НОВЫЙ МЕТОД: Отмена последнего действия
undo() {
    if (this.history.currentIndex <= 0) {
        console.log("Нет действий для отмены");
        this.showNotification("Нет действий для отмены", "info");
        return;
    }
    
    // Получаем текущее состояние (перед отменой)
    const currentState = this.history.actions[this.history.currentIndex];
    
    // Перемещаемся назад в истории
    this.history.currentIndex--;
    const previousState = this.history.actions[this.history.currentIndex];
    
    // Если у текущего состояния есть previousState, используем его для точной отмены
    let restoreState = previousState;
    if (currentState.previousState) {
        console.log("Используем сохраненное предыдущее состояние для точной отмены");
        restoreState = currentState.previousState;
    }
    
    // Восстанавливаем состояние из restoreState
    this.fontData = JSON.parse(JSON.stringify(restoreState.fontData));
    
    // Восстанавливаем топологию путей
    if (restoreState.pathTopology) {
        this.pathTopology = JSON.parse(JSON.stringify(restoreState.pathTopology));
    }
    
    // Восстанавливаем направляющие
    if (restoreState.guidelines) {
        this.guidelines = JSON.parse(JSON.stringify(restoreState.guidelines));
        this.updateGuidelineControls();
    }
    
    // Восстанавливаем текущий глиф
    if (restoreState.currentGlyphUnicode) {
        this.currentGlyph = this.fontData.glyphs.find(
            g => g.unicode === restoreState.currentGlyphUnicode
        );
    }
    
    // Обновляем интерфейс
    this.updateFontInfo();
    this.updateGlyphList();
    this.updatePropertiesPanel();
    
    if (this.currentGlyph) {
        // Очищаем и перерисовываем глиф
        this.clearCanvas();
        this.renderGlyph();
        
        // Перерисовываем все элементы
        setTimeout(() => {
            this.renderAllControlElements();
            if (this.state.showDirection) {
                this.showContourDirections();
            }
        }, 0);
    } else {
        // Если нет текущего глифа
        document.getElementById('no-glyph').style.display = 'block';
        document.getElementById('svg-canvas').style.display = 'none';
    }
    
    // Обновляем направляющие
    this.renderGuidelines();
    
    console.log(`Отменено: ${currentState.description}`);
    this.showNotification(`Отменено: ${currentState.description}`, "info");
}

            // ОБНОВЛЕНИЕ ИНТЕРФЕЙСА

            updateFontInfo() {
                document.getElementById('font-name').textContent = this.fontData.name;
                document.getElementById('glyph-count').textContent = this.fontData.glyphs.length;
                document.getElementById('units-per-em').textContent = this.fontData.unitsPerEm;
            }
            
updateGlyphList() {
    const glyphList = document.getElementById('glyph-list');
    glyphList.innerHTML = '';
    
    const sortedGlyphs = [...this.fontData.glyphs].sort((a, b) => {
        if (a.unicode === ' ') return -1;
        if (b.unicode === ' ') return 1;
        if (!a.unicode) return 1;
        if (!b.unicode) return -1;
        return a.unicode.charCodeAt(0) - b.unicode.charCodeAt(0);
    });
    
    sortedGlyphs.forEach((glyph, index) => {
        const originalIndex = this.fontData.glyphs.indexOf(glyph);
        const glyphItem = document.createElement('div');
        glyphItem.className = 'glyph-item';
        
        // ДОБАВЛЯЕМ: проверяем, есть ли у глифа векторы (path data)
        const isEmptyGlyph = !glyph.d || glyph.d.trim() === '';
        if (isEmptyGlyph) {
            glyphItem.classList.add('empty-glyph');
        }
        
        // ИСПРАВЛЕНИЕ: проверяем выбран ли этот глиф
        if (this.currentGlyph && this.currentGlyph.unicode === glyph.unicode) {
            glyphItem.classList.add('active');
        }
        
        glyphItem.innerHTML = `
            <div class="glyph-info">
                <div class="glyph-char">${glyph.unicode || ' '}</div>
                <div class="glyph-name">${glyph.name}</div>
                ${isEmptyGlyph ? '<div class="glyph-status">(пустой)</div>' : ''}
            </div>
            <div class="glyph-actions">
                <button title="Удалить"><i class="fas fa-trash"></i></button>
            </div>
        `;
        
        glyphItem.addEventListener('click', (e) => {
            if (!e.target.closest('button')) {
                this.selectGlyph(glyph);
            }
        });
        
        const deleteBtn = glyphItem.querySelector('button');
        deleteBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            this.deleteGlyph(originalIndex);
        });
        
        glyphList.appendChild(glyphItem);
    });
}

// Метод для нахождения правильной позиции вставки
findInsertIndex(unicodeChar) {
    if (unicodeChar === ' ') return 0; // Пробел всегда первый
    
    const charCode = unicodeChar.charCodeAt(0);
    
    for (let i = 0; i < this.fontData.glyphs.length; i++) {
        const glyph = this.fontData.glyphs[i];
        
        if (glyph.unicode === ' ') continue; // Пропускаем пробел
        
        if (!glyph.unicode) return i; // Без unicode - вставляем перед
        
        if (charCode < glyph.unicode.charCodeAt(0)) {
            return i;
        }
    }
    
    return this.fontData.glyphs.length; // В конец
}            
            updatePropertiesPanel() {
                if (!this.currentGlyph) return;
                
                document.getElementById('glyph-char').value = this.currentGlyph.unicode || '';
                document.getElementById('glyph-name').value = this.currentGlyph.name || '';
                document.getElementById('horiz-adv').value = this.currentGlyph.horizAdvX || this.fontData.horizAdvX;
                
                const unicode = this.currentGlyph.unicode ? 
                    `U+${this.currentGlyph.unicode.charCodeAt(0).toString(16).toUpperCase().padStart(4, '0')}` : '';
                document.getElementById('unicode').value = unicode;
            }
            
			updateGuidelineControls() {
				document.getElementById('top-guide').value = Math.round(this.guidelines.top);
				document.getElementById('bottom-guide').value = Math.round(this.guidelines.bottom);
				document.getElementById('left-guide').value = Math.round(this.guidelines.left);
				document.getElementById('right-guide').value = Math.round(this.guidelines.right);
			}
            
            // ========================
            // РАБОТА С ГЛИФАМИ

			// Выбор следующего глифа
			selectNextGlyph() {
				if (!this.currentGlyph || this.fontData.glyphs.length === 0) {
					// Если нет текущего глифа - выбираем первый
					if (this.fontData.glyphs.length > 0) {
						this.selectGlyph(this.fontData.glyphs[0]);
					}
					return;
				}
				
				const currentIndex = this.fontData.glyphs.findIndex(g => g === this.currentGlyph);
				if (currentIndex === -1) return;
				
				const nextIndex = (currentIndex + 1) % this.fontData.glyphs.length;
				this.selectGlyph(this.fontData.glyphs[nextIndex]);
			}

			// Выбор предыдущего глифа
			selectPreviousGlyph() {
				if (!this.currentGlyph || this.fontData.glyphs.length === 0) {
					// Если нет текущего глифа - выбираем последний
					if (this.fontData.glyphs.length > 0) {
						this.selectGlyph(this.fontData.glyphs[this.fontData.glyphs.length - 1]);
					}
					return;
				}
				
				const currentIndex = this.fontData.glyphs.findIndex(g => g === this.currentGlyph);
				if (currentIndex === -1) return;
				
				const prevIndex = (currentIndex - 1 + this.fontData.glyphs.length) % this.fontData.glyphs.length;
				this.selectGlyph(this.fontData.glyphs[prevIndex]);
			}

            selectGlyph(glyph) {
				this.clearAllSelections();
                this.currentGlyph = glyph;
                
                // Обновляем направляющие
                this.guidelines.right = glyph.horizAdvX;
                document.getElementById('right-guide').value = this.guidelines.right;
                
                // Обновляем интерфейс
                this.updateGlyphList();
                this.updatePropertiesPanel();
                
                document.getElementById('current-glyph-name').textContent = glyph.name || glyph.unicode || 'Unnamed';
                document.getElementById('no-glyph').style.display = 'none';
                document.getElementById('svg-canvas').style.display = 'block';
                
                // Рендерим глиф
                this.setupViewport();
                this.renderGlyph();
                
                // Подложка
                if (document.getElementById('show-underlay').checked && this.state.underlayFont) {
                    setTimeout(() => this.createSVGUnderlay(), 20);
                }
            }
            
            updateGlyphFromProperties() {
                if (!this.currentGlyph) return;
                
                const charInput = document.getElementById('glyph-char');
                const nameInput = document.getElementById('glyph-name');
                const horizAdvInput = document.getElementById('horiz-adv');
                
                this.currentGlyph.unicode = charInput.value;
                this.currentGlyph.name = nameInput.value;
                this.currentGlyph.horizAdvX = parseInt(horizAdvInput.value) || this.fontData.horizAdvX;
                
                this.guidelines.right = this.currentGlyph.horizAdvX;
                document.getElementById('right-guide').value = this.guidelines.right;
                
                this.updateGlyphList();
                this.renderGlyph();
                
                if (document.getElementById('show-underlay').checked && this.state.underlayFont) {
                    setTimeout(() => this.createSVGUnderlay(), 100);
                }
            }
            
addNewGlyph() {
    // Создаем модальное окно
    const modalHtml = `
        <div id="new-glyph-modal" class="modal" style="display:flex;">
            <div class="modal-content" style="max-width:400px;">
                <div class="modal-header">
                    <h3><i class="fas fa-plus"></i> Новый глиф</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div style="padding:20px;">
                    <div class="property" style="margin-bottom:15px;">
                        <label for="new-glyph-char">Символ *</label>
                        <input type="text" id="new-glyph-char" maxlength="1" 
                               placeholder="A" value="A" style="width:100%;">
                        <div id="char-error" style="color:#f38ba8;font-size:12px;margin-top:5px;display:none;">
                            Символ обязателен
                        </div>
                    </div>
                    <div class="property" style="margin-bottom:20px;">
                        <label for="new-glyph-name">Имя глифа</label>
                        <input type="text" id="new-glyph-name" 
                               placeholder="A" style="width:100%;">
                    </div>
                    <div style="display:flex;gap:10px;margin-top:20px;">
                        <button id="confirm-new-glyph" style="flex:1;">
                            <i class="fas fa-check"></i> Создать
                        </button>
                        <button class="secondary close-modal" style="flex:1;">
                            Отмена
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Удаляем старую модалку если есть
    const oldModal = document.getElementById('new-glyph-modal');
    if (oldModal) oldModal.remove();
    
    // Добавляем новую
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('new-glyph-modal');
    const charInput = modal.querySelector('#new-glyph-char');
    const nameInput = modal.querySelector('#new-glyph-name');
    const errorDiv = modal.querySelector('#char-error');
    
    // Фокус на поле ввода
    setTimeout(() => {
        charInput.focus();
        charInput.select();
    }, 50);
    
    // Обработчики закрытия
    const closeModal = () => modal.remove();
    
    modal.querySelectorAll('.close-modal').forEach(btn => {
        btn.addEventListener('click', closeModal);
    });
    
    // Обработчик создания
    modal.querySelector('#confirm-new-glyph').addEventListener('click', () => {
        const cher = charInput.value.trim();
        const name = nameInput.value.trim() || cher; // Если имя пустое, используем символ
        
        // Валидация
        if (!cher) {
            errorDiv.style.display = 'block';
            charInput.style.borderColor = '#f38ba8';
            charInput.focus();
            return;
        }
        
        // Проверка существования глифа
        const existingGlyph = this.fontData.glyphs.find(g => g.unicode === cher);
        if (existingGlyph) {
            errorDiv.textContent = 'Глиф с таким символом уже существует!';
            errorDiv.style.display = 'block';
            charInput.style.borderColor = '#f38ba8';
            return;
        }
        
        // Закрываем модалку
        closeModal();
        
        // Создаем новый глиф
        const newGlyph = {
            unicode: cher,
            name: name,
            d: "",
            horizAdvX: this.fontData.horizAdvX
        };
        
        // Находим правильную позицию для вставки
        const insertIndex = this.findInsertIndex(newGlyph.unicode);
        this.fontData.glyphs.splice(insertIndex, 0, newGlyph);
        
        this.updateFontInfo();
        this.updateGlyphList();
        this.selectGlyph(newGlyph);
        
        this.showNotification(`Глиф "${cher}" создан`, 'success');
    });
    
    // Валидация при вводе
    charInput.addEventListener('input', () => {
        errorDiv.style.display = 'none';
        charInput.style.borderColor = '#45475a';
        
        // Автозаполнение имени если пустое
        if (charInput.value.trim() && !nameInput.value.trim()) {
            nameInput.value = charInput.value.trim();
        }
    });
    
    // Обработка нажатия Enter в поле символа
    charInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            modal.querySelector('#confirm-new-glyph').click();
        }
    });
    
    // Обработка нажатия Enter в поле имени
    nameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            modal.querySelector('#confirm-new-glyph').click();
        }
    });
    
    // Закрытие по клику вне окна
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            closeModal();
        }
    });
    
    // Закрытие по Escape
    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', escapeHandler);
        }
    };
    document.addEventListener('keydown', escapeHandler);
}
         
async deleteGlyph(index) {
    const confirmed = await this.showConfirmDialog('Удалить этот глиф?', 'Удаление глифа');
    
    if (!confirmed) {
        return; // Пользователь отказался
    }
                
                const deletedGlyph = this.fontData.glyphs[index];
                this.fontData.glyphs.splice(index, 1);
                
                this.updateFontInfo();
                this.updateGlyphList();
                
                if (this.currentGlyph && this.currentGlyph.unicode === deletedGlyph.unicode) {
                    this.currentGlyph = null;
                    this.clearCanvas();
                    document.getElementById('no-glyph').style.display = 'block';
                    document.getElementById('svg-canvas').style.display = 'none';
                    document.getElementById('current-glyph-name').textContent = 'Выберите глиф';
                }
            }
            
            // ===================
            // РЕНДЕРИНГ

            renderGlyph() {
                if (!this.currentGlyph) return;
                
                this.clearCanvas();
                
                const pathGroup = document.getElementById('path-group');
                const controlGroup = document.getElementById('control-group');
                
                // Направляющие
                if (document.getElementById('show-guidelines').checked) {
                    this.renderGuidelines();
                }
                
                // Путь
                if (this.currentGlyph.d) {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', this.currentGlyph.d);
                    path.setAttribute('class', 'path');
                    pathGroup.appendChild(path);
                }
                
                // Контрольные точки
                if (document.getElementById('show-controls').checked && this.currentGlyph.d) {
                    this.parsePathForControls(this.currentGlyph.d, controlGroup);
                }
                
                // Подложка
                if (document.getElementById('show-underlay').checked && this.state.underlayFont) {
                    setTimeout(() => this.createSVGUnderlay(), 0);
                }
                
                // Инициализируем топологию
                this.initPathTopology();
            }
            
            clearCanvas() {
                const groups = ['path-group', 'control-group', 'guideline-group'];
                groups.forEach(groupId => {
                    const group = document.getElementById(groupId);
                    if (group) group.innerHTML = '';
                });
            }
            
            initPathTopology() {
                this.pathTopology.contours = [];
                
                if (!this.currentGlyph || !this.currentGlyph.d) return;
                
                const controlGroup = document.getElementById('control-group');
                if (!controlGroup) return;
                
                controlGroup.innerHTML = '';
                
                // Парсим путь на контуры
                const contours = this.extractContoursFromPath(this.currentGlyph.d);
                
                contours.forEach((svgContour, contourIndex) => {
                    const contourTopology = {
                        points: [],
                        segments: [],
                        isClosed: svgContour.isClosed
                    };
                    
                    // Создаем точки
                    svgContour.points.forEach((svgPoint, pointIndex) => {
                        const pointElement = this.createControlPoint(svgPoint.x, svgPoint.y, 'point', controlGroup);
                        
                        pointElement.setAttribute('data-contour-index', contourIndex);
                        pointElement.setAttribute('data-point-index', pointIndex);
                        
                        contourTopology.points.push({
                            element: pointElement,
                            index: pointIndex,
                            contourIndex: contourIndex,
                            x: svgPoint.x,
                            y: svgPoint.y,
                            isBezier: svgPoint.isBezier
                        });
                    });
                    
                    // Создаем сегменты
                    svgContour.segments.forEach((svgSegment, segmentIndex) => {
                        const startPoint = contourTopology.points[svgSegment.startIndex];
                        const endPoint = contourTopology.points[svgSegment.endIndex];
                        
                        if (startPoint && endPoint) {
                            const segment = {
                                startIndex: svgSegment.startIndex,
                                endIndex: svgSegment.endIndex,
                                type: svgSegment.type,
                                control1: svgSegment.control1,
                                control2: svgSegment.control2
                            };
                            
                            contourTopology.segments.push(segment);
                            
                            // Контрольные точки для кривых Безье
                            if (svgSegment.type === 'bezier' && svgSegment.control1 && svgSegment.control2) {
                                const cp1 = this.createControlPoint(svgSegment.control1.x, svgSegment.control1.y, 'control-point', controlGroup);
                                const cp2 = this.createControlPoint(svgSegment.control2.x, svgSegment.control2.y, 'control-point', controlGroup);
                                
                                cp1.setAttribute('data-contour-index', contourIndex);
                                cp1.setAttribute('data-segment-index', segmentIndex);
                                cp1.setAttribute('data-is-control1', 'true');
                                
                                cp2.setAttribute('data-contour-index', contourIndex);
                                cp2.setAttribute('data-segment-index', segmentIndex);
                                cp2.setAttribute('data-is-control2', 'true');
                                
                                this.createControlLine(startPoint.x, startPoint.y, svgSegment.control1.x, svgSegment.control1.y, controlGroup);
                                this.createControlLine(endPoint.x, endPoint.y, svgSegment.control2.x, svgSegment.control2.y, controlGroup);
                            }
                        }
                    });
                    
                    // Определяем типы точек
                    this.updatePointTypesInContour(contourTopology);
                    
                    this.pathTopology.contours.push(contourTopology);
                });
                
                // Скрываем контрольные точки если нужно
                if (!document.getElementById('show-controls').checked) {
                    controlGroup.querySelectorAll('.control-point, .control-line').forEach(el => {
                        el.style.display = 'none';
                    });
                }
            }
            
            // ======================
            // РАБОТА С ПУТЕМ
			
			// Показать/скрыть направление контура
toggleDirectionDisplay() {
    const showDirection = !this.state.showDirection;
    this.state.showDirection = showDirection;
    
    const btn = document.getElementById('toggle-direction');
    const reverseBtn = document.getElementById('reverse-contour');
    
    if (btn) {
        btn.classList.toggle('active', showDirection);
        // Меняем иконку
        //btn.innerHTML = showDirection ? 
           // '<i class="fas fa-eye"></i> Направление' : 
          //  '<i class="fas fa-eye-slash"></i> Направление';
    }
    
    if (reverseBtn) {
        // ДЕЛАЕМ КНОПКУ НЕАКТИВНОЙ когда направление выключено
        reverseBtn.disabled = !showDirection;
        
        // Меняем стиль неактивной кнопки
        if (showDirection) {
            reverseBtn.style.opacity = '1';
            reverseBtn.style.cursor = 'pointer';
            reverseBtn.title = 'Развернуть выделенный контур';
        } else {
            reverseBtn.style.opacity = '0.5';
            reverseBtn.style.cursor = 'not-allowed';
            reverseBtn.title = 'Включите показ направления для разворота';
        }
    }
    
    if (showDirection) {
        this.showContourDirections();
    } else {
        this.hideContourDirections();
    }
}


			// Показать стрелки направления для всех контуров
			showContourDirections() {
				this.hideContourDirections(); // Сначала очистим старые
				
				// Если режим направления выключен - выходим
				if (!this.state.showDirection) return;
				
				
				const pathGroup = document.getElementById('path-group');
				if (!pathGroup) return;
				
				this.pathTopology.contours.forEach((contour, contourIndex) => {
					if (!contour.segments || contour.segments.length === 0) return;
					
					// Для каждого сегмента показываем стрелку в середине
					contour.segments.forEach((segment, segmentIndex) => {
						const startPoint = contour.points[segment.startIndex];
						const endPoint = contour.points[segment.endIndex];
						
						if (!startPoint || !endPoint) return;
						
						// Вычисляем середину сегмента
						let midX, midY;
						
						if (segment.type === 'line') {
							midX = (startPoint.x + endPoint.x) / 2;
							midY = (startPoint.y + endPoint.y) / 2;
						} else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
							// Для кривой Безье берем точку при t=0.5
							const t = 0.5;
							const point = this.getPointOnBezier(t, 
								startPoint.x, startPoint.y,
								segment.control1.x, segment.control1.y,
								segment.control2.x, segment.control2.y,
								endPoint.x, endPoint.y
							);
							midX = point.x;
							midY = point.y;
						} else {
							midX = (startPoint.x + endPoint.x) / 2;
							midY = (startPoint.y + endPoint.y) / 2;
						}
						
						// Вычисляем угол направления
						const dx = endPoint.x - startPoint.x;
						const dy = endPoint.y - startPoint.y;
						const angle = Math.atan2(dy, dx);
						
						// Создаем стрелку направления
						const arrow = this.createDirectionArrow(midX, midY, angle, contourIndex, segmentIndex, pathGroup);
						if (arrow) {
							if (!this.state.directionArrows) this.state.directionArrows = [];
							this.state.directionArrows.push(arrow);
						}
					});
				});
			}

			// Создать стрелку направления
createDirectionArrow(x, y, angle, contourIndex, segmentIndex, container) {
    const svgNS = "http://www.w3.org/2000/svg";
    
    // Группа для стрелки с трансформацией поворота
    const group = document.createElementNS(svgNS, 'g');
    group.setAttribute('class', 'direction-arrow');
    group.setAttribute('data-contour-index', contourIndex);
    group.setAttribute('data-segment-index', segmentIndex);
    
    // Трансформация: перемещаем в точку (x,y) и поворачиваем на угол
    group.setAttribute('transform', `translate(${x}, ${y}) rotate(${angle * 180 / Math.PI})`);
    
    // Стрелка (треугольник)
    const arrow = document.createElementNS(svgNS, 'path');
    const size = 8; // Размер стрелки
    
    // Стрелка направлена вправо (после поворота будет смотреть по направлению сегмента)
    arrow.setAttribute('d', `M 0 -${size/2} L ${size} 0 L 0 ${size/2} Z`);
    arrow.setAttribute('fill', '#a6e3a1'); // Зеленый цвет
    arrow.setAttribute('stroke', '#1e1e2e');
    arrow.setAttribute('stroke-width', '1');
    arrow.setAttribute('opacity', '0.8');
    
    // Круг в центре (необязательно)
    const circle = document.createElementNS(svgNS, 'circle');
    circle.setAttribute('cx', 0);
    circle.setAttribute('cy', 0);
    circle.setAttribute('r', '2');
    circle.setAttribute('fill', '#f38ba8'); // Розовый
    circle.setAttribute('opacity', '0.6');
    
    group.appendChild(arrow);
    group.appendChild(circle);
    container.appendChild(group);
    
    return group;
}

			// Скрыть стрелки направления
			hideContourDirections() {
				if (this.state.directionArrows) {
					this.state.directionArrows.forEach(arrow => {
						if (arrow && arrow.parentNode) {
							arrow.parentNode.removeChild(arrow);
						}
					});
					this.state.directionArrows = [];
				}
			}

			// Развернуть весь контур (вектор целиком)
			reverseContour() {
				// РАБОТАЕТ ТОЛЬКО ЕСЛИ ВКЛЮЧЕНО ПОКАЗАНИЕ НАПРАВЛЕНИЯ
				if (!this.state.showDirection) {
					this.showNotification('Включите показ направления (кнопка "Направление") перед разворотом контура', 'warning');
					return;
				}
				
				// Определяем, какой контур разворачивать
				let contourIndex = -1;
				
				if (this.state.selectedSegment) {
					contourIndex = this.state.selectedSegment.contourIndex;
				} else if (this.state.selectedPoint) {
					contourIndex = this.state.selectedPoint.contourIndex;
				}
				
				if (contourIndex === -1) {
					alert('Выделите точку или сегмент контура для разворота');
					return;
				}
				
				const contour = this.pathTopology.contours[contourIndex];
				if (!contour) return;
				
				// Разворачиваем контур
				this.reverseContourData(contour.points, contour.segments);
				
				// Обновляем индексы точек
				contour.points.forEach((point, index) => {
					point.index = index;
				});
				
				// Обновляем визуализацию
				this.updateEverything();
				
			}
			
            extractContoursFromPath(pathData) {
                if (!pathData) return [];
                
                const contours = [];
                const commands = this.parsePathCommands(pathData);
                
                let currentContour = null;
                let currentPosition = {x: 0, y: 0};
                let contourStartPoint = null;
                
                for (let i = 0; i < commands.length; i++) {
                    const cmd = commands[i];
                    
                    if (cmd.type === 'M' || cmd.type === 'm') {
                        // Новый контур
                        if (currentContour) {
                            contours.push(currentContour);
                        }
                        
                        const point = cmd.type === 'M' ? 
                            {x: cmd.values[0], y: cmd.values[1]} :
                            {x: currentPosition.x + cmd.values[0], y: currentPosition.y + cmd.values[1]};
                        
                        currentContour = {
                            points: [{
                                x: point.x,
                                y: point.y,
                                isBezier: false,
                                command: 'M'
                            }],
                            segments: [],
                            isClosed: false
                        };
                        
                        contourStartPoint = {...point};
                        currentPosition = {...point};
                    }
                    else if (cmd.type === 'L' || cmd.type === 'l') {
                        if (!currentContour) continue;
                        
                        const point = cmd.type === 'L' ?
                            {x: cmd.values[0], y: cmd.values[1]} :
                            {x: currentPosition.x + cmd.values[0], y: currentPosition.y + cmd.values[1]};
                        
                        const pointIndex = currentContour.points.length;
                        currentContour.points.push({
                            x: point.x,
                            y: point.y,
                            isBezier: false,
                            command: 'L'
                        });
                        
                        // Добавляем сегмент
                        currentContour.segments.push({
                            startIndex: pointIndex - 1,
                            endIndex: pointIndex,
                            type: 'line',
                            control1: null,
                            control2: null
                        });
                        
                        currentPosition = {...point};
                    }
                    else if (cmd.type === 'C' || cmd.type === 'c') {
                        if (!currentContour) continue;
                        
                        const endPoint = cmd.type === 'C' ?
                            {x: cmd.values[4], y: cmd.values[5]} :
                            {x: currentPosition.x + cmd.values[4], y: currentPosition.y + cmd.values[5]};
                        
                        const control1 = cmd.type === 'C' ?
                            {x: cmd.values[0], y: cmd.values[1]} :
                            {x: currentPosition.x + cmd.values[0], y: currentPosition.y + cmd.values[1]};
                        
                        const control2 = cmd.type === 'C' ?
                            {x: cmd.values[2], y: cmd.values[3]} :
                            {x: currentPosition.x + cmd.values[2], y: currentPosition.y + cmd.values[3]};
                        
                        const pointIndex = currentContour.points.length;
                        currentContour.points.push({
                            x: endPoint.x,
                            y: endPoint.y,
                            isBezier: true,
                            bezierData: {
                                control1: control1,
                                control2: control2,
                                startPoint: {...currentPosition}
                            },
                            command: 'C'
                        });
                        
                        // Добавляем сегмент кривой Безье
                        currentContour.segments.push({
                            startIndex: pointIndex - 1,
                            endIndex: pointIndex,
                            type: 'bezier',
                            control1: control1,
                            control2: control2
                        });
                        
                        currentPosition = {...endPoint};
                    }
                    else if (cmd.type === 'Z' || cmd.type === 'z') {
                        if (!currentContour || !contourStartPoint) continue;
                        
                        // Замыкаем контур
                        const startIndex = 0;
                        const endIndex = currentContour.points.length - 1;
                        
                        currentContour.segments.push({
                            startIndex: endIndex,
                            endIndex: startIndex,
                            type: 'line',
                            control1: null,
                            control2: null
                        });
                        
                        currentContour.isClosed = true;
                        currentPosition = {...contourStartPoint};
                    }
                }
                
                // Добавляем последний контур
                if (currentContour) {
                    contours.push(currentContour);
                }
                
                return contours;
            }
            
            parsePathCommands(pathData) {
                if (!pathData) return [];
                
                const commands = [];
                const commandRegex = /([MmLlCcZz])([^MmLlCcZz]*)/g;
                let match;
                
                while ((match = commandRegex.exec(pathData)) !== null) {
                    const type = match[1];
                    const valuesStr = match[2].trim();
                    const values = valuesStr ? valuesStr.split(/[\s,]+/).map(parseFloat) : [];
                    
                    commands.push({
                        type: type,
                        values: values
                    });
                }
                
                return commands;
            }
            
            parsePathForControls(pathData, controlGroup) {
                controlGroup.querySelectorAll('.point, .control-point, .control-line').forEach(el => el.remove());
                
                const contours = this.extractContoursFromPath(pathData);
                
                contours.forEach((contour, contourIndex) => {
                    contour.points.forEach((svgPoint, pointIndex) => {
                        const point = this.createControlPoint(svgPoint.x, svgPoint.y, 'point', controlGroup);
                        point.setAttribute('data-contour-index', contourIndex);
                        point.setAttribute('data-point-index', pointIndex);
                    });
                });
            }
            
updatePathFromTopology() {
    if (!this.currentGlyph) return;
    let pathData = '';
    
    this.pathTopology.contours.forEach(contour => {
        if (!contour.segments || contour.segments.length === 0) return;

        const sortedSegments = [...contour.segments].sort((a, b) => a.startIndex - b.startIndex);
        
        let contourPath = '';
        let lastEndIndex = -1;
        
        sortedSegments.forEach((segment, idx) => {
            const startPoint = contour.points[segment.startIndex];
            const endPoint = contour.points[segment.endIndex];
            
            if (!startPoint || !endPoint) return;

            if (idx === 0 || segment.startIndex !== lastEndIndex) {
                contourPath += `M ${startPoint.x} ${startPoint.y} `;
            }
            
            if (segment.type === 'line') {
                contourPath += `L ${endPoint.x} ${endPoint.y} `;
            } 
            else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
                contourPath += `C ${segment.control1.x} ${segment.control1.y} `;
                contourPath += `${segment.control2.x} ${segment.control2.y} `;
                contourPath += `${endPoint.x} ${endPoint.y} `;
            }
            else {

                contourPath += `L ${endPoint.x} ${endPoint.y} `;
            }
            
            lastEndIndex = segment.endIndex;
        });
        
        if (contour.isClosed && contour.points.length > 0) {
            contourPath += 'Z ';
        }
        
        pathData += contourPath;
    });

    this.currentGlyph.d = pathData.trim();
    
    const pathGroup = document.getElementById('path-group');
    let path = pathGroup.querySelector('path');
    
    if (path) {
        path.setAttribute('d', this.currentGlyph.d || '');
    } else if (this.currentGlyph.d) {
        path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', this.currentGlyph.d);
        path.setAttribute('class', 'path');
        pathGroup.appendChild(path);
    }
    if (this.state.showDirection) {
        setTimeout(() => {
            this.showContourDirections();
        }, 10);
    }
}

			createControlPoint(x, y, type, controlGroup) {
				const svgNS = "http://www.w3.org/2000/svg";
				const point = document.createElementNS(svgNS, 'circle');
				
				const roundedX = Math.round(x * 10) / 10;
				const roundedY = Math.round(y * 10) / 10;
				
    point.setAttribute('cx', Math.round(x * 10) / 10);
    point.setAttribute('cy', Math.round(y * 10) / 10);
    point.setAttribute('r', type === 'point' ? 5 : 4);
    point.setAttribute('class', type);
				
				// Обработчик для перетаскивания
				point.addEventListener('mousedown', (e) => {
					if (this.state.currentTool === TOOLS.SELECT) {
						e.preventDefault();
						e.stopPropagation();
						
						const svgCanvas = document.getElementById('svg-canvas');
						const cursorPt = this.getSVGCoordinates(e, svgCanvas);
						this.startPointDrag(point, cursorPt.x, cursorPt.y);
					}
				});
				
				// Обработчик для выделения/снятия выделения
				/*point.addEventListener('click', (e) => {
					// ТОЛЬКО для инструмента добавления точек и ТОЛЬКО для основных точек
					if (this.state.currentTool === TOOLS.ADD_POINT && point.classList.contains('point')) {
						e.preventDefault();
						e.stopPropagation();
						this.togglePointSelection(point);
					}
					
					// Дополнительно: для инструмента выбора тоже можно выделять
					if (this.state.currentTool === TOOLS.SELECT && point.classList.contains('point')) {
						e.preventDefault();
						e.stopPropagation();
						this.togglePointSelection(point);
					}
				});*/
				
				// Двойной клик - изменение типа сегмента
				point.addEventListener('dblclick', (e) => {
					e.preventDefault();
					e.stopPropagation();
					
					if (this.state.currentTool === TOOLS.SELECT && point.classList.contains('point')) {
						this.handlePointDoubleClick(point);
					}
				});
				
				point.addEventListener('mouseenter', () => {
					if (this.state.currentTool === TOOLS.SELECT) {
						point.style.cursor = 'move';
					} else if (this.state.currentTool === TOOLS.ADD_POINT && point.classList.contains('point')) {
						point.style.cursor = 'pointer';
					}
				});
				
				point.addEventListener('mouseleave', () => {
					point.style.cursor = '';
				});
				
				controlGroup.appendChild(point);
				return point;
			}
			
handlePointDoubleClick(pointElement) {
    const contourIndex = parseInt(pointElement.getAttribute('data-contour-index') || '0');
    const pointIndex = parseInt(pointElement.getAttribute('data-point-index') || '0');
    
    if (contourIndex === -1 || pointIndex === -1) return;
    
    const contour = this.pathTopology.contours[contourIndex];
    if (!contour) return;
    
    // Находим ВСЕ сегменты, связанные с этой точкой
    const connectedSegments = this.findConnectedSegmentsInContour(contour, pointIndex);
    if (connectedSegments.length === 0) return;
    
    // ПРОВЕРКА НА КРАЙНЮЮ ТОЧКУ (data-point-type="end" или "isolated")
    const pointType = pointElement.getAttribute('data-point-type');
    const isEndPoint = pointType === 'end' || pointType === 'isolated';
    
    // ЕСЛИ КРАЙНЯЯ ТОЧКА - ПОЛНАЯ ОТМЕНА ДЕЙСТВИЯ
    if (isEndPoint) {
        console.log('Двойной клик на крайней точке - отмена всех действий');
        return;
    }
    
    // Сохраняем в историю перед изменением
    const action = connectedSegments[0].segment.type === 'bezier' 
        ? 'convert_bezier_to_line' 
        : 'convert_line_to_bezier';
    const description = connectedSegments[0].segment.type === 'bezier'
        ? 'Преобразование кривой в линию'
        : 'Преобразование линии в кривую';
    
    this.saveToHistory(action, description);
    
    // Дальше только для СРЕДНИХ точек (point-type="middle")
    
    // Проверяем, все ли уже кривые
    const allAreBezier = connectedSegments.every(seg => seg.segment.type === 'bezier');
    
    if (allAreBezier) {
        // Все кривые → в линии
        connectedSegments.forEach(segmentInfo => {
            this.convertBezierToLineForPoint(contour, segmentInfo.segmentIndex, segmentInfo.segment);
        });
    } else {
        // Превращаем линии в кривые Безье с СИММЕТРИЧНЫМИ контрольными точками
        // Только для средних точек!
        this.convertToSmoothBezier(contour, pointIndex, connectedSegments);
    }
    
    this.updatePathFromTopology();
    this.renderAllControlElements();
    this.updatePointTypesInContour(contour);
}

convertToSmoothBezier(contour, centerPointIndex, connectedSegments) {
    const B = contour.points[centerPointIndex];
    
    // Находим сегменты
    const incoming = connectedSegments.find(s => !s.isStart);
    const outgoing = connectedSegments.find(s => s.isStart);
    
    if (!incoming || !outgoing) return;
    
    const A = contour.points[incoming.otherIndex];
    const C = contour.points[outgoing.otherIndex];
    
    if (!A || !C) return;
    
    // 1. Векторы
    const vecAB = { x: B.x - A.x, y: B.y - A.y }; // от A к B
    const vecBC = { x: C.x - B.x, y: C.y - B.y }; // от B к C
    
    const lenAB = Math.sqrt(vecAB.x**2 + vecAB.y**2);
    const lenBC = Math.sqrt(vecBC.x**2 + vecBC.y**2);
    
    if (lenAB < 0.001 || lenBC < 0.001) return;
    
    // 2. Нормализованные направления
    const dirAB = { x: vecAB.x/lenAB, y: vecAB.y/lenAB };
    const dirBC = { x: vecBC.x/lenBC, y: vecBC.y/lenBC };
    
    // 3. Биссектриса - середина между направлениями
    const bisector = {
        x: -dirAB.x + dirBC.x, // -dirAB потому что dirAB идет К B, а нам нужно ОТ B
        y: -dirAB.y + dirBC.y
    };
    
    const bisectorLen = Math.sqrt(bisector.x**2 + bisector.y**2);
    
    // 4. ПРОВЕРКА: с какой стороны от биссектрисы находятся точки?
    // Используем векторное произведение чтобы определить "левую" и "правую" стороны
    
    
    const normBisector = { x: bisector.x/bisectorLen, y: bisector.y/bisectorLen };
    
    // 5. Определяем положение точки A относительно биссектрисы
    // Вектор от B к A (обратный AB)
    const vecBA = { x: A.x - B.x, y: A.y - B.y };
    
    // Векторное произведение: (bisector) × (BA)
    // Если > 0 - точка A справа от биссектрисы
    // Если < 0 - точка A слева от биссектрисы
    const crossA = normBisector.x * vecBA.y - normBisector.y * vecBA.x;
    
    // 6. Определяем положение точки C относительно биссектрисы  
    const vecBC2 = { x: C.x - B.x, y: C.y - B.y };
    const crossC = normBisector.x * vecBC2.y - normBisector.y * vecBC2.x;
    
    // 7. Контрольные точки должны быть с ТОЙ ЖЕ СТОРОНЫ, что и соответствующая точка

    const controlLen = Math.min(lenAB, lenBC) * 0.39;
    
    // Перпендикуляр к биссектрисе
    const perpRight = { x: -normBisector.y, y: normBisector.x };  // поворот на 90° вправо
    const perpLeft = { x: normBisector.y, y: -normBisector.x };   // поворот на 90° влево
    
    // 8. Создаем контрольные точки
    
    // Для сегмента A→B
    incoming.segment.type = 'bezier';
    
    // Control1 возле A (вдоль направления)
    if (!incoming.segment.control1) {
        incoming.segment.control1 = {
            x: A.x + dirAB.x * controlLen,
            y: A.y + dirAB.y * controlLen
        };
    }
    
    // Control2 возле B - с той же стороны, что и точка A
    incoming.segment.control2 = {
        x: B.x + (crossA > 0 ? perpRight.x : perpLeft.x) * controlLen,
        y: B.y + (crossA > 0 ? perpRight.y : perpLeft.y) * controlLen
    };
    
    // Для сегмента B→C
    outgoing.segment.type = 'bezier';
    
    // Control1 возле B - с той же стороны, что и точка C
    outgoing.segment.control1 = {
        x: B.x + (crossC > 0 ? perpRight.x : perpLeft.x) * controlLen,
        y: B.y + (crossC > 0 ? perpRight.y : perpLeft.y) * controlLen
    };
    
    // Control2 возле C (вдоль направления)
    if (!outgoing.segment.control2) {
        // Направление от C к B (обратное)
        const dirCB = { x: -dirBC.x, y: -dirBC.y };
        outgoing.segment.control2 = {
            x: C.x + dirCB.x * controlLen,
            y: C.y + dirCB.y * controlLen
        };
    }
    
}

handleVectorDoubleClick(contourIndex, segmentIndex) {
    const contour = this.pathTopology.contours[contourIndex];
    if (!contour) return;
    
    const segment = contour.segments[segmentIndex];
    if (!segment) return;
    
    // Сохраняем в историю перед изменением
    const action = segment.type === 'bezier' 
        ? 'convert_vector_bezier_to_line' 
        : 'convert_vector_line_to_bezier';
    const description = segment.type === 'bezier'
        ? 'Преобразование вектора: кривая → линия'
        : 'Преобразование вектора: линия → кривая';
    
    this.saveToHistory(action, description);
    
    // Переключаем тип сегмента
    if (segment.type === 'line') {
        // Преобразуем вектор в кривую Безье с учетом соседей
        this.convertVectorToBezierWithNeighbors(contour, segmentIndex, segment);
    } else if (segment.type === 'bezier') {
        // Преобразуем кривую Безье обратно в линию
        this.convertBezierToLineForSegment(contour, segmentIndex, segment);
    }
    
    // Обновляем визуализацию
    this.updatePathFromTopology();
    this.renderAllControlElements();
    this.updatePointTypesInContour(contour);
    this.clearSegmentSelection();    
    this.updateSegmentButtons();
}

convertBezierToLineForSegment(contour, segmentIndex, segment) {
    // Просто меняем тип и удаляем контрольные точки
    segment.type = 'line';
    segment.control1 = null;
    segment.control2 = null;
    
    // Обновляем информацию о точках
    const startPoint = contour.points[segment.startIndex];
    const endPoint = contour.points[segment.endIndex];
    
    if (startPoint) startPoint.isBezier = false;
    if (endPoint) endPoint.isBezier = false;
    
    // Удаляем визуальные контрольные точки
    this.removeControlPointsForSegment(contour.points[0]?.contourIndex, segmentIndex);
    
}

convertVectorToBezierWithNeighbors(contour, segmentIndex, segment) {
    const startPoint = contour.points[segment.startIndex]; // точка 2
    const endPoint = contour.points[segment.endIndex];     // точка 3
    
    if (!startPoint || !endPoint) return;
    
    // Основное направление вектора 2-3
    const dx = endPoint.x - startPoint.x;
    const dy = endPoint.y - startPoint.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    if (length < 0.001) return;
    
    // Нормализованное направление от 2 к 3
    const nx = dx / length;
    const ny = dy / length;
    
    // Величина изгиба
    const curveAmount = length * 0.39;
    
    let control1DirX = nx;
    let control1DirY = ny;
    let control2DirX = -nx;  // Минус!
    let control2DirY = -ny;  // Минус!
    
    // Для точки 2 (startPoint) - смотрим на предыдущий сегмент (1→2)
    const prevSegment = this.findSegmentEndingAt(contour, segment.startIndex);
    if (prevSegment) {
        if (prevSegment.type === 'bezier' && prevSegment.control2) {
            // Если предыдущий - кривая Безье: берем направление от control2 к точке 2 (ПРОДОЛЖАЕМ)
            const prevDirX = startPoint.x - prevSegment.control2.x;
            const prevDirY = startPoint.y - prevSegment.control2.y;
            const prevLen = Math.sqrt(prevDirX*prevDirX + prevDirY*prevDirY);
            
            if (prevLen > 0.001) {
                control1DirX = prevDirX / prevLen; // ПРОДОЛЖАЕМ
                control1DirY = prevDirY / prevLen;
            }
        } else if (prevSegment.type === 'line') {
            // Если предыдущий - линия: продолжаем её направление
            const point1 = contour.points[prevSegment.startIndex];
            if (point1) {
                const prevDirX = startPoint.x - point1.x;
                const prevDirY = startPoint.y - point1.y;
                const prevLen = Math.sqrt(prevDirX*prevDirX + prevDirY*prevDirY);
                
                if (prevLen > 0.001) {
                    control1DirX = prevDirX / prevLen; // ПРОДОЛЖАЕМ
                    control1DirY = prevDirY / prevLen;
                }
            }
        }
    }
    
    // Для точки 3 (endPoint) - смотрим на следующий сегмент (3→4)
    const nextSegment = this.findSegmentStartingAt(contour, segment.endIndex);
    if (nextSegment) {
        if (nextSegment.type === 'bezier' && nextSegment.control1) {

            const nextDirX = endPoint.x - nextSegment.control1.x;
            const nextDirY = endPoint.y - nextSegment.control1.y;
            const nextLen = Math.sqrt(nextDirX*nextDirX + nextDirY*nextDirY);
            
            if (nextLen > 0.001) {

                control2DirX = nextDirX / nextLen; 
                control2DirY = nextDirY / nextLen; 
            }
        } else if (nextSegment.type === 'line') {
            // Если следующий - линия: продолжаем её направление
            const point4 = contour.points[nextSegment.endIndex];
            if (point4) {
                const nextDirX = point4.x - endPoint.x; // Направление от 3 к 4
                const nextDirY = point4.y - endPoint.y;
                const nextLen = Math.sqrt(nextDirX*nextDirX + nextDirY*nextDirY);
                
                if (nextLen > 0.001) {

                    control2DirX = -nextDirX / nextLen; // ЗЕРКАЛИМ!
                    control2DirY = -nextDirY / nextLen; // ЗЕРКАЛИМ!
                }
            }
        }
    }
    
    // Создаем контрольные точки
    segment.type = 'bezier';
    segment.control1 = {
        x: startPoint.x + control1DirX * curveAmount,
        y: startPoint.y + control1DirY * curveAmount
    };
    segment.control2 = {
        x: endPoint.x + control2DirX * curveAmount,
        y: endPoint.y + control2DirY * curveAmount
    };
    
    // Обновляем информацию о точках
    startPoint.isBezier = true;
    endPoint.isBezier = true;
}

// Вспомогательная функция: найти сегмент, который заканчивается в точке
findSegmentEndingAt(contour, pointIndex) {
    if (!contour.segments) return null;
    return contour.segments.find(seg => seg.endIndex === pointIndex);
}

// Вспомогательная функция: найти сегмент, который начинается в точке
findSegmentStartingAt(contour, pointIndex) {
    if (!contour.segments) return null;
    return contour.segments.find(seg => seg.startIndex === pointIndex);
}

convertBezierToLineForPoint(contour, segmentIndex, segment) {
    
    // Удаляем визуальные контрольные точки
    const controlGroup = document.getElementById('control-group');
    if (controlGroup) {
        const controlPoints = controlGroup.querySelectorAll('.control-point');
        controlPoints.forEach(cp => {
            const cpSegmentIndex = parseInt(cp.getAttribute('data-segment-index'));
            const cpContourIndex = parseInt(cp.getAttribute('data-contour-index'));
            
            if (cpSegmentIndex === segmentIndex && cpContourIndex === contour.points[0]?.contourIndex) {
                // Удаляем связанные линии
                const lines = controlGroup.querySelectorAll('.control-line');
                lines.forEach(line => {
                    const x1 = parseFloat(line.getAttribute('x1'));
                    const y1 = parseFloat(line.getAttribute('y1'));
                    const x2 = parseFloat(line.getAttribute('x2'));
                    const y2 = parseFloat(line.getAttribute('y2'));
                    const cpX = parseFloat(cp.getAttribute('cx'));
                    const cpY = parseFloat(cp.getAttribute('cy'));
                    
                    const dist1 = Math.sqrt(Math.pow(x1 - cpX, 2) + Math.pow(y1 - cpY, 2));
                    const dist2 = Math.sqrt(Math.pow(x2 - cpX, 2) + Math.pow(y2 - cpY, 2));
                    
                    if (dist1 < 5 || dist2 < 5) {
                        line.remove();
                    }
                });
                
                cp.remove();
            }
        });
    }
    
    // Обновляем сегмент
    segment.type = 'line';
    segment.control1 = null;
    segment.control2 = null;
}

createControlLine(x1, y1, x2, y2, controlGroup) {
    const svgNS = "http://www.w3.org/2000/svg";
    const line = document.createElementNS(svgNS, 'line');
    
    // Смещаем начало линии НЕМНОГО от точки
    const OFFSET = 8; // Пиксели от точки
    
    // Вычисляем направление от точки к контрольной точке
    const dx = x2 - x1;
    const dy = y2 - y1;
    const length = Math.sqrt(dx * dx + dy * dy);
    
    let offsetX1 = x1;
    let offsetY1 = y1;
    let offsetX2 = x2;
    let offsetY2 = y2;
    
    if (length > OFFSET * 2) {
        // Сдвигаем от точки (x1, y1)
        const startOffset = OFFSET / length;
        offsetX1 = x1 + dx * startOffset;
        offsetY1 = y1 + dy * startOffset;
        
        // Сдвигаем от контрольной точки (x2, y2)  
        const endOffset = OFFSET / length;
        offsetX2 = x2 - dx * endOffset;
        offsetY2 = y2 - dy * endOffset;
    }
    
    line.setAttribute('x1', Math.round(offsetX1 * 10) / 10);
    line.setAttribute('y1', Math.round(offsetY1 * 10) / 10);
    line.setAttribute('x2', Math.round(offsetX2 * 10) / 10);
    line.setAttribute('y2', Math.round(offsetY2 * 10) / 10);
    line.setAttribute('class', 'control-line');
    
    controlGroup.appendChild(line);
    return line;
}
			
togglePointSelection(pointElement) {
    
    // Если точка уже выделена - снимаем выделение
    if (pointElement.classList.contains('selected')) {
        pointElement.classList.remove('selected');
        this.state.selectedPoint = null;
        
        const toggleCloseBtn = document.getElementById('toggle-close');
        if (toggleCloseBtn) toggleCloseBtn.style.display = 'none';
        return;
    }
    
    // Снимаем выделение со всех других точек
    document.querySelectorAll('.point.selected, .control-point.selected').forEach(point => {
        point.classList.remove('selected');
    });
    
    // Выделяем новую точку
    pointElement.classList.add('selected');
    
    const contourIndex = parseInt(pointElement.getAttribute('data-contour-index') || '-1');
    const pointIndex = parseInt(pointElement.getAttribute('data-point-index') || '-1');
    const pointType = pointElement.getAttribute('data-point-type');
    
    this.state.selectedPoint = {
        element: pointElement,
        x: parseFloat(pointElement.getAttribute('cx')),
        y: parseFloat(pointElement.getAttribute('cy')),
        contourIndex: contourIndex,
        pointIndex: pointIndex,
        pointType: pointType
    };
        
    // Обновляем кнопку замыкания
    const toggleCloseBtn = document.getElementById('toggle-close');
    if (toggleCloseBtn) {
        const contour = this.pathTopology.contours[contourIndex];
        if (contour) {
            toggleCloseBtn.style.display = 'inline-block';
            toggleCloseBtn.innerHTML = contour.isClosed ? 
                '<i class="fas fa-unlink"></i> Разомкнуть' : 
                '<i class="fas fa-link"></i> Замкнуть';
        } else {
            toggleCloseBtn.style.display = 'none';
        }
    }
}
         
startPointDrag(point, startX, startY) {
    const contourIndex = parseInt(point.getAttribute('data-contour-index'));
    const pointIndex = parseInt(point.getAttribute('data-point-index'));
    const isControlPoint = point.classList.contains('control-point');
    
    this.state.draggingPoint = {
        element: point,
        startX: startX,
        startY: startY,
        initialX: parseFloat(point.getAttribute('cx')),
        initialY: parseFloat(point.getAttribute('cy')),
        contourIndex: contourIndex,
        pointIndex: pointIndex,
        isControlPoint: isControlPoint
    };
    
    // Сбрасываем флаги перетаскивания
    this.dragStarted = false;
    this.controlDragStarted = false;
    this.oldControlPosition = null;
    
    if (isControlPoint) {
        this.state.draggingPoint.segmentIndex = parseInt(point.getAttribute('data-segment-index'));
        this.state.draggingPoint.isControl1 = point.getAttribute('data-is-control1') === 'true';
        this.state.draggingPoint.isControl2 = point.getAttribute('data-is-control2') === 'true';
        
        // Запоминаем ВСЕ линии этого сегмента
        this.state.draggingPoint.controlLines = this.findControlLinesForSegment(
            contourIndex, 
            this.state.draggingPoint.segmentIndex
        );
    }
    
    point.classList.add('selected');
    
    // Обработчики для перетаскивания
    const mouseMoveHandler = (e) => {
        if (!this.state.draggingPoint) return;
        
        const svgCanvas = document.getElementById('svg-canvas');
        const cursorPt = this.getSVGCoordinates(e, svgCanvas);
        
        const newX = cursorPt.x;
        const newY = cursorPt.y;
        
        this.state.draggingPoint.element.setAttribute('cx', newX);
        this.state.draggingPoint.element.setAttribute('cy', newY);
        
        if (this.state.draggingPoint.isControlPoint) {
            // Двигаем контрольную точку Безье
            this.handleControlPointDrag(newX, newY);
            
            // Обновляем линии ЭТОГО СЕГМЕНТА
            if (this.state.draggingPoint.controlLines) {
                this.state.draggingPoint.controlLines.forEach(lineInfo => {
                    if (lineInfo.isStart) {
                        lineInfo.element.setAttribute('x1', newX);
                        lineInfo.element.setAttribute('y1', newY);
                    } else if (lineInfo.isEnd) {
                        lineInfo.element.setAttribute('x2', newX);
                        lineInfo.element.setAttribute('y2', newY);
                    }
                });
            }
        } else {
            // Двигаем основную точку
            this.handleMainPointDrag(newX, newY);
        }
        
        this.updatePathFromTopology();
    };
    
    const mouseUpHandler = () => {
        if (this.state.draggingPoint) {
            this.state.draggingPoint.element.classList.remove('selected');
            this.savePathToGlyph();
            
            // Полная перерисовка после завершения
            setTimeout(() => {
                this.renderAllControlElements();
                // ОБНОВЛЯЕМ СТРЕЛКИ если они включены
                if (this.state.showDirection) {
                    this.showContourDirections();
                }
                
                // Сбрасываем флаги после завершения перетаскивания
                this.dragStarted = false;
                this.controlDragStarted = false;
                this.oldControlPosition = null;
            }, 0);
            
            this.state.draggingPoint = null;
        }
        
        document.removeEventListener('mousemove', mouseMoveHandler);
        document.removeEventListener('mouseup', mouseUpHandler);
    };
    
    document.addEventListener('mousemove', mouseMoveHandler);
    document.addEventListener('mouseup', mouseUpHandler);
}
           
			findControlLinesForSegment(contourIndex, segmentIndex) {
				const controlGroup = document.getElementById('control-group');
				const allLines = Array.from(controlGroup.querySelectorAll('.control-line'));
				
				const relatedLines = [];
				
				for (const line of allLines) {
					const lineSegmentIndex = parseInt(line.getAttribute('data-segment-index'));
					const lineContourIndex = parseInt(line.getAttribute('data-contour-index'));
					
					if (lineSegmentIndex === segmentIndex && lineContourIndex === contourIndex) {
						relatedLines.push({
							element: line,
							// Определяем, к какой точке привязана линия
							isStart: this.isLineConnectedToControlPoint(line, true),
							isEnd: this.isLineConnectedToControlPoint(line, false)
						});
					}
				}
				
				return relatedLines;
			}		   

			isLineConnectedToControlPoint(line, checkStart = true) {
				const controlGroup = document.getElementById('control-group');
				const controlPoints = controlGroup.querySelectorAll('.control-point');
				
				const lineX = checkStart ? 
					parseFloat(line.getAttribute('x1')) : 
					parseFloat(line.getAttribute('x2'));
				const lineY = checkStart ? 
					parseFloat(line.getAttribute('y1')) : 
					parseFloat(line.getAttribute('y2'));
				
				for (const cp of controlPoints) {
					const cpX = parseFloat(cp.getAttribute('cx'));
					const cpY = parseFloat(cp.getAttribute('cy'));
					
					const distance = Math.sqrt(Math.pow(lineX - cpX, 2) + Math.pow(lineY - cpY, 2));
					
					if (distance < 5) {
						return true;
					}
				}
				
				return false;
			}

            handleMainPointDrag(newX, newY) {
			
				if (!this.dragStarted) {
					this.saveToHistory('move_point', 'Перемещение точки');
					this.dragStarted = true;
				}
                if (this.state.draggingPoint.contourIndex === -1 || this.state.draggingPoint.pointIndex === -1) return;
                
                const contour = this.pathTopology.contours[this.state.draggingPoint.contourIndex];
                if (!contour) return;
                
                const point = contour.points[this.state.draggingPoint.pointIndex];
                if (!point) return;
                
                const dx = newX - point.x;
                const dy = newY - point.y;
                
                point.x = newX;
                point.y = newY;
                
                // Обновляем связанные контрольные точки
                if (contour.segments) {
                    contour.segments.forEach((segment, segmentIndex) => {
                        if (segment.type === 'bezier') {
                            if (segment.startIndex === this.state.draggingPoint.pointIndex && segment.control1) {
                                segment.control1.x += dx;
                                segment.control1.y += dy;
                            }
                            
                            if (segment.endIndex === this.state.draggingPoint.pointIndex && segment.control2) {
                                segment.control2.x += dx;
                                segment.control2.y += dy;
                            }
                        }
                    });
                }
                
                this.updatePathFromTopology();
                this.renderAllControlElements();
            }
            
handleControlPointDrag(newX, newY) {
    if (this.state.draggingPoint.contourIndex === -1 || 
        this.state.draggingPoint.segmentIndex === -1) return;
    
    const contour = this.pathTopology.contours[this.state.draggingPoint.contourIndex];
    if (!contour) return;
    
    const segment = contour.segments[this.state.draggingPoint.segmentIndex];
    if (!segment || segment.type !== 'bezier') return;
    
    // Если это начало перетаскивания контрольной точки - сохраняем в историю
    if (!this.controlDragStarted) {
        this.saveToHistory('move_control_point', 'Перемещение контрольной точки Безье');
        this.controlDragStarted = true;
    }
    
    // Сохраняем старые координаты для возможной отмены
    if (!this.oldControlPosition) {
        if (this.state.draggingPoint.isControl1 && segment.control1) {
            this.oldControlPosition = {
                x: segment.control1.x,
                y: segment.control1.y
            };
        } else if (this.state.draggingPoint.isControl2 && segment.control2) {
            this.oldControlPosition = {
                x: segment.control2.x,
                y: segment.control2.y
            };
        }
    }
    
    // Обновляем координаты контрольной точки
    if (this.state.draggingPoint.isControl1 && segment.control1) {
        segment.control1.x = newX;
        segment.control1.y = newY;
    } else if (this.state.draggingPoint.isControl2 && segment.control2) {
        segment.control2.x = newX;
        segment.control2.y = newY;
    }
    
    // ВАЖНО: Обновляем контрольные линии СРАЗУ
    const showControls = document.getElementById('show-controls').checked;
    if (showControls) {
        this.updateControlLinesForSegment(contour, this.state.draggingPoint.segmentIndex);
    }
    
    this.updatePathFromTopology();
}
         
updateControlLinesForSegment(contour, segmentIndex) {
    const controlGroup = document.getElementById('control-group');
    const segment = contour.segments[segmentIndex];
    
    if (!segment || segment.type !== 'bezier') return;
    
    const startPoint = contour.points[segment.startIndex];
    const endPoint = contour.points[segment.endIndex];
    
    if (!startPoint || !endPoint) return;
    
    const contourIndex = contour.points[0]?.contourIndex || 0;
    const allLines = Array.from(controlGroup.querySelectorAll('.control-line'));
    
    // 1. Линия от startPoint к control1
    if (segment.control1) {
        // Сначала попробовать найти по data-атрибутам
        let line1 = allLines.find(line => 
            line.getAttribute('data-segment-index') === segmentIndex.toString() &&
            line.getAttribute('data-contour-index') === contourIndex.toString() &&
            line.getAttribute('data-line-type') === 'start-to-cp1'
        );
        
        // Если не нашли по атрибутам - ищем по расстоянию
        if (!line1) {
            line1 = allLines.find(line => {
                const lineX1 = parseFloat(line.getAttribute('x1'));
                const lineY1 = parseFloat(line.getAttribute('y1'));
                const lineX2 = parseFloat(line.getAttribute('x2'));
                const lineY2 = parseFloat(line.getAttribute('y2'));
                
                // Ищем линию, которая начинается у startPoint
                const distToStart = Math.sqrt(
                    Math.pow(lineX1 - startPoint.x, 2) + Math.pow(lineY1 - startPoint.y, 2)
                );
                const distToControl1 = Math.sqrt(
                    Math.pow(lineX2 - segment.control1.x, 2) + Math.pow(lineY2 - segment.control1.y, 2)
                );
                
                return distToStart < 30 && distToControl1 < 30;
            });
        }
        
        if (line1) {
            line1.setAttribute('x1', startPoint.x);
            line1.setAttribute('y1', startPoint.y);
            line1.setAttribute('x2', segment.control1.x);
            line1.setAttribute('y2', segment.control1.y);
            // Обновляем атрибуты
            line1.setAttribute('data-segment-index', segmentIndex.toString());
            line1.setAttribute('data-contour-index', contourIndex.toString());
            line1.setAttribute('data-line-type', 'start-to-cp1');
            
            // Показываем если отображение включено
            line1.style.display = document.getElementById('show-controls').checked ? '' : 'none';
        } else if (document.getElementById('show-controls').checked) {
            // Если не нашли И отображение включено - создаем новую
            const newLine = this.createControlLine(
                startPoint.x, startPoint.y,
                segment.control1.x, segment.control1.y,
                controlGroup
            );
            newLine.setAttribute('data-segment-index', segmentIndex.toString());
            newLine.setAttribute('data-contour-index', contourIndex.toString());
            newLine.setAttribute('data-line-type', 'start-to-cp1');
        }
    }
    
    // 2. Линия от endPoint к control2
    if (segment.control2) {
        // Сначала попробовать найти по data-атрибутам
        let line2 = allLines.find(line => 
            line.getAttribute('data-segment-index') === segmentIndex.toString() &&
            line.getAttribute('data-contour-index') === contourIndex.toString() &&
            line.getAttribute('data-line-type') === 'end-to-cp2'
        );
        
        // Если не нашли по атрибутам - ищем по расстоянию
        if (!line2) {
            line2 = allLines.find(line => {
                const lineX1 = parseFloat(line.getAttribute('x1'));
                const lineY1 = parseFloat(line.getAttribute('y1'));
                const lineX2 = parseFloat(line.getAttribute('x2'));
                const lineY2 = parseFloat(line.getAttribute('y2'));
                
                // Ищем линию, которая начинается у endPoint
                const distToEnd = Math.sqrt(
                    Math.pow(lineX1 - endPoint.x, 2) + Math.pow(lineY1 - endPoint.y, 2)
                );
                const distToControl2 = Math.sqrt(
                    Math.pow(lineX2 - segment.control2.x, 2) + Math.pow(lineY2 - segment.control2.y, 2)
                );
                
                return distToEnd < 30 && distToControl2 < 30;
            });
        }
        
        if (line2) {
            line2.setAttribute('x1', endPoint.x);
            line2.setAttribute('y1', endPoint.y);
            line2.setAttribute('x2', segment.control2.x);
            line2.setAttribute('y2', segment.control2.y);
            // Обновляем атрибуты
            line2.setAttribute('data-segment-index', segmentIndex.toString());
            line2.setAttribute('data-contour-index', contourIndex.toString());
            line2.setAttribute('data-line-type', 'end-to-cp2');
            
            // Показываем если отображение включено
            line2.style.display = document.getElementById('show-controls').checked ? '' : 'none';
        } else if (document.getElementById('show-controls').checked) {
            // Если не нашли И отображение включено - создаем новую
            const newLine = this.createControlLine(
                endPoint.x, endPoint.y,
                segment.control2.x, segment.control2.y,
                controlGroup
            );
            newLine.setAttribute('data-segment-index', segmentIndex.toString());
            newLine.setAttribute('data-contour-index', contourIndex.toString());
            newLine.setAttribute('data-line-type', 'end-to-cp2');
        }
    }
}

// удаление
		   
deletePoint(pointElement) {
    if (!pointElement) return;
    this.saveToHistory('delete_point', 'Удаление точки');
    const contourIndex = parseInt(pointElement.getAttribute('data-contour-index')) || 0;
    const pointIndex = parseInt(pointElement.getAttribute('data-point-index')) || 0;
    const isControlPoint = pointElement.classList.contains('control-point');
    
    const contour = this.pathTopology.contours[contourIndex];
    if (!contour) return;
    
    if (isControlPoint) {
        this.deleteControlPointOnly(contour, pointElement);
        return;
    }
    
    // Находим сегменты
    let segmentBefore = null;
    let segmentAfter = null;
    let segBeforeIdx = -1;
    let segAfterIdx = -1;
    
    for (let i = 0; i < contour.segments.length; i++) {
        const seg = contour.segments[i];
        if (seg.endIndex === pointIndex) {
            segmentBefore = seg;
            segBeforeIdx = i;
        }
        if (seg.startIndex === pointIndex) {
            segmentAfter = seg;
            segAfterIdx = i;
        }
    }
    
    // Удаляем вспомогательные элементы
    if (segmentBefore) this.removeControlPointsForSegment(contourIndex, segBeforeIdx);
    if (segmentAfter) this.removeControlPointsForSegment(contourIndex, segAfterIdx);
    
    // Если средняя точка
    if (segmentBefore && segmentAfter) {
        const pointA = contour.points[segmentBefore.startIndex];
        const pointB = contour.points[segmentAfter.endIndex];
        
        if (!pointA || !pointB) return;
        
        // Координаты удаляемой точки
        const Mx = parseFloat(pointElement.getAttribute('cx'));
        const My = parseFloat(pointElement.getAttribute('cy'));
        
        let newType = 'line';
        let control1 = null;
        let control2 = null;
        
        // ТОЧНОЕ СОХРАНЕНИЕ БЕЗЬЕ
        if (segmentBefore.type === 'bezier' && segmentAfter.type === 'bezier' &&
            segmentBefore.control1 && segmentBefore.control2 &&
            segmentAfter.control1 && segmentAfter.control2) {
            
            newType = 'bezier';
            
            // ПРАВИЛЬНЫЙ РАСЧЕТ: находим параметр t по расстояниям
            // t = расстояние от A до M / расстояние от A до B
            const distAM = Math.sqrt(Math.pow(Mx - pointA.x, 2) + Math.pow(My - pointA.y, 2));
            const distAB = Math.sqrt(Math.pow(pointB.x - pointA.x, 2) + Math.pow(pointB.y - pointA.y, 2));
            
            let t = 0.5;
            if (distAB > 0.001) {
                t = distAM / distAB;
                t = Math.max(0.1, Math.min(0.9, t)); // ограничиваем
            }
            
            // ВОССТАНОВЛЕНИЕ ИСХОДНЫХ КОНТРОЛЬНЫХ ТОЧЕК
            // Формулы де Кастельжо:
            // P1 = A + (C1_before - A) / t
            // P2 = B + (C2_after - B) / (1-t)
            
            const invT = 1 - t;
            
            control1 = {
                x: pointA.x + (segmentBefore.control1.x - pointA.x) / t,
                y: pointA.y + (segmentBefore.control1.y - pointA.y) / t
            };
            
            control2 = {
                x: pointB.x + (segmentAfter.control2.x - pointB.x) / invT,
                y: pointB.y + (segmentAfter.control2.y - pointB.y) / invT
            };
            
            // Проверка на валидность
            if (isNaN(control1.x) || !isFinite(control1.x)) {
                // Если расчет не удался, используем простой метод
                control1 = segmentBefore.control1;
                control2 = segmentAfter.control2;
            }
        }
        // Если только один сегмент был Безье
        else if (segmentBefore.type === 'bezier') {
            newType = 'bezier';
            control1 = segmentBefore.control1;
            // Для второй контрольной точки используем симметрию
            control2 = segmentBefore.control2 ? {
                x: pointB.x + (segmentBefore.control2.x - Mx),
                y: pointB.y + (segmentBefore.control2.y - My)
            } : null;
        }
        else if (segmentAfter.type === 'bezier') {
            newType = 'bezier';
            control2 = segmentAfter.control2;
            // Для первой контрольной точки используем симметрию
            control1 = segmentAfter.control1 ? {
                x: pointA.x + (segmentAfter.control1.x - Mx),
                y: pointA.y + (segmentAfter.control1.y - My)
            } : null;
        }
        
        // Удаляем старые сегменты
        [segBeforeIdx, segAfterIdx].sort((a, b) => b - a).forEach(idx => {
            contour.segments.splice(idx, 1);
        });
        
        // Создаем новый сегмент
        contour.segments.push({
            startIndex: segmentBefore.startIndex,
            endIndex: segmentAfter.endIndex,
            type: newType,
            control1: control1,
            control2: control2
        });
    }
    // Если крайняя точка
    else if (segmentBefore || segmentAfter) {
        const segIdx = segmentBefore ? segBeforeIdx : segAfterIdx;
        contour.segments.splice(segIdx, 1);
    }
    
    // Удаляем точку
    contour.points.splice(pointIndex, 1);
    
    // Переиндексируем
    for (let i = 0; i < contour.points.length; i++) {
        contour.points[i].index = i;
        if (contour.points[i].element) {
            contour.points[i].element.setAttribute('data-point-index', i);
        }
    }
    
    contour.segments.forEach(segment => {
        if (segment.startIndex > pointIndex) segment.startIndex--;
        if (segment.endIndex > pointIndex) segment.endIndex--;
    });
    
    // Удаляем элемент
    pointElement.remove();
    
    // Сбрасываем выделение
    if (this.state.selectedPoint && this.state.selectedPoint.element === pointElement) {
        this.state.selectedPoint = null;
        const toggleCloseBtn = document.getElementById('toggle-close');
        if (toggleCloseBtn) toggleCloseBtn.style.display = 'none';
    }
    
    // Обновляем
    this.updatePointTypesInContour(contour);
    this.updatePathFromTopology();
    
    if (document.getElementById('show-controls').checked) {
        this.renderAllControlElements();
    }
}

            // ====================
            // ИНСТРУМЕНТЫ

			setTool(tool) {
				// Очищаем выделения при смене инструмента
				if (tool !== this.state.currentTool) {
					this.clearAllSelections();
				}
				
				// Очищаем временные элементы при смене инструмента
				if (this.state.currentTool === TOOLS.GUIDELINE && this.state.guidelineCreationStart) {
					this.removeTemporaryGuideline();
					this.state.guidelineCreationStart = null;
				}
				
				if (this.state.currentTool === TOOLS.DELETE && this.state.deleteVectorStart) {
					this.removeDeleteVectorLine();
					this.state.deleteVectorStart = null;
				}
				
				this.state.currentTool = tool;
				
				// Обновляем активные кнопки
				document.getElementById('select-tool').classList.toggle('active', tool === TOOLS.SELECT);
				document.getElementById('add-point-tool').classList.toggle('active', tool === TOOLS.ADD_POINT);
				document.getElementById('add-vector-tool').classList.toggle('active', tool === TOOLS.DELETE);
				document.getElementById('guideline-tool').classList.toggle('active', tool === TOOLS.GUIDELINE);
				
				// Обновляем курсор
				const svgCanvas = document.getElementById('svg-canvas');
				switch(tool) {
					case TOOLS.SELECT:
						svgCanvas.style.cursor = 'default';
						break;
					case TOOLS.ADD_POINT:
						svgCanvas.style.cursor = 'crosshair';
						break;
					case TOOLS.DELETE:
						svgCanvas.style.cursor = 'crosshair';
						break;
					case TOOLS.GUIDELINE:
						svgCanvas.style.cursor = 'cell';
						break;
					default:
						svgCanvas.style.cursor = 'default';
				}
			}
						
            // ==========================
            // ОБРАБОТЧИКИ СОБЫТИЙ

            handleCanvasMouseDown(e) {
                const target = e.target;
                const svgCanvas = document.getElementById('svg-canvas');
                const cursorPt = this.getSVGCoordinates(e, svgCanvas);
                
                // Режим удаления
                if (this.state.currentTool === TOOLS.DELETE && target === svgCanvas) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.state.deleteVectorStart = {
                        x: cursorPt.x,
                        y: cursorPt.y,
                        active: true
                    };
                    
                    this.createDeleteVectorLine(cursorPt.x, cursorPt.y, cursorPt.x, cursorPt.y);
                    
                    const mouseMoveHandler = (e) => {
                        if (!this.state.deleteVectorStart || !this.state.deleteVectorStart.active) return;
                        
                        const currentPt = this.getSVGCoordinates(e, svgCanvas);
                        this.updateDeleteVectorLine(this.state.deleteVectorStart.x, this.state.deleteVectorStart.y, currentPt.x, currentPt.y);
                    };
                    
                    const mouseUpHandler = (e) => {
                        if (!this.state.deleteVectorStart || !this.state.deleteVectorStart.active) return;
                        
                        const endPt = this.getSVGCoordinates(e, svgCanvas);
                        this.deleteIntersectingElements(this.state.deleteVectorStart.x, this.state.deleteVectorStart.y, endPt.x, endPt.y);
                        
                        this.removeDeleteVectorLine();
                        this.state.deleteVectorStart.active = false;
                        this.state.deleteVectorStart = null;
                        
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };
                    
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                    return;
                }
                
                // Удаление точки в режиме удаления
                if (this.state.currentTool === TOOLS.DELETE && 
                    (target.classList.contains('point') || target.classList.contains('control-point'))) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.deletePoint(target);
                    return;
                }
                
                // Выбор точки
                if (this.state.currentTool === TOOLS.SELECT && 
                    (target.classList.contains('point') || target.classList.contains('control-point'))) {
                    e.preventDefault();
                    e.stopPropagation();
                    this.startPointDrag(target, cursorPt.x, cursorPt.y);
                    return;
                }
                
                // Направляющие
                if ((this.state.currentTool === TOOLS.SELECT || this.state.currentTool === TOOLS.GUIDELINE) && 
                    target.classList.contains('guideline') && 
                    (target.classList.contains('custom') || target.classList.contains('draggable'))) {
                    
                    if (e.ctrlKey || e.metaKey) {
                        this.deleteGuideline(target);
                        return;
                    }
                    
                    e.preventDefault();
                    e.stopPropagation();
                    this.startGuidelineDrag(target);
                    return;
                }
                
                // Снятие выделения
                if (this.state.currentTool === TOOLS.SELECT && target === svgCanvas) {
                    this.clearSelection();
                    return;
                }
                
                // Создание направляющей
                if (this.state.currentTool === TOOLS.GUIDELINE && target === svgCanvas) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    this.state.guidelineCreationStart = {
                        x: cursorPt.x,
                        y: cursorPt.y,
                        active: true
                    };
                    
                    this.createTemporaryGuideline(cursorPt.x, cursorPt.y);
                    
                    const mouseMoveHandler = (e) => {
                        if (!this.state.guidelineCreationStart || !this.state.guidelineCreationStart.active) return;
                        
                        const currentPt = this.getSVGCoordinates(e, svgCanvas);
                        this.updateTemporaryGuideline(this.state.guidelineCreationStart.x, this.state.guidelineCreationStart.y, currentPt.x, currentPt.y);
                    };
                    
                    const mouseUpHandler = (e) => {
                        if (!this.state.guidelineCreationStart || !this.state.guidelineCreationStart.active) return;
                        
                        const endPt = this.getSVGCoordinates(e, svgCanvas);
                        const dx = Math.abs(endPt.x - this.state.guidelineCreationStart.x);
                        const dy = Math.abs(endPt.y - this.state.guidelineCreationStart.y);
                        
                        if (dx > dy) {
                            this.addCustomGuideline('horizontal', this.state.guidelineCreationStart.y);
                        } else {
                            this.addCustomGuideline('vertical', this.state.guidelineCreationStart.x);
                        }
                        
                        this.removeTemporaryGuideline();
                        this.state.guidelineCreationStart.active = false;
                        this.state.guidelineCreationStart = null;
                        
                        document.removeEventListener('mousemove', mouseMoveHandler);
                        document.removeEventListener('mouseup', mouseUpHandler);
                    };
                    
                    document.addEventListener('mousemove', mouseMoveHandler);
                    document.addEventListener('mouseup', mouseUpHandler);
                    return;
                }
            }
            
            handleCanvasMouseMove(e) {
                if (this.state.draggingGuideline) {
                    const svgCanvas = document.getElementById('svg-canvas');
                    const cursorPt = this.getSVGCoordinates(e, svgCanvas);
                    this.updateGuidelineDrag(cursorPt.x, cursorPt.y);
                }
            }
            
            handleCanvasMouseUp() {
                if (this.state.draggingGuideline) {
                    this.state.draggingGuideline.element.classList.remove('dragging');
                    this.endGuidelineDrag();
                    this.state.draggingGuideline = null;
                }
            }
						
			handleCanvasClick(e) {
				const target = e.target;
				const svgCanvas = document.getElementById('svg-canvas');
				const cursorPt = this.getSVGCoordinates(e, svgCanvas);

				// Проверяем, был ли это двойной клик
				const isDoubleClick = e.detail === 2;
				
				// ДВОЙНОЙ КЛИК НА ВЕКТОР (в режиме "Изменить")
				if (isDoubleClick && this.state.currentTool === TOOLS.SELECT && target.classList.contains('path')) {
					
					// Получаем координаты клика
					const cursorPt = this.getSVGCoordinates(e, svgCanvas);
					
					// Ищем ближайший сегмент
					const closestSegment = this.findClosestSegment(cursorPt.x, cursorPt.y);
					
					if (closestSegment && closestSegment.distance < 20) {
						e.preventDefault();
						e.stopPropagation();
						this.handleVectorDoubleClick(closestSegment.contourIndex, closestSegment.segmentIndex);
						return;
					}
				}
				// 1. Alt+клик для соединения точек (ПЕРВЫМ делом!)
				if (target.classList.contains('point') && e.altKey) {
					
					if (this.state.selectedPoint && 
						this.state.selectedPoint.element !== target) {
						
						e.preventDefault();
						e.stopPropagation();
						
						const point1Type = this.state.selectedPoint.pointType || 
										  this.state.selectedPoint.element.getAttribute('data-point-type');
						const point2Type = target.getAttribute('data-point-type');
												
						if ((point1Type === 'end' || point1Type === 'isolated') && 
							(point2Type === 'end' || point2Type === 'isolated')) {
							
							// Сохраняем состояние перед соединением
							const previousState = {
								fontData: JSON.parse(JSON.stringify(this.fontData)),
								pathTopology: JSON.parse(JSON.stringify(this.pathTopology)),
								currentGlyphUnicode: this.currentGlyph.unicode
							};
							
							this.createSegmentBetweenPoints(this.state.selectedPoint.element, target);
							
							// Сохраняем в историю ПОСЛЕ соединения
							setTimeout(() => {
								this.saveToHistoryWithPreviousState('connect_points', 'Соединение двух точек', previousState);
							}, 10);
							
							// Снимаем выделение после соединения
							setTimeout(() => {
								this.clearAllSelections();
							}, 50);
							
							return; // Выходим, не делаем выделение
						}
					}
				}
				
				// Клик по сегменту (вектору)
				if (this.state.currentTool === TOOLS.SELECT && target.classList.contains('path')) {
					// Получаем координаты клика
					const cursorPt = this.getSVGCoordinates(e, svgCanvas);
					
					// Ищем ближайший сегмент
					const closestSegment = this.findClosestSegment(cursorPt.x, cursorPt.y);
					
					if (closestSegment && closestSegment.distance < 20) {
					this.clearAllSelections();
						e.preventDefault();
						e.stopPropagation();
						this.handleSegmentClick(e, closestSegment.contourIndex, closestSegment.segmentIndex);
						return;
					}
				}
				
				// Клик по пустому месту - снимаем все выделения
				if (this.state.currentTool === TOOLS.SELECT && target === svgCanvas) {
					this.clearAllSelections();
					return;
				}
				
				// Удаление в режиме delete
				if (this.state.currentTool === TOOLS.DELETE) {
					if (target.classList.contains('point') || target.classList.contains('control-point')) {
						e.preventDefault();
						e.stopPropagation();
						this.deletePoint(target);
						return;
					}
				}
				
				// Ctrl+клик для удаления
				if ((e.ctrlKey || e.metaKey) && this.state.currentTool !== TOOLS.SELECT && this.state.currentTool !== TOOLS.DELETE && 
					(target.classList.contains('point') || target.classList.contains('control-point'))) {
					e.preventDefault();
					e.stopPropagation();
					this.deletePoint(target);
					return;
				}
				
				// Обработка в зависимости от инструмента
				switch(this.state.currentTool) {
					case TOOLS.SELECT:
						if (target.classList.contains('point') || target.classList.contains('control-point')) {
							this.clearAllSelections();
							this.togglePointSelection(target);
						}
						return;
					case TOOLS.ADD_POINT:
						if (target.classList.contains('point')) {
							this.togglePointSelection(target);
						} else if (target.classList.contains('path')) {
							this.addPointToPathAtClick(cursorPt.x, cursorPt.y);
						} else {
							this.addPointAtPosition(cursorPt.x, cursorPt.y);
						}
						return;
				}

			}

			createSegmentBetweenPoints(point1Element, point2Element) {
				
				const contourIndex1 = parseInt(point1Element.getAttribute('data-contour-index') || '-1');
				const pointIndex1 = parseInt(point1Element.getAttribute('data-point-index') || '-1');
				
				const contourIndex2 = parseInt(point2Element.getAttribute('data-contour-index') || '-1');
				const pointIndex2 = parseInt(point2Element.getAttribute('data-point-index') || '-1');
								
				// ВСЕГДА используем mergeTwoContours, даже для одного контура
				// (функция сама разберется)
				this.mergeTwoContours(contourIndex1, pointIndex1, contourIndex2, pointIndex2);
			}

			mergeTwoContours(contourIndex1, pointIndex1, contourIndex2, pointIndex2) {
				
				const contour1 = this.pathTopology.contours[contourIndex1];
				const contour2 = this.pathTopology.contours[contourIndex2];
				
				if (!contour1 || !contour2) return;

				// 1. Определяем направление контура1 относительно точки1
				// Нам нужно чтобы точка1 была КОНЦОМ контура1
				const isPoint1AtEnd = this.isPointAtEndOfChain(contour1, pointIndex1);
				
				// 2. Определяем направление контура2 относительно точки2
				// Нам нужно чтобы точка2 была НАЧАЛОМ контура2
				const isPoint2AtStart = this.isPointAtStartOfChain(contour2, pointIndex2);
				
				// 3. Копируем контуры для манипуляций
				const contour1Copy = {
					points: JSON.parse(JSON.stringify(contour1.points)),
					segments: JSON.parse(JSON.stringify(contour1.segments))
				};
				
				const contour2Copy = {
					points: JSON.parse(JSON.stringify(contour2.points)),
					segments: JSON.parse(JSON.stringify(contour2.segments))
				};
				
				// 4. Если точка1 не в конце - разворачиваем контур1
				let correctedPointIndex1 = pointIndex1;
				if (!isPoint1AtEnd) {
					this.reverseContourData(contour1Copy.points, contour1Copy.segments);
					correctedPointIndex1 = contour1Copy.points.length - 1 - pointIndex1;
				}
				
				// 5. Если точка2 не в начале - разворачиваем контур2
				let correctedPointIndex2 = pointIndex2;
				if (!isPoint2AtStart) {
					this.reverseContourData(contour2Copy.points, contour2Copy.segments);
					correctedPointIndex2 = contour2Copy.points.length - 1 - pointIndex2;
				}
				
				// 6. Создаем новый объединенный контур
				const newContour = {
					points: [],
					segments: [],
					isClosed: false
				};
				
				// 7. Добавляем точки контура1
				contour1Copy.points.forEach((point, idx) => {
					const newPoint = {
						x: point.x,
						y: point.y,
						isBezier: point.isBezier,
						index: newContour.points.length,
						contourIndex: contourIndex1,
						element: null
					};
					newContour.points.push(newPoint);
				});
				
				// 8. Добавляем сегменты контура1
				contour1Copy.segments.forEach(segment => {
					newContour.segments.push({
						type: segment.type,
						control1: segment.control1 ? { ...segment.control1 } : null,
						control2: segment.control2 ? { ...segment.control2 } : null,
						startIndex: segment.startIndex,
						endIndex: segment.endIndex
					});
				});
				
				// 9. Сохраняем индекс, с которого начинается контур2
				const contour2StartIndex = newContour.points.length;
				
				// 10. Добавляем точки контура2
				contour2Copy.points.forEach((point, idx) => {
					const newPoint = {
						x: point.x,
						y: point.y,
						isBezier: point.isBezier,
						index: newContour.points.length,
						contourIndex: contourIndex1,
						element: null
					};
					newContour.points.push(newPoint);
				});
				
				// 11. Добавляем сегменты контура2 с обновленными индексами
				contour2Copy.segments.forEach(segment => {
					newContour.segments.push({
						type: segment.type,
						control1: segment.control1 ? { ...segment.control1 } : null,
						control2: segment.control2 ? { ...segment.control2 } : null,
						startIndex: segment.startIndex + contour2StartIndex,
						endIndex: segment.endIndex + contour2StartIndex
					});
				});
				
				// 12. Добавляем мост-сегмент
				// correctedPointIndex1 - это индекс в конце контура1
				// correctedPointIndex2 + contour2StartIndex - это индекс начала контура2
				const bridgeSegment = {
					startIndex: correctedPointIndex1,
					endIndex: correctedPointIndex2 + contour2StartIndex,
					type: 'line',
					control1: null,
					control2: null
				};
				
				newContour.segments.push(bridgeSegment);
				
				// 13. Заменяем контур1 новым объединенным контуром
				contour1.points = newContour.points;
				contour1.segments = newContour.segments;
				
				// 14. Удаляем контур2
				this.pathTopology.contours.splice(contourIndex2, 1);
				
				// 15. Пересоздаем элементы
				this.recreateAllElementsFromScratch();

				return true;
			}

			isPointAtStartOfChain(contour, pointIndex) {
				if (!contour || !contour.segments) return false;
				
				const connectedSegments = [];
				
				contour.segments.forEach((segment, segIndex) => {
					if (segment.startIndex === pointIndex) {
						connectedSegments.push({ segment, segIndex, isStart: true });
					}
					if (segment.endIndex === pointIndex) {
						connectedSegments.push({ segment, segIndex, isStart: false });
					}
				});
				
				if (connectedSegments.length === 0) return true; // изолированная точка
				
				const isStart = connectedSegments.some(conn => conn.isStart);
				const isEnd = connectedSegments.some(conn => !conn.isStart);
				
				return isStart && !isEnd;
			}

			// Функция: проверяет, является ли точка концом цепочки
			isPointAtEndOfChain(contour, pointIndex) {
				if (!contour || !contour.segments) return false;
				
				// Находим все сегменты, связанные с точкой
				const connectedSegments = [];
				
				contour.segments.forEach((segment, segIndex) => {
					if (segment.startIndex === pointIndex) {
						connectedSegments.push({
							segment: segment,
							segmentIndex: segIndex,
							isStart: true
						});
					}
					if (segment.endIndex === pointIndex) {
						connectedSegments.push({
							segment: segment,
							segmentIndex: segIndex,
							isStart: false
						});
					}
				});
				
				// Если нет соединений - это изолированная точка
				if (connectedSegments.length === 0) return true;
				
				// Если точка является концом (есть сегмент, где она endIndex)
				// но не является началом (нет сегмента, где она startIndex)
				const isStart = connectedSegments.some(conn => conn.isStart);
				const isEnd = connectedSegments.some(conn => !conn.isStart);
				
				return isEnd && !isStart;
			}

			// Новая функция: разворачивает массивы точек и сегментов
			reverseContourData(pointsArray, segmentsArray) {
				// 1. Разворачиваем точки
				pointsArray.reverse();
				
				// 2. Обновляем сегменты
				const totalPoints = pointsArray.length;
				
				segmentsArray.forEach(segment => {
					// Новые индексы после reverse
					const newStart = totalPoints - 1 - segment.endIndex;
					const newEnd = totalPoints - 1 - segment.startIndex;
					segment.startIndex = newStart;
					segment.endIndex = newEnd;
					
					// Для кривых Безье меняем контрольные точки
					if (segment.type === 'bezier') {
						[segment.control1, segment.control2] = [segment.control2, segment.control1];
					}
				});
				
				// 3. Разворачиваем порядок сегментов в массиве
				segmentsArray.reverse();
			}

			// Новая функция: пересоздает все элементы с нуля
			recreateAllElementsFromScratch() {
				
				// 1. Очищаем control-group
				const controlGroup = document.getElementById('control-group');
				if (controlGroup) {
					controlGroup.innerHTML = '';
				}
				
				// 2. Создаем все точки заново
				this.pathTopology.contours.forEach((contour, contourIndex) => {
					contour.points.forEach((point, pointIndex) => {
						// Удаляем старую ссылку
						point.element = null;
						
						// Создаем новый элемент
						const pointElement = this.createControlPoint(point.x, point.y, 'point', controlGroup);
						pointElement.setAttribute('data-contour-index', contourIndex);
						pointElement.setAttribute('data-point-index', pointIndex);
						
						// Сохраняем ссылку
						point.element = pointElement;
						point.index = pointIndex;
						point.contourIndex = contourIndex;
					});
				});
				
				// 3. Обновляем все
				this.updateEverything();
			}

			updateEverything() {
				// 1. Обновляем путь
				this.updatePathFromTopology();
				
				// 2. Обновляем типы точек
				this.updateAllPointTypes();
				
				// 3. Перерисовываем контрольные элементы
				if (document.getElementById('show-controls').checked) {
					this.renderAllControlElements();
				}

				// 4. ОБНОВЛЯЕМ СТРЕЛКИ НАПРАВЛЕНИЯ если они включены
				if (this.state.showDirection) {
					this.showContourDirections();
				}
				
				// 5. Обновляем SVG
				const pathGroup = document.getElementById('path-group');
				let path = pathGroup.querySelector('path');
				
				if (!path && this.currentGlyph && this.currentGlyph.d) {
					path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
					path.setAttribute('class', 'path');
					pathGroup.appendChild(path);
				}
				
				if (path) {
					path.setAttribute('d', this.currentGlyph?.d || '');
				}
			}

			clearAllSelections() {
				// Снимаем выделение с точек
				document.querySelectorAll('.point.selected, .control-point.selected').forEach(point => {
					point.classList.remove('selected');
				});
				
				// Очищаем выделение сегмента
				this.clearSegmentSelection();
				
				// Очищаем состояние
				this.state.selectedPoint = null;
				this.state.selectedSegment = null;
				
				// Скрываем кнопки
				this.hideSegmentButtons();
				
				// Обновляем кнопки
				this.updateSegmentButtons();
			}

handleKeyPress(e) {
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return;
    }
    
    // Ctrl+Стрелки для переключения глифов
    if (e.ctrlKey) {
        switch(e.key) {
            case 'ArrowRight':
            case 'ArrowDown':
                e.preventDefault();
                this.selectNextGlyph();
                return;
                
            case 'ArrowLeft':
            case 'ArrowUp':
                e.preventDefault();
                this.selectPreviousGlyph();
                return;
        }
    }
    
    // Ctrl+Z для отмены
    if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z') {
        e.preventDefault();
        this.undo();
        return;
    }
    
    if (e.ctrlKey || e.metaKey || e.altKey) {
        return;
    }
    
    switch(e.key.toLowerCase()) {
        case 'm':
        case 'ь':
            e.preventDefault();
            this.setTool(TOOLS.SELECT);
            break;
        case 'a':
        case 'ф':
            e.preventDefault();
            this.setTool(TOOLS.ADD_POINT);
            break;
        case 'd':
        case 'в':
            e.preventDefault();
            this.setTool(TOOLS.DELETE);
            break;
        case 'escape':
        case 'esc':
            e.preventDefault();
            this.clearAllSelections();
            break;
        case 'delete':
            // Delete - удаление точки или сегмента (старая логика)
            e.preventDefault();
            if (this.state.selectedPoint && this.state.selectedPoint.element) {
                // Сохраняем в историю перед удалением
                this.saveToHistory('delete_point', 'Удаление точки');
                this.deletePoint(this.state.selectedPoint.element);
            } else if (this.state.selectedSegment) {
                this.saveToHistory('delete_segment', 'Удаление сегмента');
                this.deleteSelectedSegment();
            }
            break;
        case 'backspace':
            // Backspace - ОТМЕНА последнего действия (НОВАЯ логика)
            e.preventDefault();
            this.undo();
            break;
    }
}
					 
            // ==========
            // ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ

            getSVGCoordinates(event, svgElement) {
                const pt = svgElement.createSVGPoint();
                pt.x = event.clientX;
                pt.y = event.clientY;
                return pt.matrixTransform(svgElement.getScreenCTM().inverse());
            }
            
            flipYCoordinates(pathData, unitsPerEm) {
                const commands = this.parsePathCommands(pathData);
                if (!commands) return pathData;
                
                let result = '';
                
                commands.forEach(cmd => {
                    const type = cmd.type;
                    const values = cmd.values;
                    
                    let transformedCmd = type;
                    
                    if (type === 'M' || type === 'L' || type === 'C') {
                        for (let i = 0; i < values.length; i += 2) {
                            const x = values[i];
                            const y = unitsPerEm - values[i+1];
                            transformedCmd += ` ${x} ${y}`;
                        }
                    } else if (type === 'm' || type === 'l' || type === 'c') {
                        for (let i = 0; i < values.length; i += 2) {
                            const x = values[i];
                            const y = -values[i+1];
                            transformedCmd += ` ${x} ${y}`;
                        }
                    } else if (type === 'Z' || type === 'z') {
                        transformedCmd = type;
                    }
                    
                    result += transformedCmd + ' ';
                });
                
                return result.trim();
            }
            

			// ==================================================
			// ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ И ШРИФТАМИ 
			// Загрузка шрифта подложки

async loadUnderlayFont() {
    const customFontInput = document.getElementById('custom-font');
    let fontName = customFontInput.value.trim();
    
    // Если выбрали из списка
    const selectedFont = document.querySelector('.font-item.active');
    if (selectedFont && !fontName) {
        fontName = selectedFont.textContent;
        customFontInput.value = fontName;
    }
    
    if (!fontName) {
        alert('Выберите или введите название шрифта');
        return;
    }
    
    // Простая проверка существования шрифта
    const testElement = document.createElement('span');
    testElement.style.cssText = `
        position: absolute;
        left: -9999px;
        font-size: 100px;
        font-family: sans-serif;
    `;
    testElement.textContent = 'A';
    
    document.body.appendChild(testElement);
    const defaultWidth = testElement.offsetWidth;
    
    testElement.style.fontFamily = `"${fontName}", sans-serif`;
    
    setTimeout(async () => {
        const newWidth = testElement.offsetWidth;
        document.body.removeChild(testElement);
        
        if (Math.abs(newWidth - defaultWidth) < 5) {
            this.showNotification(`Шрифт "${fontName}" не найден в системе.`, 'warning');
            return;
        }
        
        // Получаем метрики
        let metrics;
        try {
            metrics = await this.getSimpleFontMetrics(fontName);
        } catch (error) {
            console.warn('Не удалось получить метрики:', error);
            metrics = null;
        }
        
        // Сохраняем метрики подложки
        this.state.underlayMetrics = metrics;
        this.state.underlayFont = fontName;
        
        // ПОКАЗЫВАЕМ ДИАЛОГ ВЫБОРА
        if (metrics && (metrics.ascent !== 800 || metrics.descent !== -200)) {
            this.showMetricsDialog(metrics, fontName);
        } else {
            // Метрики стандартные или не получены - просто закрываем
            document.getElementById('font-modal').style.display = 'none';
            this.updateUnderlay();
        }
        
    }, 100);
}

showGroupSelectionWithMetrics(fontName, metrics) {
    // Проверяем отличаются ли метрики от стандартных
    if (metrics.ascent !== 800 || metrics.descent !== -200) {
        // Показываем существующий диалог с callback
        this.showMetricsDialog(metrics, fontName, (useMetrics) => {
            // Закрываем модальное окно метрик
            const metricsModal = document.getElementById('metrics-modal');
            if (metricsModal) metricsModal.remove();
            
            if (useMetrics) {
                // Пользователь выбрал использовать метрики подложки
                this.templateMetrics = metrics;
            } else {
                // Используем стандартные метрики
                this.templateMetrics = { ascent: 800, descent: -200 };
            }
            
            // После выбора метрик - показываем выбор групп символов
            this.showGroupSelection(fontName);
        });
    } else {
        // Метрики стандартные - сразу показываем группы
        this.templateMetrics = metrics;
        this.showGroupSelection(fontName);
    }
}


// Вспомогательный метод для обновления подложки
updateUnderlay() {
    if (this.currentGlyph && document.getElementById('show-underlay').checked) {
        setTimeout(() => {
            this.createSVGUnderlay();
        }, 150);
    }
    
    this.showNotification(
        `Шрифт "${this.state.underlayFont}" загружен как подложка`,
        'success'
    );
}

async getSimpleFontMetrics(fontName) {
    return new Promise((resolve) => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const fontSize = 100;
        
        ctx.font = `${fontSize}px "${fontName}", Arial`;
        
        // Тестируем высоту строки
        const testString = 'Hjgyp';
        const metrics = ctx.measureText(testString);
        
        if (metrics.actualBoundingBoxAscent && metrics.actualBoundingBoxDescent) {
            // Масштабируем к 1000 UPM
            const scale = 1000 / fontSize;
            
            resolve({
                ascent: Math.round(metrics.actualBoundingBoxAscent * scale),
                descent: -Math.round(metrics.actualBoundingBoxDescent * scale),
                unitsPerEm: 1000
            });
        } else {
            // Альтернативный метод через DOM
            const div = document.createElement('div');
            div.style.cssText = `
                position: absolute;
                left: -9999px;
                font-size: ${fontSize}px;
                font-family: "${fontName}", Arial;
                line-height: 1;
            `;
            div.textContent = 'Hjgyp';
            
            document.body.appendChild(div);
            
            setTimeout(() => {
                const height = div.offsetHeight;
                document.body.removeChild(div);
                
                // Эмпирическая формула
                const scale = 1000 / fontSize;
                resolve({
                    ascent: Math.round(height * 0.8 * scale),
                    descent: Math.round(-height * 0.2 * scale),
                    unitsPerEm: 1000
                });
            }, 100);
        }
    });
}

async getSystemFontMetrics(fontName) {
    return new Promise((resolve, reject) => {
        // Сначала ждем загрузки шрифтов
        document.fonts.ready.then(() => {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            const fontSize = 100;
            const testStrings = ['Hg', 'Aj', 'Tg', 'yp'];
            
            // Пробуем несколько раз с задержкой
            const attemptMeasurement = (attempt = 0) => {
                let anyDifference = false;
                let totalAscent = 0;
                let totalDescent = 0;
                let count = 0;
                
                for (const testString of testStrings) {
                    // Измеряем с fallback
                    ctx.font = `${fontSize}px "Arial"`;
                    const defaultMetrics = ctx.measureText(testString);
                    
                    // Измеряем с нашим шрифтом
                    ctx.font = `${fontSize}px "${fontName}", Arial`;
                    const newMetrics = ctx.measureText(testString);
                    
                    // Проверяем разницу
                    if (Math.abs(newMetrics.width - defaultMetrics.width) > 1) {
                        anyDifference = true;
                    }
                    
                    // Собираем метрики если они доступны
                    if (newMetrics.actualBoundingBoxAscent) {
                        totalAscent += newMetrics.actualBoundingBoxAscent;
                        totalDescent += newMetrics.actualBoundingBoxDescent;
                        count++;
                    }
                }
                
                if (!anyDifference && attempt < 3) {
                    // Шрифт еще не применился, ждем и пробуем снова
                    setTimeout(() => attemptMeasurement(attempt + 1), 100);
                    return;
                }
                
                if (!anyDifference) {
                    reject(new Error('Шрифт не применился'));
                    return;
                }
                
                const scale = 1000 / fontSize;
                
                if (count > 0) {
                    // Есть расширенные метрики
                    resolve({
                        ascent: Math.round((totalAscent / count) * scale),
                        descent: Math.round((totalDescent / count) * scale),
                        unitsPerEm: 1000,
                        capHeight: Math.round((totalAscent / count) * scale * 0.7),
                        xHeight: Math.round((totalAscent / count) * scale * 0.5)
                    });
                } else {
                    // Нет расширенных метрик, используем расчетные
                    resolve({
                        ascent: 800,
                        descent: -200,
                        unitsPerEm: 1000,
                        capHeight: 700,
                        xHeight: 500
                    });
                }
            };
            
            // Начинаем измерения
            attemptMeasurement();
            
        }).catch(() => {
            // document.fonts.ready недоступен
            reject(new Error('API шрифтов не доступен'));
        });
    });
}

			// Загрузка шрифта из файла для подложки
loadUnderlayFromFile() {
    // ПРОВЕРКА: если мы в режиме создания шаблона, не делаем ничего
    if (this.state && this.state.isCreatingTemplate) {
        return; // Выходим, файл будет обработан в showFontTemplateSelection()
    }
    
    // Обычная загрузка подложки
    document.getElementById('underlay-font-input').click();
}

async readFontMetrics(fontFile) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (event) => {
            try {
                const arrayBuffer = event.target.result;
                const dataView = new DataView(arrayBuffer);
                const sfntVersion = dataView.getUint32(0);
                
                let ascent = 800;
                let descent = -200;
                let unitsPerEm = 1000; // по умолчанию
                let typoAscent = null;
                let typoDescent = null;
                let winAscent = null;
                let winDescent = null;
                let lineGap = 0;
                
                if (sfntVersion === 0x00010000 || sfntVersion === 0x4F54544F) {
                    const numTables = dataView.getUint16(4);
                    
                    for (let i = 0; i < numTables; i++) {
                        const offset = 12 + i * 16;
                        const tag = String.fromCharCode(
                            dataView.getUint8(offset),
                            dataView.getUint8(offset + 1),
                            dataView.getUint8(offset + 2),
                            dataView.getUint8(offset + 3)
                        );
                        
                        const tableOffset = dataView.getUint32(offset + 8);
                        
                        if (tag === 'head') {
                            unitsPerEm = dataView.getUint16(tableOffset + 18);
                        }
                        else if (tag === 'OS/2') {
                            const version = dataView.getUint16(tableOffset);
                            
                            if (version >= 0) {
                                typoAscent = dataView.getInt16(tableOffset + 68);
                                typoDescent = dataView.getInt16(tableOffset + 70);
                                lineGap = dataView.getInt16(tableOffset + 72);
                                winAscent = dataView.getUint16(tableOffset + 74);
                                winDescent = dataView.getUint16(tableOffset + 76);
                            }
                        }
                        else if (tag === 'hhea') {
                            ascent = dataView.getInt16(tableOffset + 4);
                            descent = dataView.getInt16(tableOffset + 6);
                        }
                    }
                }
                
                console.log('Raw values (unitsPerEm=' + unitsPerEm + '):', {
                    typoAscent, typoDescent, 
                    winAscent, winDescent,
                    ascent, descent
                });
                
                // МАСШТАБИРУЕМ к 1000 units per em!
                const scale = 1000 / unitsPerEm;
                
                let finalAscent, finalDescent;
                
                if (typoAscent !== null && typoDescent !== null) {
                    finalAscent = Math.round(typoAscent * scale);
                    finalDescent = Math.round(typoDescent * scale);
                    console.log('Using Typo metrics, scaled:', { finalAscent, finalDescent });
                } else if (winAscent !== null && winDescent !== null) {
                    finalAscent = Math.round(winAscent * scale);
                    finalDescent = Math.round(-winDescent * scale);
                    console.log('Using Win metrics, scaled:', { finalAscent, finalDescent });
                } else {
                    finalAscent = Math.round(ascent * scale);
                    finalDescent = Math.round(descent * scale);
                    console.log('Using hhea metrics, scaled:', { finalAscent, finalDescent });
                }
                
                // Проверяем расчет
                console.log('Для 2048 UPM:', {
                    typo: `${typoAscent}/${typoDescent}`,
                    scaledTo1000: `${finalAscent}/${finalDescent}`,
                    calculation: `(${typoAscent} * 1000 / 2048 = ${finalAscent})`
                });
                
                resolve({ 
                    ascent: finalAscent, 
                    descent: finalDescent,
                    unitsPerEm: 1000, // Всегда возвращаем 1000 для редактора
                    originalUnitsPerEm: unitsPerEm, // Сохраняем оригинальное значение
                    allMetrics: {
                        typo: { ascent: typoAscent, descent: typoDescent, lineGap },
                        win: { ascent: winAscent, descent: winDescent },
                        hhea: { ascent, descent },
                        originalUnitsPerEm: unitsPerEm
                    }
                });
                
            } catch (error) {
                console.error('Ошибка чтения метрик шрифта:', error);
                resolve({
                    ascent: 800,
                    descent: -200,
                    unitsPerEm: 1000
                });
            }
        };
        
        reader.onerror = reject;
        reader.readAsArrayBuffer(fontFile);
    });
}

			// Заполнение списка системных шрифтов
			populateSystemFonts() {
				const fontList = document.getElementById('system-fonts');
				const commonFonts = [
					"Arial", "Arial Black", "Verdana", "Tahoma", "Trebuchet MS", 
					"Times New Roman", "Georgia", "Garamond", "Courier New",
					"Brush Script MT", "Comic Sans MS", "Impact", "Lucida Console"
				];
				
				fontList.innerHTML = '';
				
				commonFonts.forEach(font => {
					const fontItem = document.createElement('div');
					fontItem.className = 'font-item';
					fontItem.textContent = font;
					fontItem.addEventListener('click', () => {
						document.querySelectorAll('.font-item').forEach(item => {
							item.classList.remove('active');
						});
						fontItem.classList.add('active');
						document.getElementById('custom-font').value = font;
					});
					fontList.appendChild(fontItem);
				});
			}

			// Создание нового шрифта
createNewFont() {
    // Сначала спрашиваем - создать пустой или на основе существующего?
    const modalHtml = `
        <div id="new-font-modal" class="modal" style="display:flex;">
            <div class="modal-content" style="max-width:500px;">
                <div class="modal-header">
                    <h3><i class="fas fa-font"></i> Создать новый шрифт</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div style="padding:20px;">
                    <h4 style="margin-bottom:15px;color:#cdd6f4;">Выберите тип:</h4>
                    
                    <div style="display:grid;gap:10px;margin-bottom:20px;">
                        <button id="create-empty-font" style="text-align:left;padding:15px;">
                            <div style="font-size:18px;font-weight:bold;color:#000000;">
                                <i class="fas fa-file"></i> Пустой шрифт
                            </div>
                            <div style="font-size:14px;color:#000000;margin-top:5px;">
                                Создать пустой шрифт с базовыми настройками
                            </div>
                        </button>
                        
                        <button id="create-from-template" style="text-align:left;padding:15px;">
                            <div style="font-size:18px;font-weight:bold;color:#000000;">
                                <i class="fas fa-copy"></i> На основе существующего
                            </div>
                            <div style="font-size:14px;color:#000000;margin-top:5px;">
                                Использовать метрики и символы из системного шрифта
                            </div>
                        </button>
                        
                        <button id="create-from-svg" style="text-align:left;padding:15px;">
                            <div style="font-size:18px;font-weight:bold;color:#000000;">
                                <i class="fas fa-file-import"></i> Импорт SVG шрифта
                            </div>
                            <div style="font-size:14px;color:#000000;margin-top:5px;">
                                Загрузить существующий SVG шрифт для редактирования
                            </div>
                        </button>
                    </div>
                    
                    <div style="display:flex;gap:10px;margin-top:20px;">
                        <button class="secondary close-modal" style="flex:1;">
                            Отмена
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = document.getElementById('new-font-modal');
    
    // Обработчики
    const closeModal = () => modal.remove();
    
    modal.querySelectorAll('.close-modal').forEach(btn => {
        btn.addEventListener('click', closeModal);
    });
    
    // Пустой шрифт
    modal.querySelector('#create-empty-font').addEventListener('click', () => {
        closeModal();
        this.createEmptyFont();
    });
    
    // На основе существующего
    modal.querySelector('#create-from-template').addEventListener('click', () => {
        closeModal();
        setTimeout(() => this.showFontTemplateSelection(), 100);
    });
    
    // Импорт SVG (существующая функция)
    modal.querySelector('#create-from-svg').addEventListener('click', () => {
        closeModal();
        setTimeout(() => this.loadSVGFont(), 100);
    });
    
    // Закрытие по клику вне окна
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    
    // Escape
    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', escapeHandler);
        }
    };
    document.addEventListener('keydown', escapeHandler);
}

showFontTemplateSelection() {
    const fontModal = document.getElementById('font-modal');
    if (!fontModal) return;
    
    // Устанавливаем флаг, что мы в режиме создания шаблона
    this.state.isCreatingTemplate = true;
    
    // Сохраняем оригинальное состояние
    const originalTitle = fontModal.querySelector('.modal-header h3').innerHTML;
    const originalDescription = fontModal.querySelector('p').textContent;
    
    // Меняем заголовок и описание
    fontModal.querySelector('.modal-header h3').innerHTML = '<i class="fas fa-copy"></i> Создать шрифт на основе...';
    fontModal.querySelector('p').textContent = 'Выберите шрифт, на основе которого будут созданы глифы и метрики:';
    
    // Получаем кнопки
    const loadBtn = document.getElementById('load-underlay');
    const fileBtn = document.getElementById('load-from-file');
    
    // Сохраняем оригинальное содержимое
    const originalLoadHtml = loadBtn.innerHTML;
    const originalFileHtml = fileBtn.innerHTML;
    
    // Меняем текст кнопок
    loadBtn.innerHTML = '<i class="fas fa-check"></i> Использовать этот шрифт';
    fileBtn.innerHTML = '<i class="fas fa-folder-open"></i> Загрузить из файла';
    
    // Временные обработчики
const tempLoadHandler = () => {
    const fontInput = document.getElementById('custom-font');
    const activeFont = document.querySelector('.font-item.active');
    const fontName = fontInput.value.trim() || (activeFont ? activeFont.textContent : '');
    
    if (!fontName) {
        this.showNotification('Выберите шрифт', 'warning');
        return;
    }
    
    // Проверка шрифта
    const testSpan = document.createElement('span');
    testSpan.style.cssText = 'position:absolute;left:-9999px;font-size:100px;font-family:sans-serif;';
    testSpan.textContent = 'A';
    document.body.appendChild(testSpan);
    
    const defaultWidth = testSpan.offsetWidth;
    testSpan.style.fontFamily = `"${fontName}", sans-serif`;
    
    setTimeout(async () => {
        const newWidth = testSpan.offsetWidth;
        document.body.removeChild(testSpan);
        
        if (Math.abs(newWidth - defaultWidth) < 5) {
            this.showNotification(`Шрифт "${fontName}" не найден в системе`, 'error');
            return;
        }
        
        // Сбрасываем флаг
        this.state.isCreatingTemplate = false;
        
        // Восстанавливаем оригинальное состояние
        fontModal.querySelector('.modal-header h3').innerHTML = originalTitle;
        fontModal.querySelector('p').textContent = originalDescription;
        loadBtn.innerHTML = originalLoadHtml;
        fileBtn.innerHTML = originalFileHtml;
        
        loadBtn.onclick = null;
        fileBtn.onclick = null;
        
        fontModal.style.display = 'none';
        
        // ПОЛУЧАЕМ МЕТРИКИ для создания шаблона
        try {
            const metrics = await this.getSystemFontMetrics(fontName);
            this.showGroupSelectionWithMetrics(fontName, metrics);
        } catch (error) {
            console.error('Ошибка получения метрик:', error);
            // Используем метрики по умолчанию
            this.showGroupSelectionWithMetrics(fontName, {
                ascent: 800,
                descent: -200,
                unitsPerEm: 1000
            });
        }
        
    }, 100);
};
   
    const tempFileHandler = (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        // Обработчик для загрузки файла в режиме создания шаблона
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.ttf,.otf,.woff,.woff2,.ttc';
        
        input.onchange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            
            const fontName = file.name.replace(/\.[^/.]+$/, "");
            
            // Читаем файл
            const reader = new FileReader();
            reader.onload = (e) => {
                const fontDataUrl = e.target.result;
                const fontFace = new FontFace(fontName, `url(${fontDataUrl})`);
                
                fontFace.load().then(loadedFont => {
                    document.fonts.add(loadedFont);
                    
                    // Сбрасываем флаг
                    this.state.isCreatingTemplate = false;
                    
                    // Восстанавливаем оригинальное состояние
                    fontModal.querySelector('.modal-header h3').innerHTML = originalTitle;
                    fontModal.querySelector('p').textContent = originalDescription;
                    loadBtn.innerHTML = originalLoadHtml;
                    fileBtn.innerHTML = originalFileHtml;
                    
                    loadBtn.onclick = null;
                    fileBtn.onclick = null;
                    
                    fontModal.style.display = 'none';
                    this.showGroupSelection(fontName);
                    
                    this.showNotification(
                        `Шрифт "${fontName}" загружен из файла. Выберите группы символов.`,
                        'success'
                    );
                });
            };
            
            reader.readAsDataURL(file);
        };
        
        input.click();
    };
    
    // Устанавливаем временные обработчики
    loadBtn.onclick = tempLoadHandler;
    fileBtn.onclick = tempFileHandler;
    
    // Обработчики закрытия
    const closeButtons = fontModal.querySelectorAll('.close-modal');
    closeButtons.forEach(btn => {
        const originalClick = btn.onclick;
        btn.onclick = (e) => {
            // Сбрасываем флаг
            this.state.isCreatingTemplate = false;
            
            // Восстанавливаем оригинальное состояние
            fontModal.querySelector('.modal-header h3').innerHTML = originalTitle;
            fontModal.querySelector('p').textContent = originalDescription;
            loadBtn.innerHTML = originalLoadHtml;
            fileBtn.innerHTML = originalFileHtml;
            
            loadBtn.onclick = null;
            fileBtn.onclick = null;
            
            // Вызываем оригинальный обработчик
            if (originalClick) originalClick.call(btn, e);
            else fontModal.style.display = 'none';
        };
    });
    
    // Показываем модальное окно
    fontModal.style.display = 'flex';
}

createEmptyFont() {
    // Существующая логика
    
    this.fontData = {
        name: "NewFont",
        horizAdvX: 500,
        unitsPerEm: 1000,
        ascent: 800,
        descent: -200,
        capHeight: 500,
        xHeight: 300,
        glyphs: []
    };
    
    this.guidelines = {
        top: 200,
        bottom: 1200,
        left: 0,
        right: 500,
        baseline: 1000,
        custom: []
    };
    
    this.currentGlyph = null;
    this.state.underlayFont = null;
    this.pathTopology.contours = [];
    
    this.updateFontInfo();
    this.updateGlyphList();
    this.updateGuidelineControls();
    this.clearCanvas();
    
    document.getElementById('no-glyph').style.display = 'block';
    document.getElementById('svg-canvas').style.display = 'none';
    document.getElementById('current-glyph-name').textContent = 'Выберите глиф';
    
    alert('Новый шрифт создан. Добавьте глифы с помощью кнопки "Добавить глиф".');
}

getSymbolRange(start, end) {
    const symbols = [];
    for (let i = start; i <= end; i++) {
        symbols.push(String.fromCharCode(i));
    }
    return symbols;
}

getCyrillic() {
    // Все русские буквы в правильном порядке
    const cyrillicUppercase = 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ';
    const cyrillicLowercase = 'абвгдеёжзийклмнопрстуфхцчшщъыьэюя';
    
    return cyrillicUppercase.split('').concat(cyrillicLowercase.split(''));
}

generateFontFromTemplate(fontName, selectedGroups) {
    
    // Собираем все символы из выбранных групп
    let allSymbols = [];
    selectedGroups.forEach(group => {
        allSymbols = allSymbols.concat(group.symbols);
    });
    
    // Убираем дубликаты
    allSymbols = [...new Set(allSymbols)];
    
    // Измеряем ширину КАЖДОГО символа
    const charWidths = this.measureAllCharWidths(fontName, allSymbols);
    
    // Вычисляем среднюю ширину для шрифта
    let totalWidth = 0;
    let count = 0;
    Object.values(charWidths).forEach(width => {
        if (width > 0) {
            totalWidth += width;
            count++;
        }
    });
    
    const avgWidth = count > 0 ? Math.round(totalWidth / count * 10) : 500;
    
    // Создаем шрифт
    this.fontData = {
        name: `BasedOn${fontName.replace(/\s+/g, '')}`,
        horizAdvX: avgWidth,
        unitsPerEm: 1000,
        ascent: this.templateMetrics.ascent,      // Используем сохраненные метрики
        descent: this.templateMetrics.descent,    // Используем сохраненные метрики
        glyphs: []
    };
    
    // Направляющие устанавливаем по метрикам
    this.guidelines.top = this.fontData.unitsPerEm - this.fontData.ascent;
    this.guidelines.bottom = this.fontData.unitsPerEm - this.fontData.descent;
    
    // Создаем глифы с РЕАЛЬНЫМИ ширинами
    allSymbols.forEach(char => {
        let width;
        
        if (charWidths[char] && charWidths[char] > 0) {
            // Конвертируем пиксели в unitsPerEm (примерно)
            width = Math.round(charWidths[char] * 10);
        } else if (char === ' ') {
            // Для пробела - половина средней ширины
            width = Math.round(avgWidth * 0.5);
        } else {
            // Если не удалось измерить - используем среднюю
            width = avgWidth;
        }
        
        // Ограничиваем разумными пределами
        width = Math.max(50, Math.min(1500, width));
        
        this.fontData.glyphs.push({
            unicode: char,
            name: this.getGlyphName(char),
            d: "",
            horizAdvX: width
        });
    });
	// Сортируем созданные глифы
	this.fontData.glyphs.sort((a, b) => {
		if (a.unicode === ' ') return -1;
		if (b.unicode === ' ') return 1;
		return a.unicode.charCodeAt(0) - b.unicode.charCodeAt(0);
	});
    // Обновляем интерфейс
    this.updateFontInfo();
    this.updateGlyphList();
    this.updateGuidelineControls();
    this.clearCanvas();
    
    this.currentGlyph = null;
    this.state.underlayFont = fontName;
    
    document.getElementById('no-glyph').style.display = 'block';
    document.getElementById('svg-canvas').style.display = 'none';
    document.getElementById('current-glyph-name').textContent = 'Выберите глиф';
    
    this.showTemplateSuccessMessage(fontName, allSymbols.length);
}

measureAllCharWidths(fontName, chars) {
    const widths = {};
    
    // Создаем один canvas для всех измерений
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 2000;
    canvas.height = 200;
    
    // Устанавливаем шрифт
    ctx.font = `100px "${fontName}"`;
    ctx.fillStyle = 'black';
    ctx.textBaseline = 'alphabetic';
    ctx.textAlign = 'left';
    
    // Измеряем каждый символ
    chars.forEach(char => {
        try {
            const metrics = ctx.measureText(char);
            widths[char] = metrics.width;
            
            // Если ширина 0, возможно это непечатаемый символ
            if (metrics.width === 0 && char !== ' ') {
                console.warn(`Символ "${char}" (код ${char.charCodeAt(0)}) имеет ширину 0`);
            }
        } catch (e) {
            console.error(`Ошибка измерения символа "${char}":`, e);
            widths[char] = 0;
        }
    });
    
    return widths;
}

getGlyphName(char) {
    if (char === ' ') return 'space';
    const code = char.charCodeAt(0);
    return `uni${code.toString(16).toUpperCase().padStart(4, '0')}`;
}

showTemplateSuccessMessage(fontName, symbolCount) {
    const message = `<strong>Шрифт создан!</strong><br>
                    На основе: <strong>${fontName}</strong><br>
                    Создано глифов: <strong>${symbolCount}</strong><br>
                    Выберите глиф из списка и начните рисовать`;
    
    this.showNotification(message, 'success');
}
			// Загрузка SVG шрифта из файла
loadSVGFont() {
    document.getElementById('svg-font-input').click();
}

			// Парсинг SVG шрифта (упрощенная версия)
			parseSVGFont(svgText) {
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(svgText, 'image/svg+xml');
				
				const fontElement = xmlDoc.querySelector('font');
				if (!fontElement) {
					throw new Error('SVG не содержит шрифта');
				}
				
				this.fontData.name = fontElement.id || 'ImportedFont';
				this.fontData.horizAdvX = parseFloat(fontElement.getAttribute('horiz-adv-x')) || 500;
				
				const fontFace = xmlDoc.querySelector('font-face');
				if (fontFace) {
					this.fontData.unitsPerEm = parseFloat(fontFace.getAttribute('units-per-em')) || 1000;
					this.fontData.ascent = parseFloat(fontFace.getAttribute('ascent')) || 800;
					this.fontData.descent = parseFloat(fontFace.getAttribute('descent')) || -200;
					this.fontData.capHeight = parseFloat(fontFace.getAttribute('cap-height')) || 500;
					this.fontData.xHeight = parseFloat(fontFace.getAttribute('x-height')) || 300;
				}
				
				// Устанавливаем направляющие
				this.guidelines.top = this.fontData.unitsPerEm - this.fontData.ascent;
				this.guidelines.bottom = this.fontData.unitsPerEm - this.fontData.descent;
				this.guidelines.left = 0;
				this.guidelines.right = this.fontData.horizAdvX;
				this.guidelines.baseline = this.fontData.unitsPerEm;
				this.guidelines.custom = [];
				
				// Обновляем элементы управления
    document.getElementById('top-guide').value = Math.round(this.guidelines.top);
    document.getElementById('bottom-guide').value = Math.round(this.guidelines.bottom);
    document.getElementById('left-guide').value = Math.round(this.guidelines.left);
    document.getElementById('right-guide').value = Math.round(this.guidelines.right);
				
				// Парсим глифы
				this.fontData.glyphs = [];
				const glyphElements = xmlDoc.querySelectorAll('glyph');
				
				glyphElements.forEach(glyphEl => {
					const unicodeAttr = glyphEl.getAttribute('unicode');
					const unicode = this.parseUnicode(unicodeAttr);
					const name = glyphEl.getAttribute('glyph-name') || unicode || 'unnamed';
					let d = glyphEl.getAttribute('d') || '';
					const horizAdvX = parseFloat(glyphEl.getAttribute('horiz-adv-x')) || this.fontData.horizAdvX;
					
					// Преобразуем координаты Y
					if (d) {
						d = this.flipYCoordinates(d, this.fontData.unitsPerEm);
					}
					
					if (unicode !== null) {
						this.fontData.glyphs.push({
							unicode: unicode,
							name: name,
							d: d,
							horizAdvX: horizAdvX
						});
					}
				});
				
				this.fontData.glyphs.sort((a, b) => {
					if (a.unicode === ' ') return -1;
					if (b.unicode === ' ') return 1;
					if (!a.unicode) return 1;
					if (!b.unicode) return -1;
					return a.unicode.charCodeAt(0) - b.unicode.charCodeAt(0);
				});
				// Обновляем интерфейс
				this.updateFontInfo();
				this.updateGlyphList();
				
				this.currentGlyph = null;
				this.clearCanvas();
				document.getElementById('no-glyph').style.display = 'block';
				document.getElementById('svg-canvas').style.display = 'none';
				document.getElementById('current-glyph-name').textContent = 'Выберите глиф';
			}

			// Парсинг Unicode (упрощенная версия)
			parseUnicode(unicodeAttr) {
				if (!unicodeAttr) return null;
				
				// Если это пробел
				if (unicodeAttr.trim() === '') return ' ';
				
				// Если это HTML entity
				const entityMatch = unicodeAttr.match(/&#x([0-9A-Fa-f]+);/);
				if (entityMatch) {
					return String.fromCharCode(parseInt(entityMatch[1], 16));
				}
				
				// Если это обычный символ
				return unicodeAttr.length > 0 ? unicodeAttr.charAt(0) : null;
			}

			// Сохранение шрифта
			saveFont() {
				if (this.fontData.glyphs.length === 0) {
					alert('Нет глифов для сохранения');
					return;
				}
				
				// Создаем копию для сохранения
				const saveData = {
					...this.fontData,
					glyphs: JSON.parse(JSON.stringify(this.fontData.glyphs))
				};
				
				// Восстанавливаем ascent/descent из направляющих
				saveData.ascent = saveData.unitsPerEm - this.guidelines.top;
				saveData.descent = saveData.unitsPerEm - this.guidelines.bottom;
				
				// Обратное преобразование координат Y для сохранения
				saveData.glyphs.forEach(glyph => {
					if (glyph.d) {
						glyph.d = this.flipYCoordinates(glyph.d, saveData.unitsPerEm);
					}
				});
				
				// Генерируем SVG
				let svg = `<?xml version="1.0" encoding="UTF-8"?>
			<!DOCTYPE svg PUBLIC '-//W3C//DTD SVG 1.1//EN' 'http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd'>
			<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">
			<defs>
			<font horiz-adv-x="${saveData.horizAdvX}" id="${saveData.name}">
			<font-face font-family="${saveData.name}" units-per-em="${saveData.unitsPerEm}" ascent="${saveData.ascent}" descent="${saveData.descent}" cap-height="${saveData.capHeight}" x-height="${saveData.xHeight}"/>
			<missing-glyph horiz-adv-x="${saveData.horizAdvX}"/>`;
				
				saveData.glyphs.forEach(glyph => {
					const unicodeAttr = glyph.unicode === ' ' ? ' ' : `&#x${glyph.unicode.charCodeAt(0).toString(16)};`;
					svg += `
			<glyph unicode="${unicodeAttr}" glyph-name="${glyph.name}" d="${glyph.d}" horiz-adv-x="${glyph.horizAdvX || saveData.horizAdvX}"/>`;
				});
				
				svg += `
			</font>
			</defs>
			<metadata>Создано в SVG Font Editor</metadata>
			</svg>`;
				
				// Скачиваем файл
				const blob = new Blob([svg], { type: 'image/svg+xml' });
				const url = URL.createObjectURL(blob);
				const a = document.createElement('a');
				a.href = url;
				a.download = `${saveData.name}.svg`;
				document.body.appendChild(a);
				a.click();
				document.body.removeChild(a);
				URL.revokeObjectURL(url);
				
				this.showNotification(`Шрифт "${saveData.name}" сохранен.`, 'success');
			}
// конец работы с шрифтами
//проверка шрифтов
showDebugModal() {
    const modal = document.getElementById('debug-modal');
    modal.style.display = 'flex';
    
    // Инициализация
    this.updateDebugPreview();
    
    // 1. Получаем элементы
    const debugText = document.getElementById('debug-text');
    const updateBtn = document.getElementById('update-debug');
    
    // 2. Удаляем ВСЕ старые обработчики (клонируем элементы)
    const newDebugText = debugText.cloneNode(true);
    debugText.parentNode.replaceChild(newDebugText, debugText);
    
    const newUpdateBtn = updateBtn.cloneNode(true);
    updateBtn.parentNode.replaceChild(newUpdateBtn, updateBtn);
    
    // 3. Теперь получаем СВЕЖИЕ элементы
    const freshDebugText = document.getElementById('debug-text');
    const freshUpdateBtn = document.getElementById('update-debug');
    
    // 4. Устанавливаем новые обработчики
    freshDebugText.oninput = () => {
        this.updateDebugPreview();
    };
    
    freshUpdateBtn.onclick = () => {
        this.updateDebugPreview();
    };
    
    // Обработчики закрытия
    modal.querySelectorAll('.close-modal').forEach(btn => {
        btn.onclick = () => {
            modal.style.display = 'none';
        };
    });
    
    // Закрытие по клику на фон
    modal.onclick = (e) => {
        if (e.target === modal) {
            modal.style.display = 'none';
        }
    };
}

updateDebugPreview() {
    const text = document.getElementById('debug-text').value || 'A';
    const container = document.getElementById('text-overlay');
    
    container.innerHTML = '';
    
    // Размеры для масштабирования
    const fontSize = 190;
    const scale = fontSize / this.fontData.unitsPerEm;
    
    // 1. Создаем контейнер
    const contentDiv = document.createElement('div');
    contentDiv.style.cssText = `
        position: relative;
        width: ${fontSize * text.length * 1.2}px;
        height: ${fontSize * 1.5}px;
        margin: 0 auto;
    `;
    
    // 2. Ждем загрузки шрифта
    document.fonts.ready.then(() => {
        // Создаем SVG для всего
        const svgNS = "http://www.w3.org/2000/svg";
        const svg = document.createElementNS(svgNS, "svg");
        svg.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: ${fontSize * text.length * 1.2}px;
            height: ${fontSize * 1.5}px;
            z-index: 1;
            pointer-events: none;
            overflow: visible;
        `;
        
        // Группа для масштабирования
        const g = document.createElementNS(svgNS, "g");
        g.setAttribute("transform", `scale(${scale})`);
        
        // 3. ОТРИСОВЫВАЕМ ПОДЛОЖКУ (SVG text) - делаем текст темнее чтобы был виден
        const underlayText = document.createElementNS(svgNS, "text");
        underlayText.textContent = text;
        
        let underlayY = this.guidelines.baseline; // 1000 - baseline текста
        
        underlayText.setAttribute('x', this.guidelines.left);
        underlayText.setAttribute('y', underlayY);
        underlayText.setAttribute('font-size', this.fontData.unitsPerEm);
        underlayText.setAttribute('fill', 'rgba(166, 227, 161, 0.9)'); // БОЛЕЕ ЯРКИЙ
        
        if (this.state.underlayFont) {
            underlayText.setAttribute('font-family', `'${this.state.underlayFont}'`);
            underlayText.style.fontFamily = `'${this.state.underlayFont}', Arial`;
        }
        
        g.appendChild(underlayText);
        
        // 4. ОТРИСОВЫВАЕМ SVG ШРИФТ (ПУТЬ) И СОБИРАЕМ ИНФО О ТОМ, КАКИЕ БУКВЫ ИМЕЮТ ВЕКТОРЫ
        let currentX = this.guidelines.left;
        let hasAnyGlyphs = false;
        const lettersWithVectors = new Set(); // Множество букв, у которых есть векторы
        
        for (let i = 0; i < text.length; i++) {
            const char = text.charAt(i);
            const glyph = this.fontData.glyphs.find(g => g.unicode === char);
            
            if (glyph && glyph.d) {
                const path = document.createElementNS(svgNS, "path");
                path.setAttribute("d", glyph.d);
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", "#0612F0");
                path.setAttribute("stroke-width", "10");
                path.setAttribute("stroke-linecap", "round");
                path.setAttribute("stroke-linejoin", "round");
                
                path.setAttribute("transform", `translate(${currentX}, 0)`);
                
                g.appendChild(path);
                hasAnyGlyphs = true;
                lettersWithVectors.add(i); // Запоминаем, что у этой буквы есть вектор
                
                currentX += glyph.horizAdvX || this.fontData.horizAdvX;
            } else {
                currentX += this.fontData.horizAdvX * 0.5;
            }
        }
        
        svg.appendChild(g);
        
        // 5. ЛИНИЯ ДЛЯ ПОДЛОЖКИ на уровне baseline (1000)
        const underlayLine = document.createElementNS(svgNS, "line");
        underlayLine.setAttribute("x1", this.guidelines.left);
        underlayLine.setAttribute("x2", currentX); // до конца текста
        underlayLine.setAttribute("y1", this.guidelines.baseline); // 1000
        underlayLine.setAttribute("y2", this.guidelines.baseline); // 1000
        underlayLine.setAttribute("stroke", "#FFFFFF");
        underlayLine.setAttribute("stroke-width", "3");
        underlayLine.setAttribute("stroke-dasharray", "5,5");
        underlayLine.setAttribute("pointer-events", "none");
        g.appendChild(underlayLine);
        
        // 6. КРАСНЫЕ РАМКИ ТОЛЬКО ДЛЯ БУКВ БЕЗ ВЕКТОРОВ
        let frameX = this.guidelines.left;
        
        for (let i = 0; i < text.length; i++) {
            const char = text.charAt(i);
            const glyph = this.fontData.glyphs.find(g => g.unicode === char);
            const glyphWidth = glyph ? (glyph.horizAdvX || this.fontData.horizAdvX) : this.fontData.horizAdvX * 0.5;
            
            // Проверяем, есть ли у этой буквы вектор
            if (!lettersWithVectors.has(i)) {
                // Красный прямоугольник - только если НЕТ вектора
                const frame = document.createElementNS(svgNS, "rect");
                frame.setAttribute("x", frameX);
                frame.setAttribute("y", this.guidelines.top); // верхняя направляющая
                frame.setAttribute("width", glyphWidth);
                frame.setAttribute("height", this.guidelines.bottom - this.guidelines.top); // от верхней до нижней направляющей
                frame.setAttribute("fill", "none");
                frame.setAttribute("stroke", "rgba(243, 139, 168, 0.5)"); // полупрозрачный розовый
                frame.setAttribute("stroke-width", "2");
                frame.setAttribute("stroke-dasharray", "5,5");
                frame.setAttribute("pointer-events", "none");
                
                g.appendChild(frame);
            }
            
            frameX += glyphWidth;
        }
        
        // 7. Собираем
        contentDiv.appendChild(svg);
        container.appendChild(contentDiv);
        
    }).catch(error => {
        container.innerHTML = '<div style="color: #f38ba8; text-align: center;">Ошибка загрузки шрифта</div>';
    });
}

//конец проверки
			// Отражение по горизонтали
			mirrorHorizontal() {
				if (!this.currentGlyph || !this.currentGlyph.d) return;
				
				const bbox = this.getPathBBox(this.currentGlyph.d);
				const centerX = (bbox.x + bbox.width / 2);
				
				const transformedPath = this.mirrorPath(this.currentGlyph.d, centerX, true, false);
				this.currentGlyph.d = transformedPath;
				
				this.renderGlyph();
			}

			// Отражение по вертикали
			mirrorVertical() {
				if (!this.currentGlyph || !this.currentGlyph.d) return;
				
				const bbox = this.getPathBBox(this.currentGlyph.d);
				const centerY = (bbox.y + bbox.height / 2);
				
				const transformedPath = this.mirrorPath(this.currentGlyph.d, centerY, false, true);
				this.currentGlyph.d = transformedPath;
				
				this.renderGlyph();
			}

			// Функция отражения пути
			mirrorPath(pathData, center, mirrorX = true, mirrorY = false) {
				const commands = this.parsePathCommands(pathData);
				if (!commands) return pathData;
				
				let result = '';
				let currentX = 0;
				let currentY = 0;
				
				commands.forEach(cmd => {
					const type = cmd.type;
					const values = cmd.values;
					
					let transformedCmd = type;
					
					if (type === 'M' || type === 'm' || type === 'L' || type === 'l') {
						for (let i = 0; i < values.length; i += 2) {
							let x = values[i];
							let y = values[i+1];
							
							if (type === 'M' || type === 'L') {
								if (mirrorX) x = 2 * center - x;
								if (mirrorY) y = 2 * center - y;
							} else {
								if (mirrorX) x = -x;
								if (mirrorY) y = -y;
							}
							
							transformedCmd += ` ${x} ${y}`;
						}
						
						if (values.length >= 2) {
							if (type === 'M' || type === 'm') {
								currentX = type === 'M' ? values[0] : currentX + values[0];
								currentY = type === 'M' ? values[1] : currentY + values[1];
							} else {
								currentX = type === 'L' ? values[0] : currentX + values[0];
								currentY = type === 'L' ? values[1] : currentY + values[1];
							}
						}
					} else if (type === 'C' || type === 'c') {
						for (let i = 0; i < values.length; i += 2) {
							let x = values[i];
							let y = values[i+1];
							
							if (type === 'C') {
								if (mirrorX) x = 2 * center - x;
								if (mirrorY) y = 2 * center - y;
							} else {
								if (mirrorX) x = -x;
								if (mirrorY) y = -y;
							}
							
							transformedCmd += ` ${x} ${y}`;
						}
						
						if (values.length >= 6) {
							currentX = type === 'C' ? values[4] : currentX + values[4];
							currentY = type === 'C' ? values[5] : currentY + values[5];
						}
					} else if (type === 'Z' || type === 'z') {
						transformedCmd = type;
					}
					
					result += transformedCmd + ' ';
				});
				
				return result.trim();
			}

			// Получение bounding box пути
			getPathBBox(pathData) {
				try {
					const svgNS = "http://www.w3.org/2000/svg";
					const svg = document.createElementNS(svgNS, "svg");
					const path = document.createElementNS(svgNS, "path");
					
					path.setAttribute("d", pathData);
					svg.appendChild(path);
					document.body.appendChild(svg);
					
					const bbox = path.getBBox();
					document.body.removeChild(svg);
					
					return bbox;
				} catch (e) {
					return { x: 0, y: 0, width: 100, height: 100 };
				}
			}

			// ==============================================
			// ФУНКЦИИ РАБОТЫ С НАПРАВЛЯЮЩИМИ (ИСПРАВЛЕННЫЕ)

			// Показать модальное окно выбора шрифта
			showFontModal() {
				document.getElementById('font-modal').style.display = 'flex';
			}

			// Создание SVG подложки
createSVGUnderlay() {
    const svgCanvas = document.getElementById('svg-canvas');
    
    // Удаляем старую подложку если есть
    const oldUnderlay = document.getElementById('underlay-svg');
    if (oldUnderlay) {
        oldUnderlay.remove();
    }
    
    if (!this.currentGlyph || !this.state.underlayFont || !document.getElementById('show-underlay').checked) {
        return;
    }
    
    // Создаем группу для подложки
    const underlayGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    underlayGroup.id = 'underlay-svg';
    underlayGroup.setAttribute('class', 'underlay-svg');
    
    // Создаем text элемент в SVG
    const textElement = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    
    // Устанавливаем символ глифа
    const charToDisplay = this.currentGlyph.unicode === ' ' ? '⠀' : this.currentGlyph.unicode;
    textElement.textContent = charToDisplay;
    
    // Устанавливаем шрифт
    textElement.setAttribute('font-family', this.state.underlayFont);
    textElement.style.fontFamily = this.state.underlayFont;
    
    // ФИКСИРОВАННЫЙ размер шрифта = units-per-em
    textElement.setAttribute('font-size', this.fontData.unitsPerEm);
    
    textElement.setAttribute('fill', 'rgba(136, 136, 136, 0.15)');
    textElement.style.stroke = 'none';
    
    underlayGroup.appendChild(textElement);
    svgCanvas.appendChild(underlayGroup);
    
    // СРАЗУ позиционируем - без ожидания
    this.positionUnderlay(underlayGroup, textElement);
    
}

			// Позиционирование подложки
positionUnderlay(underlayGroup, textElement) {
    if (!this.currentGlyph || !textElement) return;
    
    const fontSize = this.fontData.unitsPerEm; // Используем unitsPerEm редактора
    textElement.setAttribute('font-size', fontSize);
    
    const leftX = this.guidelines.left;
    
    // ВАЖНО: масштабируем метрики подложки к нашим единицам
    if (this.state.underlayMetrics) {
        const metrics = this.state.underlayMetrics;
        
        // 1. Масштаб от метрик подложки к нашим единицам
        const scale = this.fontData.unitsPerEm / metrics.unitsPerEm;
        
        // 2. Baseline всегда на высоте unitsPerEm (1000)
        const baselineY = this.fontData.unitsPerEm;
        
        // 3. Для подложки используем baseline positioning
        textElement.setAttribute('x', leftX);
        textElement.setAttribute('y', baselineY);
        textElement.setAttribute('dominant-baseline', 'alphabetic');
        
        
    } else {
        // Без метрик - старый метод
        textElement.setAttribute('x', leftX);
        textElement.setAttribute('y', this.guidelines.baseline);
    }
    
    textElement.setAttribute('text-anchor', 'start');
    textElement.setAttribute('fill', 'rgba(136, 136, 136, 0.15)');
}

			// Переключение отображения подложки
			toggleUnderlay() {
				const showUnderlay = document.getElementById('show-underlay').checked;
				
				const svgUnderlay = document.getElementById('underlay-svg');
				if (svgUnderlay) {
					svgUnderlay.remove();
				}
				
				if (showUnderlay && this.state.underlayFont && this.currentGlyph) {
					setTimeout(() => {
						this.createSVGUnderlay();
					}, 100);
				}
			}

			// Переключение контрольных точек
			toggleControlPoints() {
				const showControls = document.getElementById('show-controls').checked;
				const controlGroup = document.getElementById('control-group');
				
				if (controlGroup) {
					// Показываем/скрываем контрольные точки и линии
					controlGroup.querySelectorAll('.control-point, .control-line').forEach(el => {
						el.style.display = showControls ? '' : 'none';
					});
				}
				
				// Если контрольные точки скрыты, снимаем выделение с контрольных точек
				if (!showControls && this.state.draggingPoint && this.state.draggingPoint.isControlPoint) {
					this.state.draggingPoint.element.classList.remove('selected');
					this.state.draggingPoint = null;
				}
			}

			// Переключение направляющих
			toggleGuidelines() {
				if (this.currentGlyph) {
					this.renderGlyph();
				} else {
					const guidelineGroup = document.getElementById('guideline-group');
					if (guidelineGroup) {
						if (document.getElementById('show-guidelines').checked) {
							this.renderGuidelines();
						} else {
							guidelineGroup.innerHTML = '';
						}
					}
				}
			}

			// Добавление горизонтальной направляющей
			addHorizontalGuideline() {
				const svgCanvas = document.getElementById('svg-canvas');
				const bbox = svgCanvas.getBBox ? svgCanvas.getBBox() : { y: 0, height: 1000 };
				const centerY = bbox.y + bbox.height / 2;
				
				this.addCustomGuideline('horizontal', centerY);
			}

			// Добавление вертикальной направляющей
			addVerticalGuideline() {
				const svgCanvas = document.getElementById('svg-canvas');
				const bbox = svgCanvas.getBBox ? svgCanvas.getBBox() : { x: 0, width: 1000 };
				const centerX = bbox.x + bbox.width / 2;
				
				this.addCustomGuideline('vertical', centerX);
			}

			// Добавление пользовательской направляющей
			addCustomGuideline(type, position) {
				const id = 'guide_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
				
				this.guidelines.custom.push({
					type: type,
					position: position,
					id: id
				});
				
				this.renderGuidelines();
				this.updateCustomGuidelinesList();
			}

			// Очистка пользовательских направляющих
async clearCustomGuidelines() {
    const confirmed = await this.showConfirmDialog(
        'Удалить все пользовательские направляющие?',
        'Очистка направляющих'
    );
    
    if (!confirmed) return;
    
    this.guidelines.custom = [];
    this.renderGuidelines();
    this.updateCustomGuidelinesList();
}

			// Обновление списка пользовательских направляющих
			updateCustomGuidelinesList() {
				const list = document.getElementById('custom-guidelines');
				list.innerHTML = '';
				
				this.guidelines.custom.forEach((guide, index) => {
					const item = document.createElement('div');
					item.className = 'guideline-item';
					item.innerHTML = `
						<span>${guide.type === 'horizontal' ? 'Гориз.' : 'Верт.'}: ${Math.round(guide.position)}</span>
						<button class="secondary" data-index="${index}"><i class="fas fa-trash"></i></button>
					`;
					
					const deleteBtn = item.querySelector('button');
					deleteBtn.addEventListener('click', (e) => {
						e.stopPropagation();
						this.guidelines.custom.splice(index, 1);
						this.renderGuidelines();
						this.updateCustomGuidelinesList();
					});
					
					list.appendChild(item);
				});
			}

			// ====================================================
			// ФУНКЦИИ ИНСТРУМЕНТА УДАЛЕНИЯ ВЕКТОРОВ (ИСПРАВЛЕННЫЕ)

			// Создание линии удаления
			createDeleteVectorLine(x1, y1, x2, y2) {
				const svgNS = "http://www.w3.org/2000/svg";
				const svgCanvas = document.getElementById('svg-canvas');
				
				this.removeDeleteVectorLine();
				
				const line = document.createElementNS(svgNS, 'line');
				line.setAttribute('x1', x1);
				line.setAttribute('y1', y1);
				line.setAttribute('x2', x2);
				line.setAttribute('y2', y2);
				line.setAttribute('stroke', '#ff0000');
				line.setAttribute('stroke-width', '2');
				line.setAttribute('stroke-dasharray', '5,3');
				line.setAttribute('class', 'delete-vector-line');
				line.id = 'temp-delete-vector';
				
				svgCanvas.appendChild(line);
				this.state.deleteVectorTempLine = line;
			}

			// Обновление линии удаления
			updateDeleteVectorLine(x1, y1, x2, y2) {
				const line = document.getElementById('temp-delete-vector');
				if (line) {
					line.setAttribute('x1', x1);
					line.setAttribute('y1', y1);
					line.setAttribute('x2', x2);
					line.setAttribute('y2', y2);
				}
			}

			// Удаление линии удаления
			removeDeleteVectorLine() {
				const line = document.getElementById('temp-delete-vector');
				if (line) {
					line.remove();
					this.state.deleteVectorTempLine = null;
				}
			}

			// Удаление пересекаемых элементов
deleteIntersectingElements(x1, y1, x2, y2) {
    let found = false;
    let affectedContours = new Set();
    
    for (let contourIndex = 0; contourIndex < this.pathTopology.contours.length; contourIndex++) {
        const contour = this.pathTopology.contours[contourIndex];
        if (!contour || !contour.segments) continue;
        
        for (let segmentIndex = contour.segments.length - 1; segmentIndex >= 0; segmentIndex--) {
            const segment = contour.segments[segmentIndex];
            const startPoint = contour.points[segment.startIndex];
            const endPoint = contour.points[segment.endIndex];
            
            if (!startPoint || !endPoint) continue;
            
            let intersects = false;
            
            if (segment.type === 'line') {
                // Старая проверка для линий
                intersects = this.checkCrossing(x1, y1, x2, y2, 
                    startPoint.x, startPoint.y, 
                    endPoint.x, endPoint.y);
            } 
            else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
                // Новая проверка для кривых Безье
                // Используем дискретизацию
                intersects = this.checkBezierIntersection(x1, y1, x2, y2,
                    startPoint, segment.control1, segment.control2, endPoint);
            }
            
            if (intersects) {
                this.deleteSegment(contourIndex, segmentIndex);
                found = true;
                affectedContours.add(contour);
            }
        }
    }
    
    if (found) {
        this.updatePathFromTopology();
        affectedContours.forEach(contour => {
            this.updatePointTypesInContour(contour);
        });
        this.renderAllControlElements();
    }
}

checkBezierIntersection(lx1, ly1, lx2, ly2, p0, p1, p2, p3) {
    // Разбиваем кривую на 20 отрезков
    for (let i = 0; i < 20; i++) {
        const t1 = i / 20;
        const t2 = (i + 1) / 20;
        
        // Точки на кривой (используем твою существующую функцию)
        const point1 = this.getPointOnBezier(t1, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        const point2 = this.getPointOnBezier(t2, p0.x, p0.y, p1.x, p1.y, p2.x, p2.y, p3.x, p3.y);
        
        // Используем существующую checkCrossing
        if (this.checkCrossing(lx1, ly1, lx2, ly2, point1.x, point1.y, point2.x, point2.y)) {
            return true;
        }
    }
    
    return false;
}

			// Проверка пересечения двух отрезков
			checkCrossing(x1, y1, x2, y2, x3, y3, x4, y4) {
				const denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
				if (Math.abs(denominator) < 0.0001) return false;
				
				const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;
				const u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;
				
				return t >= 0 && t <= 1 && u >= 0 && u <= 1;
			}

			// Удаление сегмента

deleteSegment(contourIndex, segmentIndex) {
    
    const contour = this.pathTopology.contours[contourIndex];
    if (!contour || !contour.segments[segmentIndex]) return;
    
    const segment = contour.segments[segmentIndex];
    
    // 1. Сохраняем информацию о сегменте до удаления
    const startIndex = segment.startIndex;
    const endIndex = segment.endIndex;
        
    // 2. Удаляем визуальные элементы (контрольные точки и линии)
    this.removeControlPointsForSegment(contourIndex, segmentIndex);
    
    // 3. Удаляем сегмент из массива
    contour.segments.splice(segmentIndex, 1);
    
    // 4. ВСЕГДА пытаемся разделить контур после удаления сегмента
    this.splitContourIfDisconnected(contourIndex, startIndex, endIndex);
        
    // 5. Пересчитываем типы точек во ВСЕХ контурах
    this.updateAllPointTypes();
    
    // 6. Обновляем путь
    this.updatePathFromTopology();
    
    // 7. Перерисовываем контрольные элементы
    if (document.getElementById('show-controls').checked) {
        this.renderAllControlElements();
    }
}

// Упрощенная версия: всегда пытается разделить контур
splitContourIfDisconnected(originalContourIndex, pointAIndex, pointBIndex) {
    const originalContour = this.pathTopology.contours[originalContourIndex];
    if (!originalContour || originalContour.segments.length === 0) return;
        
    // Находим все точки, достижимые из pointAIndex (BFS)
    const visited = new Set();
    const queue = [pointAIndex];
    visited.add(pointAIndex);
    
    while (queue.length > 0) {
        const currentPoint = queue.shift();
        
        // Находим все сегменты, связанные с текущей точкой
        originalContour.segments.forEach(segment => {
            if (segment.startIndex === currentPoint && !visited.has(segment.endIndex)) {
                visited.add(segment.endIndex);
                queue.push(segment.endIndex);
            } else if (segment.endIndex === currentPoint && !visited.has(segment.startIndex)) {
                visited.add(segment.startIndex);
                queue.push(segment.startIndex);
            }
        });
    }
    
    // Если все точки посещены - контур остался связным, разделение не требуется
    if (visited.size === originalContour.points.length) {
        return;
    }
        
    // Создаем новый контур для группы B (непосещенные точки)
    const newContour = {
        points: [],
        segments: [],
        isClosed: false
    };
    
    // Определяем, какие точки в группе B
    const pointsInGroupA = Array.from(visited);
    const pointsInGroupB = [];
    
    for (let i = 0; i < originalContour.points.length; i++) {
        if (!visited.has(i)) {
            pointsInGroupB.push(i);
        }
    }
    
    // Разделяем точки и сегменты
    this.performContourSplit(originalContourIndex, pointsInGroupA, pointsInGroupB);
}

// Фактическое разделение контура
performContourSplit(originalContourIndex, pointsInGroupA, pointsInGroupB) {
    const originalContour = this.pathTopology.contours[originalContourIndex];
    
    // Создаем новый контур для группы B
    const newContour = {
        points: [],
        segments: [],
        isClosed: false
    };
    
    // 1. Перемещаем точки группы B в новый контур
    const oldToNewIndexMap = new Map();
    
    pointsInGroupB.forEach((oldIndex, newIndex) => {
        const point = originalContour.points[oldIndex];
        if (point) {
            // Копируем точку с новым индексом
            const newPoint = { ...point, index: newIndex, contourIndex: this.pathTopology.contours.length };
            newContour.points.push(newPoint);
            oldToNewIndexMap.set(oldIndex, newIndex);
            
            // Обновляем элемент SVG
            if (point.element) {
                point.element.setAttribute('data-contour-index', this.pathTopology.contours.length);
                point.element.setAttribute('data-point-index', newIndex);
            }
        }
    });
    
    // 2. Перемещаем сегменты группы B в новый контур
    originalContour.segments.forEach((seg, segIndex) => {
        const isInGroupB = pointsInGroupB.includes(seg.startIndex) && pointsInGroupB.includes(seg.endIndex);
        
        if (isInGroupB) {
            // Преобразуем индексы для нового контура
            const newSeg = { ...seg };
            newSeg.startIndex = oldToNewIndexMap.get(seg.startIndex);
            newSeg.endIndex = oldToNewIndexMap.get(seg.endIndex);
            newContour.segments.push(newSeg);
        }
    });
    
    // 3. Удаляем точки группы B из оригинального контура
    originalContour.points = originalContour.points.filter((point, pointIndex) => 
        pointsInGroupA.includes(pointIndex)
    );
    
    // 4. Удаляем сегменты группы B из оригинального контура
    originalContour.segments = originalContour.segments.filter((seg, segIndex) => {
        const isInGroupA = pointsInGroupA.includes(seg.startIndex) && pointsInGroupA.includes(seg.endIndex);
        return isInGroupA;
    });
    
    // 5. Обновляем индексы в оригинальном контуре
    originalContour.points.forEach((point, newIndex) => {
        point.index = newIndex;
        if (point.element) {
            point.element.setAttribute('data-point-index', newIndex);
        }
    });
    
    // 6. Обновляем индексы сегментов в оригинальном контуре
    originalContour.segments.forEach(seg => {
        seg.startIndex = pointsInGroupA.indexOf(seg.startIndex);
        seg.endIndex = pointsInGroupA.indexOf(seg.endIndex);
    });
    
    // 7. Добавляем новый контур
    this.pathTopology.contours.push(newContour);
        
    // 8. Проверяем, не стал ли один из контуров пустым
    if (originalContour.points.length === 0) {
        this.pathTopology.contours.splice(originalContourIndex, 1);
    }
}

			updateAllPointTypes() {
				this.pathTopology.contours.forEach(contour => {
					this.updatePointTypesInContour(contour);
				});
			}
			// ===================================================
			// ФУНКЦИИ ПЕРЕТАСКИВАНИЯ НАПРАВЛЯЮЩИХ (ИСПРАВЛЕННЫЕ)

			// Начало перетаскивания направляющей
			startGuidelineDrag(guideline) {
				const type = guideline.classList.contains('horizontal') ? 'horizontal' : 'vertical';
				const position = type === 'horizontal' ? 
					parseFloat(guideline.getAttribute('y1')) : 
					parseFloat(guideline.getAttribute('x1'));
				const id = guideline.getAttribute('data-id');
				
				this.state.draggingGuideline = {
					element: guideline,
					type: type,
					position: position,
					id: id
				};
				
				guideline.classList.add('dragging');
			}

			// Обновление перетаскивания направляющей
			updateGuidelineDrag(x, y) {
				if (!this.state.draggingGuideline) return;
				
				const guideline = this.state.draggingGuideline;
				
				if (guideline.type === 'horizontal') {
					const newY = y;
					guideline.element.setAttribute('y1', newY);
					guideline.element.setAttribute('y2', newY);
					this.updateGuidelinePosition(guideline.id, newY, 'horizontal');
				} else {
					const newX = x;
					guideline.element.setAttribute('x1', newX);
					guideline.element.setAttribute('x2', newX);
					this.updateGuidelinePosition(guideline.id, newX, 'vertical');
				}
			}

			// Завершение перетаскивания направляющей
			endGuidelineDrag() {
				if (!this.state.draggingGuideline) return;
				
				const guideline = this.state.draggingGuideline;
				
				// Обновляем список пользовательских направляющих
				this.updateCustomGuidelinesList();
				
				// Сохраняем изменения для правой направляющей
				if (guideline.id === 'right' && this.currentGlyph) {
					this.currentGlyph.horizAdvX = Math.round(this.guidelines.right);
					this.updatePropertiesPanel();
				}
				
				if (guideline.id === 'right') {
					document.getElementById('right-guide').value = Math.round(this.guidelines.right);
				}
			}

			// Обновление позиции направляющей
			updateGuidelinePosition(id, position, type) {
				switch(id) {
					case 'top':
						this.guidelines.top = position;
						document.getElementById('top-guide').textContent = Math.round(position);
						break;
					case 'bottom':
						this.guidelines.bottom = position;
						document.getElementById('bottom-guide').textContent = Math.round(position);
						break;
					case 'left':
						this.guidelines.left = position;
						document.getElementById('left-guide').value = Math.round(position);
						break;
					case 'right':
						this.guidelines.right = position;
						document.getElementById('right-guide').value = Math.round(position);
						break;
					case 'baseline':
						this.guidelines.baseline = position;
						break;
					default:
						// Пользовательская направляющая
						const customGuide = this.guidelines.custom.find(g => g.id === id);
						if (customGuide) {
							customGuide.position = position;
						}
				}
			}

			// Удаление направляющей
			deleteGuideline(guidelineElement) {
				const id = guidelineElement.getAttribute('data-id');
				
				// Правая направляющая не удаляется
				if (id === 'right') {
					alert('Правую направляющую нельзя удалить');
					return;
				}
				
				if (id.startsWith('guide_')) {
					// Пользовательская направляющая
					const index = this.guidelines.custom.findIndex(g => g.id === id);
					if (index !== -1) {
						this.guidelines.custom.splice(index, 1);
						this.renderGuidelines();
						this.updateCustomGuidelinesList();
					}
				} else {
					// Базовая направляющая - сброс к значениям по умолчанию
					switch(id) {
						case 'top':
							this.guidelines.top = this.fontData.unitsPerEm - this.fontData.ascent;
							break;
						case 'bottom':
							this.guidelines.bottom = this.fontData.unitsPerEm - this.fontData.descent;
							break;
						case 'left':
							this.guidelines.left = 0;
							break;
						case 'baseline':
							this.guidelines.baseline = this.fontData.unitsPerEm;
							break;
					}
					this.renderGuidelines();
					this.updateGuidelineControls();
				}
			}

			// ==============================================
			// ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ ДЛЯ ВРЕМЕННЫХ ЭЛЕМЕНТОВ

			// Создание временной направляющей
			createTemporaryGuideline(x, y) {
				const svgNS = "http://www.w3.org/2000/svg";
				const svgCanvas = document.getElementById('svg-canvas');
				
				this.removeTemporaryGuideline();
				
				const line = document.createElementNS(svgNS, 'line');
				line.setAttribute('x1', x);
				line.setAttribute('y1', y);
				line.setAttribute('x2', x);
				line.setAttribute('y2', y);
				line.setAttribute('stroke', '#888');
				line.setAttribute('stroke-width', '1');
				line.setAttribute('stroke-dasharray', '5,3');
				line.setAttribute('class', 'temporary-guideline');
				line.id = 'temp-guideline';
				
				svgCanvas.appendChild(line);
			}

			// Обновление временной направляющей
			updateTemporaryGuideline(x1, y1, x2, y2) {
				const line = document.getElementById('temp-guideline');
				if (line) {
					line.setAttribute('x1', x1);
					line.setAttribute('y1', y1);
					line.setAttribute('x2', x2);
					line.setAttribute('y2', y2);
				}
			}

			// Удаление временной направляющей
			removeTemporaryGuideline() {
				const line = document.getElementById('temp-guideline');
				if (line) {
					line.remove();
				}
			}

			// Сохранение пути в глиф
			savePathToGlyph() {
				if (!this.currentGlyph) return;
				
				let pathData = '';
				
				// Строим путь из всех контуров
				this.pathTopology.contours.forEach((contour) => {
					if (!contour.segments || contour.segments.length === 0) {
						// Если нет сегментов, но есть точки
						if (contour.points.length > 0) {
							contour.points.forEach((point, i) => {
								if (i === 0) {
									pathData += `M ${point.x} ${point.y} `;
								} else {
									pathData += `L ${point.x} ${point.y} `;
								}
							});
						}
						return;
					}
					
					// Сортируем сегменты для правильного порядка
					const sortedSegments = this.sortSegmentsForPath(contour);
					
					sortedSegments.forEach((segment, segmentIndex) => {
						const startPoint = contour.points[segment.startIndex];
						const endPoint = contour.points[segment.endIndex];
						
						if (!startPoint || !endPoint) return;
						
						// Для первого сегмента добавляем M
						if (segmentIndex === 0) {
							pathData += `M ${startPoint.x} ${startPoint.y} `;
						}
						
						// Добавляем команду в зависимости от типа
						if (segment.type === 'line') {
							pathData += `L ${endPoint.x} ${endPoint.y} `;
						} else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
							pathData += `C ${segment.control1.x} ${segment.control1.y} `;
							pathData += `${segment.control2.x} ${segment.control2.y} `;
							pathData += `${endPoint.x} ${endPoint.y} `;
						}
						
						// Замыкаем контур если нужно
						if (contour.isClosed && segmentIndex === sortedSegments.length - 1) {
							pathData += 'Z ';
						}
					});
				});
				
				this.currentGlyph.d = pathData.trim();
			}

			// Сортировка сегментов для правильного построения пути
			sortSegmentsForPath(contour) {
				if (!contour.segments || contour.segments.length === 0) return [];
				
				const sorted = [];
				const visited = new Set();
				
				// Начинаем с первого сегмента
				let currentSegment = contour.segments[0];
				sorted.push(currentSegment);
				visited.add(0);
				
				// Строим цепочку
				while (sorted.length < contour.segments.length) {
					let foundNext = false;
					
					for (let i = 0; i < contour.segments.length; i++) {
						if (visited.has(i)) continue;
						
						const segment = contour.segments[i];
						const lastSegment = sorted[sorted.length - 1];
						
						if (segment.startIndex === lastSegment.endIndex) {
							sorted.push(segment);
							visited.add(i);
							foundNext = true;
							break;
						}
					}
					
					if (!foundNext) break;
				}
				
				return sorted;
			}

			// ============================
			// ФУНКЦИИ ОБНОВЛЕНИЯ ИНДЕКСОВ

			// Удаление контрольных точек для сегмента
removeControlPointsForSegment(contourIndex, segmentIndex) {
    const controlGroup = document.getElementById('control-group');
    if (!controlGroup) return;
    
    // Удаляем контрольные точки этого сегмента
    const controlPoints = controlGroup.querySelectorAll('.control-point');
    controlPoints.forEach(cp => {
        const cpSegmentIndex = parseInt(cp.getAttribute('data-segment-index') || '-1');
        const cpContourIndex = parseInt(cp.getAttribute('data-contour-index') || '-1');
        
        if (cpSegmentIndex === segmentIndex && cpContourIndex === contourIndex) {
            // Удаляем линии, связанные с этой контрольной точкой
            const lines = controlGroup.querySelectorAll('.control-line');
            lines.forEach(line => {
                const lineSegmentIndex = parseInt(line.getAttribute('data-segment-index') || '-1');
                if (lineSegmentIndex === segmentIndex) {
                    line.remove();
                }
            });
            
            cp.remove();
        }
    });
}

		// ==================================================
			// ИСПРАВЛЕННЫЕ ФУНКЦИИ РАБОТЫ С ТОЧКАМИ И СЕГМЕНТАМИ

			// Исправленная функция продолжения контура от выделенной точки
continueContourFromSelectedPoint(x, y, controlGroup) {
    
    const selected = this.state.selectedPoint;
    if (!selected || !selected.element) return;
    
    const contour = this.pathTopology.contours[selected.contourIndex];
    if (!contour) return;
    
    const pointType = selected.pointType || selected.element.getAttribute('data-point-type');
    
    // Если это средняя точка (middle) - создаем новую изолированную
    if (pointType === 'middle') {
        this.createNewContourFromPoint(selected.x, selected.y, controlGroup);
        return;
    }
    
    const fromPoint = contour.points[selected.pointIndex];
    const distance = Math.sqrt(Math.pow(x - fromPoint.x, 2) + Math.pow(y - fromPoint.y, 2));
    
    if (distance < 5) return;
    
    // 1. Находим ВСЕ связанные сегменты
    const connectedSegments = this.findConnectedSegmentsInContour(contour, selected.pointIndex);
    
    const hasOutgoing = connectedSegments.some(s => s.isStart);
    const hasIncoming = connectedSegments.some(s => !s.isStart);
    
    let isAddingToEnd;
    
    if (hasIncoming && !hasOutgoing) {
        // Только входящие → конец цепочки → добавляем в конец
        isAddingToEnd = true;
    } else if (!hasIncoming && hasOutgoing) {
        // Только исходящие → начало цепочки → добавляем в начало
        isAddingToEnd = false;
    } else if (!hasIncoming && !hasOutgoing) {
        // Изолированная точка → добавляем в конец (создаем новый контур)
        isAddingToEnd = true;
    } else {
        // И входящие, и исходящие → средняя точка (не должно сюда попадать)
        console.warn("Точка имеет и входящие, и исходящие связи");
        isAddingToEnd = true;
    }
    
    // 3. Определяем тип нового сегмента
    let newSegmentType = 'line';
    
    // НАХОДИМ ПРАВИЛЬНЫЙ СЕГМЕНТ ДЛЯ ПРОДОЛЖЕНИЯ
    let segmentToContinue = null;
    
    if (isAddingToEnd) {
        // Добавляем в конец → смотрим на ВХОДЯЩИЙ сегмент
        segmentToContinue = connectedSegments.find(s => !s.isStart);
    } else {
        // Добавляем в начало → смотрим на ИСХОДЯЩИЙ сегмент
        segmentToContinue = connectedSegments.find(s => s.isStart);
    }
    
    if (segmentToContinue && segmentToContinue.segment.type === 'bezier') {
        newSegmentType = 'bezier';
    }
    
    // 4. Создаем новую точку
    const pointElement = this.createControlPoint(x, y, 'point', controlGroup);
    
    let newPointIndex;
    let newPoint;
    let newSegment;
    let oldPointIndexForSmoothing = selected.pointIndex;
    // 5. Если добавляем в НАЧАЛО цепочки
    if (!isAddingToEnd) {
        // Сдвигаем все индексы на +1
        contour.points.forEach((point, idx) => {
            point.index = idx + 1;
            if (point.element) {
                point.element.setAttribute('data-point-index', idx + 1);
            }
        });
        
        // Обновляем индексы в сегментах
        contour.segments.forEach(segment => {
            segment.startIndex += 1;
            segment.endIndex += 1;
        });
        
        // Новая точка имеет индекс 0
        newPointIndex = 0;
        
        newPoint = {
            element: pointElement,
            index: newPointIndex,
            contourIndex: selected.contourIndex,
            x: x,
            y: y,
            isBezier: newSegmentType === 'bezier'
        };
        
        // Добавляем в начало массива
        contour.points.unshift(newPoint);
        
        // Создаем сегмент: новая точка → старая начальная точка
        // ОБРАТИТЕ ВНИМАНИЕ: направление от новой точки (0) к старой точке (1)
        newSegment = {
            startIndex: 0, // новая точка
            endIndex: 1,   // старая начальная точка (теперь с индексом 1)
            type: newSegmentType,
            control1: null,
            control2: null
        };
        
        // При добавлении в начало, старая точка теперь имеет индекс 1
        oldPointIndexForSmoothing = 1;
        
    } 
    // 6. Если добавляем в КОНЕЦ цепочки
    else {
        
        newPointIndex = contour.points.length;
        
        newPoint = {
            element: pointElement,
            index: newPointIndex,
            contourIndex: selected.contourIndex,
            x: x,
            y: y,
            isBezier: newSegmentType === 'bezier'
        };
        
        contour.points.push(newPoint);
        
        // Создаем сегмент: старая точка → новая точка
        newSegment = {
            startIndex: selected.pointIndex,
            endIndex: newPointIndex,
            type: newSegmentType,
            control1: null,
            control2: null
        };
    }
    
    // 7. Если новый сегмент - кривая Безье, создаем начальные контрольные точки
    if (newSegmentType === 'bezier') {
        const startPt = contour.points[newSegment.startIndex];
        const endPt = contour.points[newSegment.endIndex];
        
        if (startPt && endPt) {
            const dx = endPt.x - startPt.x;
            const dy = endPt.y - startPt.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            
            if (length > 0.001) {
                const nx = dx / length;
                const ny = dy / length;
                const curveAmount = length * 0.39;
                
                // Простые контрольные точки вдоль направления
                newSegment.control1 = {
                    x: startPt.x + nx * curveAmount,
                    y: startPt.y + ny * curveAmount
                };
                
                newSegment.control2 = {
                    x: endPt.x - nx * curveAmount,
                    y: endPt.y - ny * curveAmount
                };
            }
        }
    }
    
    // 8. Устанавливаем атрибуты
    pointElement.setAttribute('data-contour-index', selected.contourIndex);
    pointElement.setAttribute('data-point-index', newPointIndex);
    
    // 9. Добавляем сегмент
    if (!contour.segments) contour.segments = [];
    contour.segments.push(newSegment);
    
    // 10. Обновляем все
    this.updatePointTypesInContour(contour);
    this.updatePathFromTopology();
    
    // 11. Выделяем новую точку
    if (fromPoint.element) {
        fromPoint.element.classList.remove('selected');
    }
    pointElement.classList.add('selected');
    
    this.state.selectedPoint = {
        element: pointElement,
        x: x,
        y: y,
        contourIndex: selected.contourIndex,
        pointIndex: newPointIndex,
        pointType: 'end'
    };
    
    // 12. АВТОМАТИЧЕСКОЕ ВЫРАВНИВАНИЕ БЕЗЬЕ
    if (newSegmentType === 'bezier') {
        setTimeout(() => {
            // Находим ВСЕ сегменты, связанные со СТАРОЙ точкой
            const allSegmentsAtOldPoint = this.findConnectedSegmentsInContour(contour, oldPointIndexForSmoothing);
            
            // Должно быть 2 сегмента (старый существующий и новый)
            if (allSegmentsAtOldPoint.length === 2) {
                // Используем ВАШУ существующую функцию для сглаживания
                this.convertToSmoothBezier(contour, oldPointIndexForSmoothing, allSegmentsAtOldPoint);
                
                // Обновляем отображение
                this.updatePathFromTopology();
                this.renderAllControlElements();
                this.updatePointTypesInContour(contour);
            }
        }, 50);
    } else {
        // Для линий просто обновляем отображение
        if (document.getElementById('show-controls').checked) {
            this.renderAllControlElements();
        }
    }
    
    this.updateSegmentButtons();
}

			// Исправленная функция создания нового контура
createNewContourFromPoint(x, y, controlGroup) {
    
    const newContourIndex = this.pathTopology.contours.length;
    
    // Создаем новый контур
    const newContour = {
        points: [],
        segments: [], // ПУСТОЙ массив сегментов
        isClosed: false
    };
    
    // Создаем первую точку
    const pointElement = this.createControlPoint(x, y, 'point', controlGroup);
    const point = {
        element: pointElement,
        index: 0,
        contourIndex: newContourIndex,
        x: x,
        y: y,
        isBezier: false
    };
    
    newContour.points.push(point);
    pointElement.setAttribute('data-contour-index', newContourIndex);
    pointElement.setAttribute('data-point-index', 0);
    
    // Добавляем контур в топологию
    this.pathTopology.contours.push(newContour);
    
    // Обновляем типы (точка будет 'isolated')
    this.updatePointTypesInContour(newContour);
    
    // Выделяем точку
    pointElement.classList.add('selected');
    this.state.selectedPoint = {
        element: pointElement,
        x: x,
        y: y,
        contourIndex: newContourIndex,
        pointIndex: 0
    };
    
    // Обновляем путь (пустой, так как нет сегментов)
    this.updatePathFromTopology();
        
    return pointElement;
}

addPointAtPosition(x, y) {
    if (!this.currentGlyph) return;
    
    const controlGroup = document.getElementById('control-group');
    
    // Сохраняем состояние ДО добавления точки
    const previousState = {
        fontData: JSON.parse(JSON.stringify(this.fontData)),
        pathTopology: JSON.parse(JSON.stringify(this.pathTopology)),
        currentGlyphUnicode: this.currentGlyph.unicode
    };
    
    // 1. Если есть выделенная точка - продолжаем от нее
    if (this.state.selectedPoint && this.state.selectedPoint.element) {
        this.continueContourFromSelectedPoint(x, y, controlGroup);
        
        // Сохраняем в историю ПОСЛЕ добавления
        setTimeout(() => {
            this.saveToHistoryWithPreviousState('add_point', 'Добавление точки', previousState);
        }, 10);
        
        return;
    }
    
    // 2. Проверяем сегменты для разделения (если эта функция есть)
    try {
        const closestSegment = this.findClosestSegment(x, y);
        if (closestSegment && closestSegment.distance < 15) {
            this.splitSegmentAtPoint(closestSegment, x, y, controlGroup);
            
            // Сохраняем в историю ПОСЛЕ разделения
            setTimeout(() => {
                this.saveToHistoryWithPreviousState('split_segment', 'Разделение сегмента точкой', previousState);
            }, 10);
            
            return;
        }
    } catch (e) {
        console.log("Ошибка при проверке сегментов:", e);
    }
    
    // 3. Создаем новую изолированную точку
    this.createNewContourFromPoint(x, y, controlGroup);
    
    // Сохраняем в историю ПОСЛЕ создания
    setTimeout(() => {
        this.saveToHistoryWithPreviousState('create_point', 'Создание изолированной точки', previousState);
    }, 10);
}

saveToHistoryWithPreviousState(action, description, previousState) {
    // Если мы не в конце истории, удаляем все после текущего индекса
    if (this.history.currentIndex < this.history.actions.length - 1) {
        this.history.actions = this.history.actions.slice(0, this.history.currentIndex + 1);
    }
    
    // Сохраняем состояние с предыдущим состоянием для отмены
    const state = {
        action,
        description,
        timestamp: Date.now(),
        fontData: JSON.parse(JSON.stringify(this.fontData)),
        pathTopology: JSON.parse(JSON.stringify(this.pathTopology)),
        currentGlyphUnicode: this.currentGlyph ? this.currentGlyph.unicode : null,
        guidelines: JSON.parse(JSON.stringify(this.guidelines)),
        // Сохраняем предыдущее состояние для точной отмены
        previousState: previousState
    };
    
    // Добавляем в историю
    this.history.actions.push(state);
    
    // Ограничиваем размер истории
    if (this.history.actions.length > this.history.maxHistory) {
        this.history.actions.shift();
    }
    
    // Обновляем индекс
    this.history.currentIndex = this.history.actions.length - 1;
    
    console.log(`Сохранено в историю: ${description}`);
}

			// Исправленная функция разделения сегмента
splitSegmentAtPoint(segmentInfo, x, y, controlGroup) {
    const contour = this.pathTopology.contours[segmentInfo.contourIndex];
    if (!contour) return;
    
    const segment = contour.segments[segmentInfo.segmentIndex];
    if (!segment) return;
    
    
    const startPoint = contour.points[segment.startIndex];
    const endPoint = contour.points[segment.endIndex];
    
    if (!startPoint || !endPoint) return;
    
    // ВАЖНО: вставляем точку между startIndex и endIndex
    // Новая точка получает индекс endIndex, а старая endIndex сдвигается
    
    const insertPosition = segment.endIndex; // Вставляем ПЕРЕД endPoint
        
    // 1. СДВИГАЕМ все точки начиная с insertPosition
    for (let i = contour.points.length - 1; i >= insertPosition; i--) {
        const point = contour.points[i];
        point.index = i + 1; // Увеличиваем индекс на 1
        if (point.element) {
            point.element.setAttribute('data-point-index', i + 1);
        }
    }
    
    // 2. СДВИГАЕМ все ссылки в сегментах
    contour.segments.forEach(s => {
        if (s.startIndex >= insertPosition) s.startIndex++;
        if (s.endIndex >= insertPosition) s.endIndex++;
    });
    
    // 3. Обновляем текущий сегмент (пока он еще ссылается на старые индексы)
    segment.endIndex = insertPosition; // Теперь он ведет к новой точке
    
    // 4. СОЗДАЕМ новую точку
    const newPointIndex = insertPosition;
    const newPointElement = this.createControlPoint(x, y, 'point', controlGroup);
    
    const newPoint = {
        element: newPointElement,
        index: newPointIndex,
        contourIndex: segmentInfo.contourIndex,
        x: x,
        y: y,
        isBezier: segment.type === 'bezier',
        pointType: 'middle' // В середине всегда middle
    };
    
    // 5. ВСТАВЛЯЕМ точку в массив
    contour.points.splice(insertPosition, 0, newPoint);
    newPointElement.setAttribute('data-contour-index', segmentInfo.contourIndex);
    newPointElement.setAttribute('data-point-index', newPointIndex);
    
    // 6. СОЗДАЕМ второй сегмент (от новой точки к старому endPoint)
    const segment2 = {
        startIndex: newPointIndex,
        endIndex: segment.endIndex + 1, // Старый endPoint теперь с индексом +1
        type: segment.type,
        control1: null,
        control2: null
    };
    
    // Для кривых Безье нужно разделить контрольные точки
    if (segment.type === 'bezier' && segment.control1 && segment.control2) {
        const t = segmentInfo.t || 0.5;
        const splitResult = this.splitBezierAtT(
            startPoint.x, startPoint.y,
            segment.control1.x, segment.control1.y,
            segment.control2.x, segment.control2.y,
            endPoint.x, endPoint.y,
            t
        );
        
        // Обновляем контрольные точки первого сегмента
        segment.control1 = splitResult.left.cp1;
        segment.control2 = splitResult.left.cp2;
        
        // Устанавливаем контрольные точки второго сегмента
        segment2.control1 = splitResult.right.cp1;
        segment2.control2 = splitResult.right.cp2;
        
        newPoint.isBezier = true;
    }
    
    // 7. Добавляем второй сегмент в массив
    contour.segments.splice(segmentInfo.segmentIndex + 1, 0, segment2);
    
    // 8. Обновляем типы точек (новая точка будет middle)
    this.updatePointTypesInContour(contour);
    
    // 9. Выделяем новую точку
    newPointElement.classList.add('selected');
    this.state.selectedPoint = {
        element: newPointElement,
        x: x,
        y: y,
        contourIndex: segmentInfo.contourIndex,
        pointIndex: newPointIndex,
        pointType: 'middle'
    };
    
    // 10. Обновляем все
    this.updatePathFromTopology();
    this.renderAllControlElements();
}

// Главная функция удаления точки

deleteControlPointOnly(contour, controlPointElement) {
    // Просто удаляем контрольную точку Безье
    const segmentIndex = parseInt(controlPointElement.getAttribute('data-segment-index'));
    const isControl1 = controlPointElement.getAttribute('data-is-control1') === 'true';
    
    const segment = contour.segments[segmentIndex];
    if (!segment || segment.type !== 'bezier') return;
    
    if (isControl1) {
        segment.control1 = null;
    } else {
        segment.control2 = null;
    }
    
    // Если обе контрольные точки удалены - делаем линию
    if (!segment.control1 && !segment.control2) {
        segment.type = 'line';
    }
    
    controlPointElement.remove();
    this.updatePathFromTopology();
}

renderAllControlElements() {
    const controlGroup = document.getElementById('control-group');
    if (!controlGroup) return;
    
    // Очищаем (на всякий случай)
    controlGroup.querySelectorAll('.control-point, .control-line').forEach(el => el.remove());
    
    // Проверяем, показывать ли контрольные точки
    const showControls = document.getElementById('show-controls').checked;
    
    // Рисуем контрольные точки для кривых Безье
    this.pathTopology.contours.forEach((contour, contourIndex) => {
        if (!contour.segments) return;
        
        contour.segments.forEach((segment, segmentIndex) => {
            if (segment.type === 'bezier') {
                const startPoint = contour.points[segment.startIndex];
                const endPoint = contour.points[segment.endIndex];
                
                if (!startPoint || !endPoint) return;
                
                // Контрольная точка 1
                if (segment.control1) {
                    const cp1 = this.createControlPoint(
                        segment.control1.x, 
                        segment.control1.y, 
                        'control-point', 
                        controlGroup
                    );
                    
                    cp1.setAttribute('data-contour-index', contourIndex);
                    cp1.setAttribute('data-segment-index', segmentIndex);
                    cp1.setAttribute('data-is-control1', 'true');
                    
                    // Линия от стартовой точки к контрольной
                    const line1 = this.createControlLine(
                        startPoint.x, startPoint.y,
                        segment.control1.x, segment.control1.y,
                        controlGroup
                    );
                    
                    // Скрываем если не показывать контрольные точки
                    if (!showControls) {
                        cp1.style.display = 'none';
                        line1.style.display = 'none';
                    }
                }
                
                // Контрольная точка 2
                if (segment.control2) {
                    const cp2 = this.createControlPoint(
                        segment.control2.x, 
                        segment.control2.y, 
                        'control-point', 
                        controlGroup
                    );
                    
                    cp2.setAttribute('data-contour-index', contourIndex);
                    cp2.setAttribute('data-segment-index', segmentIndex);
                    cp2.setAttribute('data-is-control2', 'true');
                    
                    // Линия от конечной точки к контрольной
                    const line2 = this.createControlLine(
                        endPoint.x, endPoint.y,
                        segment.control2.x, segment.control2.y,
                        controlGroup
                    );
                    
                    // Скрываем если не показывать контрольные точки
                    if (!showControls) {
                        cp2.style.display = 'none';
                        line2.style.display = 'none';
                    }
                }
            }
        });
    });
}


			// Исправленная функция отрисовки направляющих
			renderGuidelines() {
				const guidelineGroup = document.getElementById('guideline-group');
				if (!guidelineGroup) return;
				
				guidelineGroup.innerHTML = '';
				
				if (!document.getElementById('show-guidelines').checked) {
					return;
				}
				
				const svgCanvas = document.getElementById('svg-canvas');
				let bbox;
				
				try {
					bbox = svgCanvas.getBBox();
				} catch (e) {
					bbox = { x: -100, y: -100, width: 800, height: 800 };
				}
				
				// Базовая линия
				this.drawGuideline('horizontal', this.guidelines.baseline, 'baseline', bbox, guidelineGroup);
				
				// Основные направляющие
				this.drawGuideline('horizontal', this.guidelines.top, 'top', bbox, guidelineGroup);
				this.drawGuideline('horizontal', this.guidelines.bottom, 'bottom', bbox, guidelineGroup);
				this.drawGuideline('vertical', this.guidelines.left, 'left', bbox, guidelineGroup);
				this.drawGuideline('vertical', this.guidelines.right, 'right', bbox, guidelineGroup);
				
				// Пользовательские направляющие
				this.guidelines.custom.forEach(guide => {
					this.drawGuideline(guide.type, guide.position, guide.id, bbox, guidelineGroup, true);
				});
			}

			// Исправленная функция рисования направляющей
drawGuideline(type, position, id, bbox, container, isCustom = false) {
    const svgNS = "http://www.w3.org/2000/svg";
    const svgCanvas = document.getElementById('svg-canvas');
    
    const viewBox = svgCanvas.getAttribute('viewBox');
    let viewX = 0, viewY = 0, viewWidth = 1000, viewHeight = 1000;
    
    if (viewBox) {
        [viewX, viewY, viewWidth, viewHeight] = viewBox.split(' ').map(Number);
    }
    
    const extendedLength = 500;
    let strokeColor;
    
    if (id === 'baseline') {
        strokeColor = '#ff6b6b';
    } else if (isCustom) {
        strokeColor = '#cba6f7';
    } else if (id === 'right') {
        strokeColor = '#74c7ec';
    } else {
        strokeColor = type === 'horizontal' ? '#a6e3a1' : '#f9e2af';
    }
    
    const line = document.createElementNS(svgNS, 'line');
    
    if (type === 'horizontal') {
        line.setAttribute('x1', viewX - extendedLength);
        line.setAttribute('y1', position);
        line.setAttribute('x2', viewX + viewWidth + extendedLength);
        line.setAttribute('y2', position);
    } else {
        line.setAttribute('x1', position);
        line.setAttribute('y1', viewY - extendedLength);
        line.setAttribute('x2', position);
        line.setAttribute('y2', viewY + viewHeight + extendedLength);
    }
    
    line.setAttribute('stroke', strokeColor);
    line.setAttribute('stroke-width', id === 'baseline' ? '2' : '1');
    line.setAttribute('stroke-dasharray', id === 'baseline' ? '5,3' : '10,5');
    
    // ВАЖНО: Все пользовательские направляющие должны быть draggable
    const classes = ['guideline', type];
    if (isCustom) {
        classes.push('custom');  // Добавляем класс custom
    }
    
    // Правая направляющая И пользовательские должны быть draggable
    if (id === 'right' || isCustom) {
        classes.push('draggable');
        line.style.cursor = type === 'horizontal' ? 'ns-resize' : 'ew-resize';
        line.style.pointerEvents = 'all';  // Явно включаем события
    } else {
        line.style.pointerEvents = 'none';
    }
    
    line.setAttribute('class', classes.join(' '));
    line.setAttribute('data-id', id);
    
    container.appendChild(line);
    return line;
}

			// Обновление типов точек в контуре (полная версия)
updatePointTypesInContour(contour) {
    if (!contour || !contour.points || !contour.segments) return;
    
    // Считаем соединения
    const connectionCounts = new Array(contour.points.length).fill(0);
    
    contour.segments.forEach(segment => {
        if (segment.startIndex !== undefined && segment.endIndex !== undefined) {
            connectionCounts[segment.startIndex]++;
            connectionCounts[segment.endIndex]++;
        }
    });
    
    // Обновляем точки
    contour.points.forEach((point, pointIndex) => {
        if (!point.element) return;
        
        const connections = connectionCounts[pointIndex] || 0;
        
        let pointType;
        
        if (connections === 0) {
            pointType = 'isolated'; // ОРАНЖЕВЫЙ (как крайние)
        } else if (connections === 1) {
            pointType = 'end'; // ОРАНЖЕВЫЙ
        } else if (contour.isClosed && (pointIndex === 0 || pointIndex === contour.points.length - 1)) {
            pointType = 'end'; // ОРАНЖЕВЫЙ
        } else {
            pointType = 'middle'; // СИНИЙ
        }
        
        // Устанавливаем только тип - цвет возьмется из CSS
        point.element.setAttribute('data-point-type', pointType);

        // Только снимаем выделение
        //point.element.classList.remove('selected');
        
        // Сохраняем тип
        point.pointType = pointType;
    });
}


			// Добавление точки к пути при клике на него
addPointToPathAtClick(clickX, clickY) {
    if (!this.currentGlyph) return;
    this.clearSelection();
    // Ищем ближайший сегмент
    const closestSegment = this.findClosestSegment(clickX, clickY);
    
    if (closestSegment && closestSegment.distance < 5) {
        // Разделяем существующий сегмент
        const controlGroup = document.getElementById('control-group');
        this.splitSegmentAtPoint(closestSegment, 
            closestSegment.closestPoint.x, 
            closestSegment.closestPoint.y, 
            controlGroup
        );
    } else {
        // Создаем новую изолированную точку
        this.addPointAtPosition(clickX, clickY);
    }
}

			// Вспомогательная функция для нахождения ближайшего сегмента (улучшенная)
findClosestSegment(x, y) {
    let closest = null;
    let minDistance = 5;
    let closestPointOnCurve = null;
    
    this.pathTopology.contours.forEach((contour, contourIndex) => {
        if (!contour.segments) return;
        
        contour.segments.forEach((segment, segmentIndex) => {
            const startPoint = contour.points[segment.startIndex];
            const endPoint = contour.points[segment.endIndex];
            
            if (!startPoint || !endPoint) return;
            
            let distance, t, closestPoint;
            
            if (segment.type === 'line') {
                const result = this.getClosestPointOnLine(
                    startPoint.x, startPoint.y, 
                    endPoint.x, endPoint.y, 
                    x, y
                );
                distance = result.distance;
                t = result.t;
                closestPoint = { x: result.x, y: result.y };
                
            } else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
                const result = this.getClosestPointOnBezier(
                    startPoint.x, startPoint.y,
                    segment.control1.x, segment.control1.y,
                    segment.control2.x, segment.control2.y,
                    endPoint.x, endPoint.y,
                    x, y
                );
                distance = result.distance;
                t = result.t;
                closestPoint = { x: result.x, y: result.y };
                
            } else {
                return;
            }
            
            if (distance < minDistance) {
                minDistance = distance;
                closestPointOnCurve = closestPoint;
                closest = {
                    contourIndex,
                    segmentIndex,
                    t,
                    type: segment.type,
                    distance,
                    closestPoint: closestPoint,
                    startPoint: { x: startPoint.x, y: startPoint.y },
                    endPoint: { x: endPoint.x, y: endPoint.y },
                    control1: segment.control1,
                    control2: segment.control2
                };
            }
        });
    });
    
    return closest;
}

			// Поиск всех сегментов, связанных с точкой в контуре
			findConnectedSegmentsInContour(contour, pointIndex) {
				const connectedSegments = [];
				
				if (!contour || !contour.segments) {
					return connectedSegments;
				}
				
				contour.segments.forEach((segment, segmentIndex) => {
					if (segment.startIndex === pointIndex) {
						connectedSegments.push({
							segment: segment,
							segmentIndex: segmentIndex,
							otherIndex: segment.endIndex,
							isStart: true,
							isConnectedToPoint: true
						});
					} else if (segment.endIndex === pointIndex) {
						connectedSegments.push({
							segment: segment,
							segmentIndex: segmentIndex,
							otherIndex: segment.startIndex,
							isStart: false,
							isConnectedToPoint: true
						});
					}
				});
				
				return connectedSegments;
			}

			// =======================
			// МАТЕМАТИЧЕСКИЕ ФУНКЦИИ

			// Нахождение ближайшей точки на линии
			getClosestPointOnLine(x1, y1, x2, y2, px, py) {
				const A = px - x1;
				const B = py - y1;
				const C = x2 - x1;
				const D = y2 - y1;
				
				const dot = A * C + B * D;
				const lenSq = C * C + D * D;
				let t = 0;
				
				if (lenSq !== 0) {
					t = Math.max(0, Math.min(1, dot / lenSq));
				}
				
				const x = x1 + t * C;
				const y = y1 + t * D;
				const distance = Math.sqrt(Math.pow(x - px, 2) + Math.pow(y - py, 2));
				
				return { x, y, t, distance };
			}

			// Нахождение ближайшей точки на кривой Безье (упрощенный метод)
			getClosestPointOnBezier(x0, y0, x1, y1, x2, y2, x3, y3, px, py) {
				let bestT = 0;
				let bestDistance = Infinity;
				let bestX = x0, bestY = y0;
				
				// Дискретизация кривой
				for (let i = 0; i <= 20; i++) {
					const t = i / 20;
					const point = this.getPointOnBezier(t, x0, y0, x1, y1, x2, y2, x3, y3);
					const distance = Math.sqrt(
						Math.pow(point.x - px, 2) + Math.pow(point.y - py, 2)
					);
					
					if (distance < bestDistance) {
						bestDistance = distance;
						bestT = t;
						bestX = point.x;
						bestY = point.y;
					}
				}
				
				return { x: bestX, y: bestY, t: bestT, distance: bestDistance };
			}

			// Получение точки на кривой Безье
			getPointOnBezier(t, x0, y0, x1, y1, x2, y2, x3, y3) {
				const mt = 1 - t;
				const mt2 = mt * mt;
				const t2 = t * t;
				
				const x = mt2 * mt * x0 + 3 * mt2 * t * x1 + 3 * mt * t2 * x2 + t2 * t * x3;
				const y = mt2 * mt * y0 + 3 * mt2 * t * y1 + 3 * mt * t2 * y2 + t2 * t * y3;
				
				return { x, y };
			}

			// Разделение кривой Безье в точке t (алгоритм де Кастельжо)
			splitBezierAtT(x0, y0, x1, y1, x2, y2, x3, y3, t) {
				const x01 = x0 + t * (x1 - x0);
				const y01 = y0 + t * (y1 - y0);
				
				const x12 = x1 + t * (x2 - x1);
				const y12 = y1 + t * (y2 - y1);
				
				const x23 = x2 + t * (x3 - x2);
				const y23 = y2 + t * (y3 - y2);
				
				const x012 = x01 + t * (x12 - x01);
				const y012 = y01 + t * (y12 - y01);
				
				const x123 = x12 + t * (x23 - x12);
				const y123 = y12 + t * (y23 - y12);
				
				const x0123 = x012 + t * (x123 - x012);
				const y0123 = y012 + t * (y123 - y012);
				
				return {
					left: {
						cp1: { x: x01, y: y01 },
						cp2: { x: x012, y: y012 },
						end: { x: x0123, y: y0123 }
					},
					right: {
						cp1: { x: x123, y: y123 },
						cp2: { x: x23, y: y23 },
						start: { x: x0123, y: y0123 }
					},
					mid: { x: x0123, y: y0123 }
				};
			}

			// =================================================
			// ПРОСТЫЕ ФУНКЦИИ 
			
handleSegmentClick(e, contourIndex, segmentIndex) {
    e.stopPropagation();
    
    // Если уже выделен этот сегмент - снимаем выделение
    if (this.state.selectedSegment && 
        this.state.selectedSegment.contourIndex === contourIndex && 
        this.state.selectedSegment.segmentIndex === segmentIndex) {
        
        this.clearSegmentSelection();
        return;
    }
    
    // Очищаем все выделения
    this.clearAllSelections();
    
    // Запоминаем выбранный сегмент
    this.state.selectedSegment = { contourIndex, segmentIndex };
    
    // Визуально выделяем сегмент
    this.highlightSegment(contourIndex, segmentIndex);
    
    // Показываем кнопки для сегмента
    this.showSegmentButtons();
}

showSegmentButtons() {
    const toggleCloseBtn = document.getElementById('toggle-close');
    const deleteBtn = document.getElementById('delete-segment-btn');
    
    if (!toggleCloseBtn || !deleteBtn) return;
    
    // Показываем кнопки в зависимости от выделения
    if (this.state.selectedSegment) {
        toggleCloseBtn.style.display = 'inline-block';
        deleteBtn.style.display = 'inline-block';
        
        // Обновляем текст кнопки "Замкнуть"
        const contour = this.pathTopology.contours[this.state.selectedSegment.contourIndex];
        if (contour) {
            toggleCloseBtn.innerHTML = contour.isClosed ? 
                '<i class="fas fa-unlink"></i> Разомкнуть' : 
                '<i class="fas fa-link"></i> Замкнуть';
        }
    } else if (this.state.selectedPoint) {
        toggleCloseBtn.style.display = 'inline-block';
        deleteBtn.style.display = 'none';
        
        // Обновляем текст кнопки "Замкнуть"
        const contour = this.pathTopology.contours[this.state.selectedPoint.contourIndex];
        if (contour) {
            toggleCloseBtn.innerHTML = contour.isClosed ? 
                '<i class="fas fa-unlink"></i> Разомкнуть' : 
                '<i class="fas fa-link"></i> Замкнуть';
        }
    } else {
        toggleCloseBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
    }
}

updateSegmentButtons() {
    const toggleCloseBtn = document.getElementById('toggle-close');
    const deleteBtn = document.getElementById('delete-segment-btn');
    
    if (!toggleCloseBtn || !deleteBtn) return;
    
    // Определяем контур по выделенному элементу
    let contour = null;
    let showToggle = false;
    
    if (this.state.selectedSegment) {
        contour = this.pathTopology.contours[this.state.selectedSegment.contourIndex];
        showToggle = true;
    } else if (this.state.selectedPoint) {
        contour = this.pathTopology.contours[this.state.selectedPoint.contourIndex];
        showToggle = true;
    }
    
    // Показываем/скрываем кнопки
    if (showToggle && contour) {
        // Обновляем текст кнопки "Замкнуть/Разомкнуть"
        toggleCloseBtn.innerHTML = contour.isClosed ? 
            '<i class="fas fa-unlink"></i> Разомкнуть' : 
            '<i class="fas fa-link"></i> Замкнуть';
        
        toggleCloseBtn.style.display = 'inline-block';
        
        // Для сегмента показываем кнопку удаления
        deleteBtn.style.display = this.state.selectedSegment ? 'inline-block' : 'none';
    } else {
        // Если ничего не выделено - скрываем кнопки
        toggleCloseBtn.style.display = 'none';
        deleteBtn.style.display = 'none';
    }
}

highlightSegment(contourIndex, segmentIndex) {
    const contour = this.pathTopology.contours[contourIndex];
    if (!contour || !contour.segments[segmentIndex]) return;
    
    const segment = contour.segments[segmentIndex];
    const startPoint = contour.points[segment.startIndex];
    const endPoint = contour.points[segment.endIndex];
    
    if (!startPoint || !endPoint) return;
    
    // Создаем простую красную линию поверх сегмента
    const highlight = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    highlight.setAttribute('class', 'segment-highlight');
    highlight.id = 'selected-segment';
    
    if (segment.type === 'line') {
        highlight.setAttribute('d', `M ${startPoint.x} ${startPoint.y} L ${endPoint.x} ${endPoint.y}`);
    } else if (segment.type === 'bezier' && segment.control1 && segment.control2) {
        highlight.setAttribute('d', 
            `M ${startPoint.x} ${startPoint.y} C ${segment.control1.x} ${segment.control1.y} ${segment.control2.x} ${segment.control2.y} ${endPoint.x} ${endPoint.y}`
        );
    }
    
    const pathGroup = document.getElementById('path-group');
    pathGroup.appendChild(highlight);
}

deleteSelectedSegment() {
    if (!this.state.selectedSegment) return;
    this.saveToHistory('delete_segment', 'Удаление сегмента');
    const { contourIndex, segmentIndex } = this.state.selectedSegment;
    const contour = this.pathTopology.contours[contourIndex];
    
    if (!contour || !contour.segments[segmentIndex]) return;
    
    // Удаляем сегмент (используем существующую функцию)
    this.deleteSegment(contourIndex, segmentIndex);
    
    // Очищаем выделение
    this.clearSegmentSelection();
    
    // Обновляем путь
    this.updatePathFromTopology();
}

clearSegmentSelection() {
    // Убираем подсветку
    const highlight = document.getElementById('selected-segment');
    if (highlight) highlight.remove();
    
    // Очищаем состояние
    this.state.selectedSegment = null;
}

hideSegmentButtons() {
    const toggleCloseBtn = document.getElementById('toggle-close');
    const deleteBtn = document.getElementById('delete-segment-btn');
    
    if (toggleCloseBtn) toggleCloseBtn.style.display = 'none';
    if (deleteBtn) deleteBtn.style.display = 'none';
}


setupViewport() {
    const svgCanvas = document.getElementById('svg-canvas');
    if (!this.currentGlyph) return;
    
    // Добавляем дополнительные отступы для подложки
    const paddingX = 1500;
    const paddingY = 250;
    const minX = this.guidelines.left - paddingX;
    const maxX = this.guidelines.right + paddingX;
    const minY = this.guidelines.top - paddingY;
    const maxY = this.guidelines.bottom + paddingY;
    
    const width = maxX - minX;
    const height = maxY - minY;
    
    svgCanvas.setAttribute('viewBox', `${minX} ${minY} ${width} ${height}`);
    
    // Автомасштабирование для холста - НЕЗАВИСИМОЕ по X и Y
    const container = document.querySelector('.canvas-container');
    if (container) {
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        
        const zoomScale = parseInt(document.getElementById('zoom-scale').value) / 100;
        
        // РАЗДЕЛЬНОЕ масштабирование:
        const scaleX = (containerWidth / width) * zoomScale;
        const scaleY = (containerHeight / height) * zoomScale;
        
        // Применяем РАЗНЫЕ масштабы для сохранения пропорций viewBox
        svgCanvas.style.width = `${width * scaleX}px`;
        svgCanvas.style.height = `${height * scaleY}px`;
        
        // Центрируем
        svgCanvas.style.position = 'absolute';
        svgCanvas.style.left = '50%';
        svgCanvas.style.top = '50%';
        svgCanvas.style.transform = `translate(-50%, -50%) scale(${zoomScale})`;
        svgCanvas.style.transformOrigin = 'center';
    }
}

			clearSelection() {
				document.querySelectorAll('.point.selected, .control-point.selected').forEach(point => {
					point.classList.remove('selected');
				});
				
				this.state.selectedPoint = null;
				
				// Скрываем кнопку
				const toggleCloseBtn = document.getElementById('toggle-close');
				if (toggleCloseBtn) {
					toggleCloseBtn.style.display = 'none';
				}
			}

			resetView() {
				this.renderGlyph();
			}

// Новый метод - диалог выбора метрик
showMetricsDialog(metrics, fontName, callback = null) {
    const isTemplateCreation = !!callback; // Если есть callback - это создание шаблона
    
    const modalHtml = `
        <div id="metrics-modal" class="modal" style="display:flex;">
            <div class="modal-content" style="max-width:500px;">
                <div class="modal-header">
                    <h3><i class="fas fa-ruler"></i> ${isTemplateCreation ? 'Использовать метрики шрифта?' : 'Использовать метрики подложки?'}</h3>
                </div>
                <div style="padding:20px;">
                    <p>Шрифт "<strong>${fontName}</strong>" имеет свои метрики:</p>
                    
<div style="background:#313244;padding:15px;border-radius:8px;margin:15px 0;">
    <div style="font-size:12px;color:#a6adc8;margin-bottom:5px;">Метрики шрифта:</div>
    ${metrics.allMetrics ? `
        <div style="font-size:11px;line-height:1.4;">
            <div>Typo: ${metrics.allMetrics.typo.ascent !== null ? `${metrics.allMetrics.typo.ascent}/${metrics.allMetrics.typo.descent}` : 'N/A'}</div>
            <div>Win: ${metrics.allMetrics.win.ascent !== null ? `${metrics.allMetrics.win.ascent}/${metrics.allMetrics.win.descent}` : 'N/A'}</div>
            <div>HHEA: ${metrics.allMetrics.hhea.ascent !== null ? `${metrics.allMetrics.hhea.ascent}/${metrics.allMetrics.hhea.descent}` : 'N/A'}</div>
        </div>
        <div style="margin-top:10px;font-size:11px;color:#a6e3a1;">
            Будут использованы: <strong>${metrics.ascent}/${metrics.descent}</strong>
        </div>
    ` : `
        <div>Ascent: ${metrics.ascent}, Descent: ${metrics.descent}</div>
    `}
</div>
                    
                    <div style="margin:20px 0;">
                        <label style="display:flex;align-items:center;gap:10px;cursor:pointer;">
                            <input type="checkbox" id="use-metrics-checkbox" checked>
                            <span>${isTemplateCreation ? 'Использовать метрики шрифта для нового шрифта' : 'Использовать метрики подложки для направляющих'}</span>
                        </label>
                        <div style="font-size:12px;color:#a6adc8;margin-top:5px;margin-left:30px;">
                            ${isTemplateCreation ? 
                                'Новый шрифт будет создан с этими метриками' : 
                                'Направляющие будут установлены на ' + metrics.ascent + '/' + metrics.descent
                            }
                        </div>
                    </div>
                    
                    <div style="display:flex;gap:10px;margin-top:20px;">
                        <button id="apply-metrics" style="flex:1;">
                            <i class="fas fa-check"></i> ${isTemplateCreation ? 'Продолжить' : 'Применить'}
                        </button>
                        <button id="skip-metrics" class="secondary" style="flex:1;">
                            <i class="fas fa-times"></i> ${isTemplateCreation ? 'Оставить стандартные' : 'Оставить текущие'}
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = document.getElementById('metrics-modal');
    
    // Обработчики
    document.getElementById('apply-metrics').addEventListener('click', () => {
        const useMetrics = document.getElementById('use-metrics-checkbox').checked;
        
        if (callback) {
            // Это создание шаблона - вызываем callback
            modal.remove();
            callback(useMetrics);
        } else {
            // Это обычная загрузка подложки
            if (useMetrics && metrics) {
                this.fontData.ascent = metrics.ascent;
                this.fontData.descent = metrics.descent;
                this.guidelines.top = this.fontData.unitsPerEm - this.fontData.ascent;
                this.guidelines.bottom = this.fontData.unitsPerEm - this.fontData.descent;
                this.updateGuidelineControls();
                this.renderGuidelines();
            }
            modal.remove();
            document.getElementById('font-modal').style.display = 'none';
            this.updateUnderlay();
        }
    });
    
    document.getElementById('skip-metrics').addEventListener('click', () => {
        if (callback) {
            modal.remove();
            callback(false);
        } else {
            modal.remove();
            document.getElementById('font-modal').style.display = 'none';
            this.updateUnderlay();
        }
    });
    
    // Закрытие по клику вне окна
    modal.addEventListener('click', (e) => {
        if (e.target === modal) {
            modal.remove();
            if (callback) callback(false);
        }
    });
}

renameFont() {
    // Создаем модальное окно
    const modalHtml = `
        <div id="rename-font-modal" class="modal" style="display:flex;">
            <div class="modal-content" style="max-width:400px;">
                <div class="modal-header">
                    <h3><i class="fas fa-pen"></i> Переименовать шрифт</h3>
                    <button class="close-modal">&times;</button>
                </div>
                <div style="padding:20px;">
                    <div class="property" style="margin-bottom:20px;">
                        <label for="new-font-name">Новое название</label>
                        <input type="text" id="new-font-name" 
                               value="${this.fontData.name}" 
                               placeholder="Название шрифта" 
                               style="width:100%;">
                        <div id="name-error" style="color:#f38ba8;font-size:12px;margin-top:5px;display:none;">
                            Введите название шрифта
                        </div>
                    </div>
                    <div style="display:flex;gap:10px;margin-top:20px;">
                        <button id="confirm-rename" style="flex:1;">
                            <i class="fas fa-check"></i> Сохранить
                        </button>
                        <button class="secondary close-modal" style="flex:1;">
                            Отмена
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Удаляем старую модалку если есть
    const oldModal = document.getElementById('rename-font-modal');
    if (oldModal) oldModal.remove();
    
    // Добавляем новую
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    
    const modal = document.getElementById('rename-font-modal');
    const nameInput = modal.querySelector('#new-font-name');
    const errorDiv = modal.querySelector('#name-error');
    
    // Фокус и выделение текста
    setTimeout(() => {
        nameInput.focus();
        nameInput.select();
    }, 50);
    
    // Обработчики закрытия
    const closeModal = () => modal.remove();
    
    modal.querySelectorAll('.close-modal').forEach(btn => {
        btn.addEventListener('click', closeModal);
    });
    
    // Обработчик сохранения
    modal.querySelector('#confirm-rename').addEventListener('click', () => {
        const newName = nameInput.value.trim();
        
        // Валидация
        if (!newName) {
            errorDiv.style.display = 'block';
            nameInput.style.borderColor = '#f38ba8';
            nameInput.focus();
            return;
        }
        
        // Проверяем, изменилось ли имя
        if (newName === this.fontData.name) {
            closeModal();
            return;
        }
        
        // Обновляем имя шрифта
        this.fontData.name = newName;
        // Закрываем окно
        closeModal();
        // Обновляем отображение - ИСПРАВЛЕННАЯ СТРОКА
        const fontNameElement = document.getElementById('font-name');
        if (fontNameElement) {
            fontNameElement.textContent = newName;
        }

        // Показываем уведомление
        this.showNotification(`Название шрифта изменено на "${newName}"`, 'success');
    });
    
    // Валидация при вводе
    nameInput.addEventListener('input', () => {
        errorDiv.style.display = 'none';
        nameInput.style.borderColor = '#45475a';
    });
    
    // Обработка нажатия Enter
    nameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
            e.preventDefault();
            modal.querySelector('#confirm-rename').click();
        }
    });
    
    // Закрытие по клику вне окна
    modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
    });
    
    // Закрытие по Escape
    const escapeHandler = (e) => {
        if (e.key === 'Escape') {
            closeModal();
            document.removeEventListener('keydown', escapeHandler);
        }
    };
    document.addEventListener('keydown', escapeHandler);
}

// Показывает модальное окно подтверждения
async showConfirmDialog(message, title = 'Подтверждение') {
    return new Promise((resolve) => {
        const modalId = 'confirm-dialog-' + Date.now();
        
        const modalHtml = `
            <div id="${modalId}" class="modal" style="display:flex;z-index:9999;">
                <div class="modal-content" style="max-width:400px;">
                    <div class="modal-header">
                        <h3><i class="fas fa-question-circle"></i> ${title}</h3>
                        <button class="close-confirm">&times;</button>
                    </div>
                    <div style="padding:20px;">
                        <p>${message}</p>
                        <div style="display:flex;gap:10px;margin-top:20px;">
                            <button id="confirm-yes" class="confirm-btn" style="flex:1;">
                                <i class="fas fa-check"></i> Да
                            </button>
                            <button id="confirm-no" class="confirm-btn secondary" style="flex:1;">
                                <i class="fas fa-times"></i> Нет
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', modalHtml);
        const modal = document.getElementById(modalId);
        
        const closeModal = (result) => {
            modal.remove();
            resolve(result);
        };
        
        // Да
        document.getElementById('confirm-yes').addEventListener('click', () => {
            closeModal(true);
        });
        
        // Нет
        document.getElementById('confirm-no').addEventListener('click', () => {
            closeModal(false);
        });
        
        // Крестик
        modal.querySelector('.close-confirm').addEventListener('click', () => {
            closeModal(false);
        });
        
        // Клик по фону
        modal.addEventListener('click', (e) => {
            if (e.target === modal) closeModal(false);
        });
        
        // Escape
        const escapeHandler = (e) => {
            if (e.key === 'Escape') {
                closeModal(false);
                document.removeEventListener('keydown', escapeHandler);
            }
        };
        document.addEventListener('keydown', escapeHandler);
    });
}

// Показывает уведомление (всплывашку)
showNotification(message, type = 'info', duration = 5000) {
    const colors = {
        success: '#a6e3a1',
        error: '#f38ba8',
        warning: '#f9e2af',
        info: '#89b4fa'
    };
    
    const icons = {
        success: 'fa-check-circle',
        error: 'fa-exclamation-circle',
        warning: 'fa-exclamation-triangle',
        info: 'fa-info-circle'
    };
    
    const notificationId = 'notification-' + Date.now();
    
    const notificationHtml = `
        <div id="${notificationId}" style="
            position: fixed;
            top: 20px;
            right: 20px;
            background: ${colors[type] || colors.info};
            color: #1e1e2e;
            padding: 12px 20px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            z-index: 10000;
            max-width: 400px;
            animation: slideIn 0.3s ease-out;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
        ">
            <i class="fas ${icons[type] || icons.info}"></i>
            <span style="flex: 1;">${message}</span>
            <button style="background: none; border: none; color: #1e1e2e; cursor: pointer; font-size: 16px;" 
                    onclick="document.getElementById('${notificationId}').remove()">
                ×
            </button>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', notificationHtml);
    
    // Автоудаление через указанное время
    setTimeout(() => {
        const notification = document.getElementById(notificationId);
        if (notification) {
            notification.style.animation = 'slideOut 0.3s ease-out';
            setTimeout(() => notification.remove(), 300);
        }
    }, duration);
}

showGroupSelection(fontName) {
    // Группы символов
    const groups = [
        { id: 'latin', name: 'Английские буквы', symbols: this.getSymbolRange(65, 90).concat(this.getSymbolRange(97, 122)), default: true },
        { id: 'cyrillic', name: 'Русские буквы', symbols: this.getCyrillic(), default: true },
        { id: 'numbers', name: 'Цифры', symbols: this.getSymbolRange(48, 57), default: true },
        { id: 'basic', name: 'Основные знаки', symbols: '!?.,:;-"\'()[]{}@#$%^&*_+=|\\/~`<>'.split(''), default: true },
        { id: 'extra', name: 'Дополнительно', symbols: ['№','©','®','™','€','£','¥','°','±','×','÷','…','←','→','↑','↓'], default: false }
    ];
    
    // Создаем окно выбора групп
    const modalHtml = `
        <div id="group-modal" class="modal" style="display:flex;">
            <div class="modal-content" style="max-width:500px;">
                <div class="modal-header">
                    <h3><i class="fas fa-check-square"></i> Выберите символы</h3>
                    <div style="font-size:14px;color:#a6adc8;">Шрифт: ${fontName}</div>
                </div>
                <div style="padding:20px;">
                    ${groups.map(group => `
                        <div style="margin-bottom:15px;padding:15px;background:#313244;border-radius:8px;">
                            <label style="display:flex;align-items:center;cursor:pointer;">
                                <input type="checkbox" 
                                       data-group="${group.id}" 
                                       ${group.default ? 'checked' : ''}
                                       style="margin-right:10px;">
                                <div>
                                    <div style="font-weight:bold;color:#cdd6f4;">${group.name}</div>
                                    <div style="font-size:12px;color:#a6adc8;">
                                        ${group.symbols.length} символов: 
                                        <span style="font-family:monospace;">${group.symbols.slice(0, 20).join('')}${group.symbols.length > 20 ? '...' : ''}</span>
                                    </div>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                    
                    <div style="display:flex;gap:10px;margin-top:20px;">
                        <button id="create-font-btn" style="flex:1;">
                            <i class="fas fa-check"></i> Создать
                        </button>
                        <button class="secondary" id="cancel-btn" style="flex:1;">
                            Отмена
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHtml);
    const modal = document.getElementById('group-modal');
    
    // Обработчики
    document.getElementById('create-font-btn').onclick = () => {
        const selectedGroups = [];
        modal.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
            const groupId = cb.getAttribute('data-group');
            const group = groups.find(g => g.id === groupId);
            if (group) selectedGroups.push(group);
        });
        
        if (selectedGroups.length === 0) {
            alert('Выберите хотя бы одну группу');
            return;
        }
        
        modal.remove();
        this.generateFontFromTemplate(fontName, selectedGroups);
    };
    
    document.getElementById('cancel-btn').onclick = () => {
        modal.remove();
    };
    
    modal.onclick = (e) => {
        if (e.target === modal) modal.remove();
    };
}

        }

        // Создаем экземпляр редактора при загрузке страницы
        let fontEditor;
        document.addEventListener('DOMContentLoaded', function() {
            fontEditor = new FontEditor();
        });
    </script>
</body>
</html>
